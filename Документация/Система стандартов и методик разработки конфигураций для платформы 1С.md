# Система стандартов и методик разработки конфигураций для платформы 1С

*Конвертировано в улучшенном режиме: Система стандартов и методик разработки конфигураций для платформы 1С.pdf*

*Страниц: 357 | Таблиц: 0*

---

## Общие требования к конфигурации

- 1 . 1 . Конфигурация должна использовать только штатные и документированные возможности платформы 1С:Предприятие .

Область применения (уточнение): управляемое приложение , обычное приложение .

- 1 . 2 . Конфигурация должна быть одинаково рассчитана на работу со всеми СУБД , операционными системами , веб ­ браузерами и различными режимами работы , которые поддерживает платформа 1С:Предприятие . В частности , в веб ­ клиенте все ключевые возможности конфигурации должны быть доступны пользователям без использования расширения работы с файлами , а взаимодействие с пользователем должно быть организовано асинхронно . Дополнительные материалы:
- Список поддерживаемых операционных систем и СУБД
- Особенности работы с различными СУБД см . в приложении 8 документации по платформе 1С:Предприятие 8 . 3
- Особенности режима низкой скорости соединения и работы вебклиента см . в приложении 7 (там же)
- Особенности разработки конфигураций для ОС Linux
- 1 . 3 . Конфигурация не должна содержать ошибок , обнаруживаемых при проверке конфигурации (конфигуратор – меню Конфигурация –

Проверка конфигурации … ) . Кроме отдельных , обоснованных случаев:

- Обработчики событий модуля формы , подключаемые из кода;
- Ограничение на использование модальных окон и синхронных вызовов;
- Ограничение на установку признака «Вызов сервера»;
- Несущественные предупреждения проверки конфигурации .
- 1 . 4 . Для поддержки обратной совместимости с различными собственными и сторонними решениями , внешними обработками и отчетами ,

разработанными

на

предыдущих версиях платформы 1С:Предприятие 8

- и 8 . 1 , конфигурация также должна поддерживать запуск в режимах обычного приложения (толстый клиент) и внешнего соединения для администраторов (пользователей с полными правами) . Для этого рекомендуется
- свойство конфигурации «Использовать управляемые формы в обычном приложении» установить в Истина , а свойство «Использовать обычные формы в управляемом режиме» – в Ложь .
- придерживаться общей схемы установки признаков общих модулей ,
- а саму разработку в Конфигураторе вести в режиме редактирования для обоих режимов запуска – управляемое и обычное приложение

.

0

(меню Сервис – Параметры – закладка Общие) .

Отказ от поддержки запуска конфигурации в режимах обычного приложения и внешнего соединения для администраторов возможен только в отдельных , обоснованных случаях .

- 1 . 5 . При проектировании тех или иных технических решений , при разработке пользовательского интерфейса , отчетов и т . п . не рекомендуется отходить от умолчаний платформы 1С:Предприятие . Реализация альтернативных вариантов технических решений допустима только в отдельных , обоснованных случаях .
- 2 . 1 . Имена , синонимы , комментарии объектов метаданных , общих модулей , а также любая текстовая информация (которая выводится пользователю или предназначена для разработчика/внедренца) должны быть составлены по правилам русского языка и , в частности , не должны содержать грамматических ошибок .
- 2 . 2 . В конфигурации не должно быть неиспользуемых объектов метаданных (справочников , документов , разделов командного интерфейса и т . п . ) и программного кода (общих модулей , процедур , функций , переменных и т . п . ) , который не используется ни в самой конфигурации , ни для интеграции с другими системами .
- 2 . 3 . Объекты метаданных верхнего уровня , такие как Справочники , Документы , Общие модули и т . д . рекомендуется сортировать в дереве метаданных по имени . Подчиненные объекты метаданных , такие как реквизиты , измерения , формы , располагаются в дереве метаданных в соответствии с проектной логикой .

## Исключение составляют:

- общие реквизиты (т . к . для общих реквизитов , являющихся разделителями , порядок следования в дереве метаданных должен подбираться , исходя из требуемого порядка установки параметров сеанса) .
- объекты с префиксом " Удалить " , которые допустимо размещать в конце соответствующей ветки метаданных;

## Имена объектов метаданных в конфигурациях

См

также: общие правила наименования метаданных

,

неправильно:

| п/п            | Объекты метаданных                             | Правила наименования                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   | Область применения (уточнение)                                                        |
|----------------|------------------------------------------------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|---------------------------------------------------------------------------------------|
| 1 .            | Подсистемы                                     | Согласно общим  правилам  наименования  метаданных .  Например: Финансы ,  Маркетинг ,  НастройкаИАдминистирование . См также:  Использование подсистем                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                | Управляемое приложение  Обычное приложение                                            |
| 2 .            | Общие модули                                   | См .  Правила создания общих модулей                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |                                                                                       |
| 3 .            | Параметры сеанса                               | Согласно общим  правилам  наименования  метаданных .  Например: ТекущийПользователь ,  ОбменДаннымиВключен ,                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |                                                                                       |
| 4 .            |                                                | ПредлагатьУстановкуРасширенияРаботыСФайлами .                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |                                                                                       |
|                |                                                | См .  также:  Использование параметров сеанса                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |                                                                                       |
|                | Роли                                           | При  именовании ролей рекомендуется  придерживаться двух схем: «прикладные» роли ,  пользователей информационной системы ,  следует именовать от названия должности ,                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |                                                                                       |
|                |                                                | соответствующие должностным обязанностям определенной категории например  Бухгалтер ,  Кассир ,  Администратор . роли ,  дающие доступ  к более  «мелким» функциональным блокам для более  «тонкой» настройки  прав доступа  пользователей ,  рекомендуется  именовать от описания разрешаемого  действия .  Например: ДобавлениеИзменениеНСИ ,  ЧтениеДополнительныхСведений ,  ИнтерактивноеОткрытиеВнешнихОтчетовИОбработок .                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       |                                                                                       |
| 5 .  6 .       | Общие реквизиты  Планы обмена  Критерии отбора | Согласно общим  правилам  именования  метаданных .  Имена  планов обмена рекомендуется  называть по следующим  принципам: в  названии  планов обмена РИБ (признак Распределенная ИБ включен) кратко описываются  правила синхронизации данных .  Например:  Полный ,  ПоОрганизациям ,  ПоСкладамИОрганизациям имена  планов обмена  между различными  конфигурациями следует формировать из имени источника  и  имени  приемника .  Имена  планов обмена  в  источнике и  приемнике должны быть одинаковыми .  Например:  ОбменУправлениеНебольшойФирмойБухгалтерияПредприятия ,  ОбменУправлениеТорговлейРозничнаяТорговля . При  необходимости организации обмена с разными  версиями (редакциями) конфигураций ,  к  именам  приемника  и  источника добавляются  номера  версий (редакций) .  Например ,  ОбменУправлениеТорговлей110РозничнаяТорговля10 (обмен данными  между конфигурациями редакций 11 . 0 и 1 . 0) Имена  критериев отбора рекомендуется задавать во множественном  числе ,  образуя  имя от  названия списка объектов ,  которые он отбирает .  Например: СвязанныеДокументы ,  ФайлыВТоме . | Управляемое приложение  Обычное приложение Управляемое приложение  Обычное приложение |
| 8 .            | Регламентные задания                           | Имена  подписок на события рекомендуется задавать от сути  выполняемого действия  и образовывать от неопределенной формы  глагола .  Например ,  неправильно  ЗапретРедактированияРеквизитовОбъектовПередЗаписьюОбъекта  НастройкаПорядкаЭлементовПередЗаписью                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         |                                                                                       |
| 11 .           |                                                |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        |                                                                                       |
| 7 .  9 .  10 . | Подписки  на события                           | ПроверитьИзменениеРеквизитовОбъекта  ПересчитатьПорядковыйНомерЭлемента Имена регламентных заданий рекомендуется давать в единственном  числе и образовывать от существительного .  Например ,  неправильно  УстановитьПериодРасчитанныхИтогов  УведомитьИсполнителейОНовыхЗадачах правильно  УстановкаПериодаРасчитанныхИтогов  УведомлениеИсполнителейОНовыхЗадачах Имена функциональных опций ,  связанных с константами ,  рекомендуется образовывать от описания  включаемой (или  выключаемой) с их помощью функциональности .  Например ,  функциональных опций типа Булево:                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    | Управляемое приложение  Обычное приложение                                            |
|                |                                                | для  ИспользоватьБизнесПроцессыИЗадачи  ИспользоватьВерсионированиеОбъектов                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            |                                                                                       |
|                |                                                | РегистрСведений . НазначениеДополнительныхОбработок . Измерение . ТипОбъекта и РегистрСведений . НастройкаВерсионированияОбъектов . Измерение . ТипОбъекта                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             | ,                                                                                     |
|                |                                                | правильно:                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             | Управляемое приложение  Обычное приложение                                            |
|                |                                                | Организация  –  связан со справочником Организации;  ТипОбъектаКонфигурации  –  связан с двумя ресурсами регистров сведений: См .  также:  Использование функциональных опций числе и образовывать от  .  При этом  не следует называть их так же ,  как называются другие типы данных                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 |                                                                                       |
|                |                                                | Имена определяемых типов рекомендуется задавать в единственном  их назначения (например:  «Строка» ,  «Число» ,  … ) ,  и  не использовать слова ,  от удаления  которых смысл  не  меняется (например:  «Тип » «Объект » «Ссылка » )                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |                                                                                       |
|                | Функциональные опции                           |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        |                                                                                       |
| 12 .           | Определяемые типы                              |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        |                                                                                       |

Например

Имена

,

неправильно:

констант рекомендуется задавать по следующим

|      |                     | Строка25 ,  СсылкиНаКонтактыВзаимодействий Правильно:  АртикулНоменклатуры  –  строка фиксированной длины 25 символов ,  которая  справочнике номенклатуры организации ,  справочниках номенклатуры  поставщиков ,  обработках ,  предназначенных для работы с номенклатурой .  КонтактВзаимодействий  –  составной тип ,  включающий в себя ссылки  на различные справочники ,  элементы  которых являются  контактами  телефонных звонков ,  встреч  и  пр . ) .  Например ,  Пользователи ,  Партнеры  и другие . См .  также:  Использование определяемых типов Согласно общим  правилам  наименования  метаданных .  Например: ХранилищеВариантовОтчетов .   |                                            |
|------|---------------------|-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|--------------------------------------------|
|      |                     | используется  отчетов  взаимодействий (электронных писем , КонтактныеЛицаПартнеров                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |                                            |
| 13 . | Хранилища  настроек |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   | Управляемое приложение  Обычное приложение |
| 14 . |                     | .  При этом следует  названии форм слов ,  от удаления  которых смысл  не меняется ,  например:  «Форма … » ,  «Диалог … » .                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      |                                            |
|      | Общие формы         | Имена общих форм рекомендуется образовывать от существительных избегать в  … «Окно Примеры:  НастройкаСистемы МоиНастройки ПараметрыПроксиСервера                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 |                                            |
| 17   | Интерфейсы          | Например ,  ПараметрыОбменаДанными ,  Печать . Согласно общим  правилам  наименования  метаданных .                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               | Обычное приложение                         |
| .    |                     | См также: Общие правила  построения  интерфейсов Общие интерфейсы                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 |                                            |
| 18 . | Общие макеты        | Имена общих макетов рекомендуется образовывать от существительных ,  дающих краткое  представление о содержимом  или  назначении  макета .  При этом следует избегать в  названии слов ,  от удаления  которых смысл  не меняется ,  например:  «Макет … » . Примеры: ДополнительнаяОбработка КомпонентаTWAIN                                                                                                                                                                                                                                                                                                                                                     |                                            |
| 19 . | Общие картинки      | Согласно общим  правилам  наименования  имен  метаданных .  Например:  Найти  –  универсальная  картинка для  команд поиска ,  для  использования  в различных  подсистемах конфигурации .  ЗакрепитьВариантОтчета  –  картинка  команды  «Закрепить вариант отчета» .                                                                                                                                                                                                                                                                                                                                                                                            |                                            |
| 19 . | Общие картинки      | Допускается указывать спецификаторы размера ,  например:  Папка  –  картинка размером 16x16 пикселей  УправлениеПоиском32  –  картинка размером 32x32 пикселей  ДлительнаяОперация48  –  картинка размером 48x48 пикселей                                                                                                                                                                                                                                                                                                                                                                                                                                         |                                            |
| 19 . | Общие картинки      | Для обозначения  картинок­коллекций к имени добавляется  префикс Коллекция .  Например:  КоллекцияВариантыВажностиЗадачи . При этом следует избегать в  названии общих картинок слов ,  от удаления  которых смысл  не  «Изображение                                                                                                                                                                                                                                                                                                                                                                                                                              |                                            |
| 20 . | XDTO ­ пакеты       | Имена XDTO ­ пакетов рекомендуется образовывать на русском языке от существительных ,  дающих краткое представление о содержимом  или  назначении  пакета .  При этом следует  избегать в  названии слов ,  от удаления  которых смысл  не меняется ,  например:  «Пакет … » ,  «ХDTO … » . Пример: Файлы                                                                                                                                                                                                                                                                                                                                                         | Управляемое приложение  Обычное приложение |
| 21 . | Web ­ сервисы       | Имена Web­сервисов рекомендуется образовывать на английском языке от существительных ,  дающих краткое представление об их назначении .  Не рекомендуется  использовать кириллицу так как сторонние информационные системы  могут ее не поддерживать ,  а также слова ,  от удаления  которых смысл  не меняется ,  например:  «Service» ,  «WebService» .                                                                                                                                                                                                                                                                                                        | Управляемое приложение  Обычное приложение |
| 21 . | Web ­ сервисы       | Примеры:  Files ,  Accounts ,  FlightStatus . Имена операций Web­сервисов ,  а также их параметры рекомендуется также писать на английском языке .                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |                                            |
| 21 . | Web ­ сервисы       | Пример: GetCurrencyRate                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |                                            |
| 22 . | WS ­ ссылки         | Имена WS ­ ссылок рекомендуется образовывать от существительных ,  дающих краткое  представление о назначении Web­сервиса .  При этом следует избегать в  названии слов ,  от удаления  которых смысл  не меняется ,  например:  «WebСервис … » ,  «Сервис … » ,  «Ссылка … » .                                                                                                                                                                                                                                                                                                                                                                                   |                                            |
| 23 . | Элементы стиля      | Имена элементов стиля рекомендуется образовывать от существительных ,  дающих краткое  представление об их назначении .  Например:  ВыполненнаяЗадача ,  ПоясняющийТекст ,  НеСтартованныйБизнесПроцесс . Также в  имени элемента стиля допускается уточнение по поводу определяемого параметра стиля ,                                                                                                                                                                                                                                                                                                                                                           | Управляемое приложение  Обычное приложение |
| 24 . | Стили               | См .  также: Элементы стиля (для режима обычного приложения см .  Стили) Согласно общим  правилам  наименования  метаданных .                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     | Обычное приложение                         |

.

26

Константы

принципам:

26

Константы

Имена

констант рекомендуется задавать по следующим

принципам:

Не рекомендуется образовывать представление от имени отчета с уточнением специфики

| .    |             | Если  константа связана с функциональной опцией ,  то созвучно функциональной опции;  В остальных случаях имя  константы образуется от описания объекта ,  значение которого она хранит .  Например: ТипХраненияФайлов ,  НастройкаПроксиСервера .  Если тип значения  константы  –  Булево ,  то имя  может быть образовано от  неопределенной формы  глагола ,  обозначающего включаемое или  выключаемое действие .  Например:  ВыполнятьПроверкуЭЦПНаСервере ,  ИзвлекатьТекстыФайловНаСервере ,  ИзменятьЗаданияЗаднимЧислом . При этом следует избегать в  названии  констант слов ,  от удаления  которых смысл  не меняется ,  например:  «Константа … » . числе и образовывать от   |                                            |
|------|-------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|--------------------------------------------|
| 27 . | Справочники | Имена справочников рекомендуется давать во множественном  описания списка объектов ,  значения  которых хранятся  в справочнике .  Например:  Валюты ,  ГруппыИсполнителейЗадач ,  ПрофилиГруппДоступа ,  Пользователи . При этом следует избегать в  названии справочников слов ,  от удаления  которых смысл  не  меняется ,  например:  «Справочник … » .                                                                                                                                                                                                                                                                                                                                 |                                            |
| 28 . | Документы   | ,  напротив ,  даются  в единственном  числе .  Например: ЗаказПокупателя ,  Анкета . При этом следует избегать в  названии справочников слов ,  от удаления  которых смысл  не  ,  например:  «Документ … » . выборе имени документа следует различать два случая:                                                                                                                                                                                                                                                                                                                                                                                                                          |                                            |
| 28 . | Документы   | Имена документов ,  ПеремещениеТоваров                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       |                                            |
| 28 . | Документы   | меняется При  1 В первую очередь который                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |                                            |
| 28 . | Документы   | отражается  в системе этим документом .  При этом само имя должно быть максимально  лаконичным ,  рекомендуется  избегать слов  «Накладная … » ,  «Акт … »  и т . п . Например ,  в системе автоматизирован  процесс «Сверка  взаиморасчетов» ,  который завершается  подписанием сторонами ,  участвующими  в сверке ,  печатного документа  «Акт сверки товаров» .  Поскольку в данном случае в системе документом фиксируется  именно процесс ,  то                                                                                                                                                                                                                                       |                                            |
| 31 . | Отчеты      | 1 .  Имена отчетов  и  вариантов отчетов рекомендуется образовывать от имени существительного .  Например: ДинамикаИзмененийФайлов ,  СписокЗависшихЗадач ,  СправкаОбИсполнительскойДисциплине . 2 .  Рекомендуется  предусматривать вывод заголовка ,  если отчет или  вариант отчета  предназначен для  печати .                                                                                                                                                                                                                                                                                                                                                                          | Управляемое приложение  Обычное приложение |

|      |                                           | Не рекомендуется образовывать представление от имени отчета с уточнением специфики варианта отчета  в скобках или с использованием других разделителей .  Это может  перегрузить списки  вариантов отчетов  повторениями ,  разделителями  и уточнениями , снизив  простоту визуального восприятия . 4 При этом следует избегать в  названиях отчетов  и  вариантов отчетов слов от удаления   |                                            |
|------|-------------------------------------------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|--------------------------------------------|
| 32 . | Обработки                                 | Имена обработок рекомендуется образовывать от имени существительного .  Например:  КонтрольЖурналаРегистрации ,  РегламентныеИФоновыеЗадания ,  УправлениеИтогамиИАгрегатами .                                                                                                                                                                                                                 |                                            |
|      |                                           | При этом следует избегать в  названии обработок слов ,  от удаления  которых смысл  не  меняется ,  например:  «Обработка … » .                                                                                                                                                                                                                                                                |                                            |
|      |                                           | Если форму обработки  предполагается открывать из панели  навигации той или                                                                                                                                                                                                                                                                                                                    |                                            |
|      |                                           | иной формы ,  или раздела  командного интерфейса ,  то имя обработки должно совпадать с именем  команды для ее открытия .  Например ,  команда РегламентныеИФоновыеЗадания открывает обработку  РегламентныеИФоновыеЗадания .                                                                                                                                                                  |                                            |
| 33 . | Планы  видов характеристик                | Имена  планов  видов характеристики рекомендуется задавать во множественном  числе и образовывать от описания списка объектов ,  которые перечисляются  в  плане видов характеристик .  Например:  ВидыДоступа ,  ВопросыДляАнкетирования ,                                                                                                                                                    | Управляемое приложение  Обычное приложение |
| 34 . |                                           | Для дополнительных уточнений можно использовать свойство Пояснение ,  значение которого выводится  в  подсказке к команде открытия  плана счетов .  Например:                                                                                                                                                                                                                                  | Управляемое приложение  Обычное приложение |
|      |                                           | НалоговыйУчет  синоним  " План счетов  налогового учета "                                                                                                                                                                                                                                                                                                                                      |                                            |
| 35 . | Планы  видов расчета                      | Имена  планов  видов расчета рекомендуется задавать во множественном  числе и образовывать  от описания списка объектов ,  которые перечисляются  в  плане видов расчета .  Например: ОсновныеНачисления ,  УправленческиеНачисления ,  Удержания .                                                                                                                                            | Управляемое приложение  Обычное приложение |
| 36 . | Регистры сведений ,  регистры  накопления | Имена регистров сведений ,  регистров  накопления рекомендуется задавать во множественном числе и образовывать от описания списка записей ,  которые содержатся  в регистре .  Например: ДокументыФизическихЛиц ,  ФайлыВРабочемКаталоге ,  ДвиженияДенежныхСредств .                                                                                                                          |                                            |
| 37 . | Регистры бухгалтерии ,  регистры расчета  | Имена регистров бухгалтерии  и регистров расчета рекомендуется образовывать от описания списка записей ,  которые содержатся  в регистре .  Например: Хозрасчетный ,  Начисления .                                                                                                                                                                                                             | Управляемое приложение  Обычное приложение |
| 38 . | Бизнес­процессы                           | Имена бизнес­процессов рекомендуется задавать как и  имена документов ,  в единственном числе .                                                                                                                                                                                                                                                                                                | Управляемое приложение  Обычное приложение |
|      |                                           | Например: Задание ,  Согласование ,  Утверждение ,  Поручение .                                                                                                                                                                                                                                                                                                                                |                                            |
| 39 . | Задачи                                    | Имена задач бизнес­процессов рекомендуется задавать в единственном  числе .  Например: ЗадачаИсполнителя .                                                                                                                                                                                                                                                                                     | Управляемое приложение  Обычное приложение |
| 40 . | Внешние источники данных                  | Имена  внешних источников данных рекомендуется образовывать от описания  импортируемых  данных .  При этом следует избегать в  названии слов ,  от удаления  которых смысл  не меняется:  «Данные … » ,  «ИсточникДанных … » .                                                                                                                                                                 | Управляемое приложение  Обычное приложение |
|      |                                           | Примеры: ДоговорыУправленческойУчетнойСистемы ,  ФайлыОсновнойСЭД .                                                                                                                                                                                                                                                                                                                            |                                            |
|      |                                           | Таблицы  внешних источников данных рекомендуется  называть согласно общим  правилам наименования объектов  метаданных .                                                                                                                                                                                                                                                                        |                                            |

## См . также

Ограничения на переименование объектов метаданных

## Работа в разных часовых поясах

- 1 . Конфигурации должны быть рассчитаны на работу в условиях , когда часовой пояс на серверном компьютере не совпадает с реальным часовым поясом пользователей информационной базы . Например , с сервером , расположенным в Москве , работают сотрудники компании из Владивостока , и при этом все операции в системе должны выполняться по местному времени (Владивостока) .

Такой сценарий работы часто востребован в клиент­серверных информационных базах и в прикладных решениях в модели сервиса (SaaS) .

- 2 . 1 . Во всех серверных процедурах и функциях вместо функции ТекущаяДата , которая возвращает дату и время серверного компьютера , следует использовать функцию ТекущаяДатаСеанса , которая приводит время сервера к часовому поясу пользовательского сеанса .
- 2 . 2 . В тех случаях , когда требуется «универсальная» отметка времени , не зависящая от часового пояса текущего сеанса пользователя , в контексте которого выполняется серверный вызов , следует использовать функцию УниверсальноеВремя . Например , для определения момента перезаполнения закешированных данных , для получения времени последнего выполнения фонового задания и т . п .
- 2 . 3 . При использовании методов платформы , возвращающих локальную дату серверного компьютера , следует приводить ее либо к универсальному времени , либо к времени пользовательского сеанса . Например:
- 3 . 1 . В клиентском коде использование функции ТекущаяДата также недопустимо . Это требование обусловлено тем , что текущее время , вычисленное в клиентском и серверном коде , не должно различаться .

```
ДатаАктуальностиУниверсальная = УниверсальноеВремя(ПолнотекстовыйПоиск . ДатаАктуальности()); ДатаАктуальности = МестноеВремя(ДатаАктуальностиУниверсальная , ЧасовойПоясСеанса());
```

Например , с сервером , расположенным в Москве , работают пользователи из Киева . Функция ТекущаяДата для клиентского компьютера возвращает 10:00 , а для сервера – 11:00 . В то же время , функция ТекущаяДатаСеанса вернет на сервере 10:00 , если в информационной базе установлено киевское время (с помощью метода

УстановитьЧасовойПоясИнформационнойБазы) .

Как правило , вместо вызова функции ТекущаяДата на клиенте необходимо

- передавать с сервера на клиент время и дату , приведенную к часовому поясу пользовательского сеанса;
- при работе с документами на клиенте , использовать дату документа .

Рассмотрим типовые случаи на примерах .

- 3 . 2 . В алгоритме закрытия месяца с клиента на сервер передается дата , по которой далее определяется , какой месяц будет закрываться .

## Неправильно:

```
&НаКлиенте Процедура КомандаОткрытьЗакрытиеМесяца(Команда) ТекущиеДанные = Элементы . Список . ТекущиеДанные; Если ТекущиеДанные = Неопределено Тогда ТекДата = ТекущаяДата(); // вызов ТекущаяДата() на клиенте Иначе ТекДата = ТекущиеДанные . Дата;
```

```
КонецЕсли; ПараметрыФормы = Новый Структура; ПараметрыФормы . Вставить( " ПериодРегистрации " , ТекДата); ОткрытьФорму( " Обработка . ЗакрытиеМесяца . Форма . Форма " , ПараметрыФормы , ЭтотОбъект); … а затем в форме обработки: &НаСервере Процедура ПриСозданииНаСервере(Отказ , СтандартнаяОбработка) ЗаполнитьЗначенияСвойств(Объект , Параметры); Если Не ЗначениеЗаполнено(Объект . ПериодРегистрации) Тогда Объект . ПериодРегистрации = НачалоМесяца(ТекущаяДата()); КонецЕсли; … Правильно перенести получение текущей даты на сервер: &НаКлиенте Процедура КомандаОткрытьЗакрытиеМесяца(Команда) ТекущиеДанные = Элементы . Список . ТекущиеДанные; Если ТекущиеДанные = Неопределено Тогда ТекДата = Неопределено; // нет вызова ТекущаяДата() на клиенте Иначе ТекДата = ТекущиеДанные . Дата; КонецЕсли; ПараметрыФормы = Новый Структура; ПараметрыФормы . Вставить( " ПериодРегистрации " , ТекДата); ОткрытьФорму( " Обработка . ЗакрытиеМесяца . Форма . Форма " , ПараметрыФормы , ЭтотОбъект); … и в форме обработки использовать для этого функцию ТекущаяДатаСеанса: &НаСервере Процедура ПриСозданииНаСервере(Отказ , СтандартнаяОбработка) ЗаполнитьЗначенияСвойств(Объект , Параметры); Если Не ЗначениеЗаполнено(Объект . ПериодРегистрации) Тогда Объект . ПериодРегистрации = НачалоМесяца(ТекущаяДатаСеанса()); КонецЕсли; … 3 . 3 . При работе с документами следует рассмотреть возможность использования даты самого документа вместо текущей даты . Например , в реализации подбора номенклатуры в табличную часть документа , в форму подбора из клиентского кода передается дата расчетов для вывода цен и остатков на эту дату . Неправильно: &НаКлиенте Процедура ПодборТовары(Команда) ПараметрыПодбора = Новый Структура; ДатаРасчетов = ?(НачалоДня(Объект . Дата) = НачалоДня(ТекущаяДата()) , Неопределено , Объект . Дата); // вызов ТекущаяДата() на клиенте ПараметрыПодбора . Вставить( " ДатаРасчетов " , ДатаРасчетов); . . . ОткрытьФорму( " Обработка . ПодборНоменклатуры . Форма . Форма " , ПараметрыПодбора , ЭтотОбъект , УникальныйИдентификатор); …
```

## Правильно

```
передавать на сервер дату документа , а вычисление даты расчетов выполнять на сервере: &НаКлиенте Процедура ПодборТовары(Команда) ПараметрыПодбора = Новый Структура; ПараметрыПодбора . Вставить( " ДатаРасчетов " , Объект . Дата); . . . ОткрытьФорму( " Обработка . ПодборНоменклатуры . Форма . Форма " , ПараметрыПодбора , ЭтотОбъект , УникальныйИдентификатор); Другой пример . При подборе документов для зачета аванса в форме подбора устанавливается отбор по условию «дата документов аванса не больше переданной в форму» . Неправильно: &НаКлиенте Процедура ЗачетАвансовДокументАвансаНачалоВыбора(Элемент , ДанныеВыбора , СтандартнаяОбработка) СтандартнаяОбработка = Ложь; ПараметрыФормы = Новый Структура; ПараметрыФормы . Вставить( " КонецПериода " , ?(ЗначениеЗаполнено(Параметры . Ключ) , Объект . Дата ­ 1 , КонецДня(ТекущаяДата()))); // вызов ТекущаяДата() на клиенте . . . ОткрытьФорму( " Документ . ДокументРасчетовСКонтрагентом . ФормаВыбора " , ПараметрыФормы , Элемент); . . . Правильно вычислять параметр КонецПериода по дате документа: &НаКлиенте Процедура ЗачетАвансовДокументАвансаНачалоВыбора(Элемент , ДанныеВыбора , СтандартнаяОбработка) СтандартнаяОбработка = Ложь; ПараметрыФормы = Новый Структура; ПараметрыФормы . Вставить( " КонецПериода " , ?(ЗначениеЗаполнено(Параметры . Ключ) , Объект . Дата ­ 1 , КонецДня(Объект . Дата))); . . . ОткрытьФорму( " Документ . ДокументРасчетовСКонтрагентом . ФормаВыбора " , ПараметрыФормы Элемент); 4 . Исключения из правил 2 и 3 возможны в отдельных , обоснованных случаях , когда требуется использовать действительно текущее время серверного компьютера . Такие исключения должны быть обоснованы в тексте комментария к вызову . 5 . Следует избегать в коде одной процедуры (функции) многократного обращения к функции ТекущаяДатаСеанса (ТекущаяДата) , так как возвращаемые значения будут отличаться друг от друга . Неправильно ДатаПоследнегоОповещения = ТекущаяДатаСеанса(); ДатаСледующегоОповещения = РассчитатьДату() + ТекущаяДатаСеанса(); Правильно использовать ранее рассчитанные дату и время: ДатаПоследнегоОповещения = ТекущаяДатаСеанса(); ДатаСледующегоОповещения = РассчитатьДату() + ДатаПоследнегоОповещения;
```

```
,
```

## Использование функциональных опций

1 . 1 . В случае если некоторая функциональность конфигурации является необязательной для использования , то для управления доступностью такой функциональности на стадии внедрения следует применять функциональные опции . Для хранения значений функциональных опций в информационной базе необходимо завести в конфигурации соответствующие данные (например , константы) .

Допустим , в конфигурации есть функциональность версионирования данных информационной базы , которая является необязательной . Для управления доступностью этой функциональности необходимо:

- создать функциональную опцию ИспользоватьВерсионированиеОбъектов , которая определяет использование прикладного механизма конфигурации для текущей информационной базы
- создать константу ИспользоватьВерсионированиеОбъектов типа Булево для хранения значения этой функциональной опции
- в свойстве Хранение функциональной опции указать константу ИспользоватьВерсионированиеОбъектов .

После этого , те или иные объекты конфигурации можно «привязать» к функциональной опции , включив их в ее состав , а в случае необходимости управления доступностью кода – использовать метод ПолучитьФункциональнуюОпцию:

ИспользуетсяМеханизмВерсионирования = ПолучитьФункциональнуюОпцию( " ИспользоватьВерсионированиеОбъектов " );

Таким образом , набор функциональных опций описывает функциональность конфигурации , доступность которой на этапе внедрения можно настроить в зависимости от требований конкретного предприятия . При этом платформа автоматически изменяет пользовательский интерфейс в соответствии с установленными значениями функциональных опций .

Функциональные опции могут также влиять на бизнес­логику . Для чего применяются функциональные опции не только булева типа , но и других типов , например , ссылки на справочники или значения перечислений .

- 1 . 2 . Доступность функциональности может задаваться не только для информационной базы в целом , но и в зависимости от контекста применения этой функциональности . Допустим , в конфигурации необходимо управлять применением функциональности сложного учета НДС , но не в целом для всей информационной базы , а в зависимости от организации . Для этого необходимо:
- создать функциональную опцию УчетнаяПолитикаСложныйУчетНДС
- создать параметр функциональной опции Организация , поскольку значение функциональной опции зависит от организации (если такого параметра в конфигурации еще нет)
- создать регистр сведений УчетнаяПолитикаНалоговыйУчет для хранения значений этой функциональной опции , с измерением Организация и ресурсами , которые необходимы для управления функциональностью учета НДС
- в свойстве Хранение функциональной опции указать ресурс регистра сведений СложныйУчетНДС
- для параметра функциональной опции Организация указать в свойстве Использование измерения Организация регистра сведений УчетнаяПолитикаНалоговыйУчет .

<!-- image -->

После этого , для того чтобы в той или иной форме значение функциональной опции соответствовало контексту , необходимо устанавливать значения параметров функциональной опции , например , так:

УстановитьПараметрыФункциональныхОпцийФормы(Новый Структура( " Организация " , &lt;ТребуемаяОрганизация&gt;));

В случае необходимости управления доступностью кода в зависимости от значения такой функциональной опции , ее значение можно получать , например , так:

```
ПараметрыУчетнойПолитики = Новый Структура( " УчетнаяПолитикаОрганизация " , <ТребуемаяОрганизация>); СложныйУчетНДС = ПолучитьФункциональнуюОпцию( " УчетнаяПолитикаСложныйУчетНДС " , ПараметрыУчетнойПолитики); МоментОпределенияНалоговойБазыНДС = ПолучитьФункциональнуюОпцию( " УчетнаяПолитикаМоментОпределенияНалоговойБазыНДС " , ПараметрыУчетнойПолитики);
```

Внимание: следует учитывать , что описанный здесь вариант применения функциональных опций не является единственным вариантом их использования . Подробнее см . в документации по платформе 1С:Предприятие 8 . 2 .

- 1 . 3 . Не следует использовать функциональные опции не по назначению , например:
- создавать функциональные опции ради управления видимостью элементов управления конкретной формы . С помощью функциональных опций следует управлять доступностью той или иной функциональности для всей конфигурации (и , как следствие , доступностью элементов форм и команд во всей конфигурации , а не в одной отдельно взятой форме);
- использовать функциональные опции для оптимизации доступа к тем или иным данным информационной базы (хранения значений на сервере 1С:Предприятия) . Для этой цели предназначены модули с повторным использованием возвращаемых значений .

## Установка и получение значений функциональных опций

- 2 . 1 Платформа 1С:Предприятие 8 . 2 не предоставляет каких­либо специальных средств для установки значений функциональных опций: установка значений функциональных опций производится установкой значений соответствующих констант , редактированием элементов справочников или записей регистров сведений . В конфигурации следует предусмотреть соответствующую функциональность .
- 2 . 2 . При использовании функциональных опций с параметрами , следует иметь в виду , что если в справочнике или регистре сведений нет записи , соответствующей параметру , то функциональная опция считается выключенной . Если же параметру соответствует больше , чем одна запись , то значения функциональной опции складываются по «ИЛИ» .
- 2 . 3 . Если функциональная опция «привязана» к ресурсу периодического регистра сведений , то система использует срез последних для получения значения опции . Если требуется получать значение опции на какую­либо другую дату , необходимо указать значение для параметра функциональной опции Период типа Дата , который будет использоваться как дата получения среза . Например , если имеется периодический регистр сведений с измерением Организация , то следует использовать следующий синтаксис:

УстановитьПараметрыФункциональныхОпцийФормы(Новый Структура( " Организация , Период " , &lt;ТребуемаяОрганизация&gt; , &lt;ТребуемаяДата&gt;));

## При этом

- значение параметра Период необходимо предварительно привести к интервалу периодичности регистра для выполнения требования 2 . 5 . Например , если периодичность регистра – месяц , то:

## НачалоМесяца(&lt;ТребуемаяДата&gt;)

- а сам параметр Период не следует создавать в метаданных , так как он предоставляется системой автоматически .
- 2 . 4 . Также необходимо иметь в виду , что установка значения функциональной опции не вызывает автоматического изменения пользовательского командного интерфейса . Для отработки изменения следует вызвать метод ОбновитьИнтерфейс .
- 2 . 5 . С точки зрения производительности системы следует иметь в виду , что значения функциональных опций кешируются на сервере . Однако большой размер кеша может ухудшить производительность . Поэтому не рекомендуется параметризовать функциональные опции такими данными , которые заведомо могут иметь большое число значений . Например , параметризация функциональной опции контрагентом или товаром не допустима , так как контрагентов или товаров может быть большое количество . Кроме того , зависимость применения функциональности от контрагента сомнительна . На практике функциональность ставится в зависимость от вида , контрагента или иного его признака . Например , если в конфигурации существует перечисление ВидКонтрагента , то применение той или иной функциональности следует ставить в зависимость от вида контрагента , а не от самого контрагента .

## Зависимые функциональные опции

- 3 . 1 . В некоторых случаях та или иная функциональность должна быть доступна при условии использования или отказа от использования другой функциональности . В подобных случаях сложной зависимости значения функциональной опции от значений других функциональных опций необходимо обеспечить непротиворечивость данных , связанных с функциональными опциями .

Например , функциональность перевода сотрудников из одной организации в другую (т . е . все связанные с этим документы и отчеты) доступна в случае , когда одновременно доступны функциональность " многофирменный учет " и функциональность " кадровый учет " .

В таком случае , все объекты метаданных , связанные с переводом сотрудников , не могут и не должны ставиться в зависимость от функциональных опций " многофирменный учет " и " кадровый учет " . Для этого необходимо ввести функциональную опцию " перевод сотрудников " и поставить в зависимость от нее все объекты метаданных , для которых это необходимо .

Кроме того , необходимо обеспечить зависимость значения этой функциональной опции от значений " многофирменный учет " и " кадровый учет " , например , при записи значений соответствующих констант .

Значения всех трех приведенных в примере функциональных опций рекомендуется показывать администратору системы в соответствующей форме настроек . При этом значение функциональной опции " перевод сотрудников " должно быть недоступно для редактирования .

Редактировать значения таких функциональных опций рекомендуется элементами управления " Поле " вида " Поле флажка " с заголовком , совпадающим с названием соответствующей функциональной опции .

3 . 2 . Значения взаимоисключающих функциональных опций , рекомендуется редактировать в соответствующей форме настройки при помощи элементов управления " Поле переключателя " , " Поле ввода " (со списком выбора) или иной элемент управления , предназначенный для выбора одного значения из многих . При этом , заголовки для переключателей или значения выпадающего списка для " Поле ввода " должны совпадать с названиями функциональных опций .

3 . 3 . В том случае , если та или иная незначительная функциональность сложным образом зависит от значений функциональных опций , но при этом не может быть названа так , чтобы ее название было понятно конечному пользователю , рекомендуется воздержаться от создания очередной функциональной опции . При этом , например , зависимость тех или иных элементов форм должна обеспечиваться при создании формы на сервере за счет анализа значений функциональных опций из кода на встроенном языке .

## Ограничения на использование параметров функциональных опций

4 . 1 . По соображениям производительности не рекомендуется заводить в конфигурации более 10 параметров функциональных опций . Для чтобы контролировать их количество в конфигурации , не следует создавать различные параметры функциональных опций одной смысловой нагрузки . Например , вместо двух параметров:

- ТипВерсионируемогоОбъекта , связанный с измерением ТипОбъекта регистра сведений НастройкаВерсионированияОбъектов
- ТипОбъектаСДополнительнымиОтчетамиИОбработками , связанный с измерением ТипОбъекта регистра сведений НазначениеДополнительныхОбработок

рекомендуется создать один параметр функциональных опций ТипОбъектаКонфигурации , который связан с измерениями обоих регистров сведений .

4 . 2 . В общем виде , для принятия решения по поводу состава функциональных опций и их параметров рекомендуется придерживаться следующей схемы:

- 1 . Определяется , какая функциональность в нашем прикладном решении может быть опциональной (у нее есть «выключатель») .
- 2 . По каждому выявленному случаю определяется , выключается ли эта функциональность сразу для всей информационной системы или «выключателей» должно быть несколько , например , по одному на каждую организацию или на каждый вид товара .
- 3 . Выписываем список всех параметризуемых функциональных опций , а также список их параметров .
- 4 . При этом в списке параметров функциональных опций не допускаем нескольких параметров одного типа (все функциональные опции , зависящие от организации должны использовать один параметр функциональной опции) .
- 5 . Если параметров функциональных опций оказывается неприемлемо много , то составляем их «рейтинг»: суммируем состав всех функциональных опций , которые параметризуются данным параметром и принимаем во внимание важность параметризуемых функциональных опций .
- 6 . Исключаем менее востребованные параметры .
- 7 . Те функциональные опции , которые «лишились» параметров:
- либо делаем непараметрическими (т . е . они включают функциональность во всей информационной базе в целом);
- либо удаляем , если управлять такой функциональностью в целом по информационной базе не имеет смысла .

В результате такого подхода , в конфигурации окажется приемлемое количество параметров функциональных опций .

## См . также

- Влияние изменения значений параметров сеанса и функциональных опций на производительность механизма ограничения доступа к данным

## Использование параметров сеанса

- 1 . 1 . Параметры сеанса предназначены для хранения значений определенных типов для каждого клиентского сеанса на время работы этого сеанса . Инициализацию параметров сеанса следует выполнять в модуле сеанса (см . ниже раздел 2 . 1) , а их значения рекомендуется использовать в запросах и условиях ограничения доступа к данным для текущего сеанса . Примеры параметров сеанса:
- ТекущийПользователь – тип СправочникСсылка . Пользователи
- ОбменДаннымиВключен – тип Булево
- РабочееМестоКлиента – тип СправочникСсылка . РабочиеМеста

Параметры сеанса доступны из встроенного языка 1С:Предприятия , например:

ЗначениеТекущегоПользователя

ПараметрыСеанса

.

ТекущийПользователь;

В этом случае , для установки или получения значения параметра сеанса текущий пользователь должен быть наделен соответствующим правом .

Также они могут использоваться в текстах ограничений доступа , например:

ГДЕ Документ . Пользователь = &amp;ТекущийПользователь

В последнем случае для получения значения параметра сеанса наличия у текущего пользователя соответствующего права не требуется .

- 1 . 2 . Не рекомендуется использовать параметры сеанса для хранения значений , используемых исключительно в клиентской логике . Поскольку в клиент­серверном варианте 1С:Предприятия параметры сеанса хранятся на сервере , то любое их считывание или изменение в процессе работы на клиенте потребует дополнительного серверного вызова и увеличит объем передаваемых данных с клиента на сервер и обратно .

В таких случаях следует использовать глобальные переменные модуля управляемого приложения (и обычного приложения – для режима обычного приложения , соответственно) .

- 1 . 3 . Также не рекомендуется использовать параметры сеанса для кеширования вычисленных значений , которые многократно используются в серверной бизнес­логике . В таких случаях следует определять функцию в серверном общем модуле с повторным использованием возвращаемых значений . Исключение составляют случаи , когда время вычисления результата функции модуля с повторным использованием возвращаемых значений соизмеримо с периодом сброса платформенного кеша .

Установка параметров сеанса " по требованию "

=

## 2 . 1 . Не следует производить инициализацию параметров сеанса при запуске программы , так как:

- не все параметры сеанса запрашиваются из кода конфигурации при запуске программы .
- при работе программы возможно намеренное обнуление значений параметров сеанса из кода на встроенном языке .

Правильным способом установки значений параметров сеанса является установка значений " по требованию " в обработчике УстановкаПараметровСеанса модуля сеанса . Т . е . параметры сеанса должны быть инициализированы только в тот момент , когда к ним происходит первое обращение , как к неустановленным .

## Пример установки параметров сеанса " по требованию " :

```
Процедура УстановкаПараметровСеанса(ИменаПараметровСеанса) Если ИменаПараметровСеанса = Неопределено Тогда // Раздел установки параметров сеанса при начале сеанса (ИменаПараметровСеанса = Неопределено) // Выполняется установка параметров сеанса , которые можно инициализировать // при начале работы системы Иначе // Установка параметров сеанса " по требованию " // Параметры сеанса , инициализация которых требует обращения к одним и тем же данным // следует инициализировать сразу группой . Для того , чтобы избежать их повторной инициализации , // имена уже установленных параметров сеанса сохраняются в массиве УстановленныеПараметры УстановленныеПараметры = Новый Массив; Для Каждого ИмяПараметра Из ИменаПараметровСеанса Цикл УстановитьЗначениеПараметраСеанса(ИмяПараметра , УстановленныеПараметры); КонецЦикла; КонецЕсли; КонецПроцедуры // Установить значения параметров сеанса и возвратить имена установленных параметров сеанса // в параметре УстановленныеПараметры . // // Параметры // ИмяПараметра ­ Строка ­ имя параметра сеанса, который
```

```
требуется установить (проинициализировать) . // УстановленныеПараметры ­ Массив ­ массив , в который добавляются имена // установленных (проинициализированных) параметров . // Процедура УстановитьЗначениеПараметраСеанса(Знач ИмяПараметра , УстановленныеПараметры) // Если в данном вызове УстановкаПараметровСеанса параметр ИмяПараметра уже // был установлен ­ возврат . Если УстановленныеПараметры . Найти(ИмяПараметра) <> Неопределено Тогда Возврат; КонецЕсли; Если ИмяПараметра = " ТекущийПользователь " Тогда ПараметрыСеанса . ТекущийПользователь = <значение>; ПараметрыСеанса . <другой параметра сеанса> = <значение>; УстановленныеПараметры . Добавить(ИмяПараметра); УстановленныеПараметры . Добавить( " <другой параметра сеанса> " ); КонецЕсли; КонецПроцедуры
```

## См . также

- Влияние изменения значений параметров сеанса и функциональных опций на производительность механизма ограничения доступа к данным

## Использование подсистем

Методическая рекомендация (полезный совет)

- 1 . 1 . С помощью подсистем решаются две методические задачи:
- Сформировать глобальный командный интерфейс основного окна приложения , которое дает пользователю представление о функциональности приложения в целом .
- Сгруппировать объекты метаданным по функциональному признаку для удобства разработки .

В простейшем случае , получившаяся для обоих задач структура подсистем конфигурации может совпадать .

<!-- image -->

Например , видимые для пользователей разделы командного интерфейса «Закупки» , «Продажи» и пр . могут использоваться одновременно и при разработке: для быстрого отбора объектов в окне метаданных Конфигуратора , при переносе объектов в другие конфигурации , для задания ограничений области поиска при глобальном поиске по конфигурации и т . д .

У таких подсистем должен быть установлен флажок Включать в командный интерфейс .

- 1 . 2 . В общем случае , подсистема , логически объединяющая некоторый набор объектов метаданных , может не совпадать с одним разделом командного интерфейса приложения . Для логического объединения набора объектов метаданных по функциональному признаку рекомендуется заводить в конфигурации отдельную иерархию подсистем , не включенных в командный интерфейс . У таких «функциональных» подсистем флажок Включать в командный интерфейс должен быть снят .

## Примеры:

- справочник Номенклатура логически относится к одной «функциональной» подсистеме «Нормативносправочная информация» , но доступен в командном интерфейсе одновременно в двух разделах – «Нормативно ­ справочная информация» и «Маркетинг»
- в раздел командного интерфейса «Настройка и администрирование» помещаются команды открытия списков объектов , логически относящихся к тем «функциональным» подсистемам конфигурации , которые предоставляют возможность настройки для администратора системы .
- 1 . 3 . При этом , общие модули , регламентные задания , константы , подписки на события и прочие объекты , не имеющие визуального представления в командном интерфейсе , рекомендуется включать только в состав « функциональных» подсистем .

## См . также

- Панель разделов

## Использование общих реквизитов

- 1 . Общие реквизиты позволяют добавлять реквизиты сразу для нескольких объектов метаданных (справочников , документов , регистров и т . п . ) для решения одной из двух прикладных задач:
- для разделения данных (свойство Разделение данных имеет значение Разделять);
- для расширения состава реквизитов у нескольких объектов (свойство Разделение данных = Не использовать) .
- 2 . Общие реквизиты без разделения данных предназначены для добавления некоторого функционала , который не является частью бизнес­логики прикладных объектов (например , решает задачи конфигурации в целом) , но при этом требует хранения некоторых данных непосредственно в самих прикладных объектах (а не , например , в связанных регистрах) .

При этом общие реквизиты не предназначены для удобства добавления одинаковых реквизитов в прикладные объекты . Например , неправильно переносить в общие реквизиты «обычные» реквизиты документов Ответственный , Комментарий , Организация и т . п . Следует также иметь в виду , что права доступа к общим реквизитам настраиваются отдельно от тех объектов , в которые они добавлены .

- 3 . Порядок следования в дереве метаданных общих реквизитов­разделителей следует подбирать , исходя из требуемого порядка установки параметров сеанса , которые связаны с ними .

## См . также

- Использование общих реквизитов без разделения данных (статья на ИТС)

## Использование определяемых типов

- 1 . Определяемые типы предназначены для определения типов данных , которые описывают часто используемые сущности или с высокой степенью вероятности могут изменяться при внедрении прикладного решения . Они позволяют многократно использовать описываемый тип или набор типов без уточнения состава в различных местах конфигурации (в реквизитах , свойствах объектах , форм и т . п . ) .

См . также статью на ИТС: «Объекты конфигурации – Определяемые типы»

- 2 . Определяемые типы рекомендуется использовать в следующих случаях:
- 2 . 1 . Для определения простого типа и его квалификаторов , имеющего прикладной смысл , который используется в различных реквизитах , ресурсах , реквизитах форм , макетах и т . д . в рамках какой­либо подсистемы или во всем прикладном решении . Это гарантирует одинаковую длину , точность данных во всех местах использования , упрощает доработку в случае изменения требований . Например:
- НомерСчетаФактуры ­ Строка , длина 30 . Регламентирует формат номера счета ­ фактуры в различных документах: ПоступлениеТоваровИУслуг , ЗаписьКнигиПокупок , ВозвратТоваровОтКлиента и др .
- АдресДоставки ­ Строка , 500 . Текстовое представление адреса доставки в документах ЗаказПоставщику , АдресДоставкиПеревозчика , в обработке ПомощникПродаж , в реквизите АдресДоставкиПеревозчика документа ЗаявкаНаВозвратТоваровОтКлиента и др .
- 2 . 2 . Для определения составного типа , который массово используется в объектах какой ­ либо подсистемы или во всем прикладном решении . Определяемый тип гарантирует одинаковый состав (тип) данных во всех местах использования , а также упрощает доработку и внедрение подсистем в прикладные конфигурации .

Например , в конфигурацию внедрена подсистема Взаимодействия , которая предназначена для ведения переписки по электронной почте , регистрации звонков и встреч . При внедрении этой подсистемы разработчик принял решение о составе объектов метаданных , которые могут выступать в качестве «контактов взаимодействий» ­ это элементы справочников ФизическиеЛица , Партнеры , КонтактныеЛицаПартнеров , и задал этот состав типов в определяемом типе КонтактВзаимодействий , предусмотренном в подсистеме . В свою очередь , определяемый тип массово используется в реквизитах объектов и формах подсистемы (в документах Встреча , ЗапланированноеВзаимодействие ­ табличная часть Участники , в документе СообщениеSMS – табличная часть Адресаты , в документе

ТелефонныйЗвонок ­ реквизит АбонентКонтакт , в общих формах АдреснаяКнига , ВыборКонтакта – реквизиты КонтактыПоПредмету , в параметре макета ИерархияВзаимодействийКонтакт журнала документов Взаимодействия и т . д . ) В противном случае , без использования определяемого типа КонтактВзаимодействий пришлось бы снимать объекты подсистемы с поддержки и задавать требуемый состав типов во всех перечисленных местах .

- 2 . 3 . При разработке внедряемой подсистемы ­ для переопределения прикладного типа , который будет уточнен при внедрении . Например , тип подсистемы Поставщики при внедрении может быть заменен на прикладной тип конфигурации Контрагенты .
- 3 . Некорректно использовать определяемые типы для задания «синонима» существующему типу , «подмены» сущностей , для локального (не массового) использования в рамках одной подсистемы (конфигурации) без необходимости внедрения в другие конфигурации , только из соображений легкости доработки . Как правило , это говорит об ошибке проектирования или о методологически неверном выборе исходного имени типа .

Например , в конфигурации предусмотрен справочник Контрагенты , ссылки на который имеются в нескольких регистрах сведений , реквизитах форм и других объектах конфигурации . При этом справочник не является ни частью встраиваемой подсистемы , ни прикладной сущностью , которая может быть расширена другими типами . Тогда некорректно заводить дополнительный определяемый составный тип , состоящего из единственного типа Контрагенты , на «всякий случай» , для «механического» упрощения возможного изменения конфигурации в дальнейшем , поскольку это размывает прикладной смысл сущности .

## Правила создания общих модулей

- 1 . 1 . Общие модули создаются для реализации процедур и функций , объединенных по некоторому признаку . Как правило , в один общий модуль помещаются процедуры и функции одной подсистемы конфигурации (продажи , закупки) или процедуры и функции сходного функционального назначения (работа со строками , общего назначения) .
- 1 . 2 . При разработке общих модулей следует выбирать один из четырех контекстов выполнения кода:
- 2 . 1 . Серверные общие модули предназначены для размещения серверных процедур и функций , не доступных для использования из клиентского кода . В них реализуется вся внутренняя серверная бизнес­логика приложения . Для корректной работы конфигурации в режимах внешнего соединения , управляемого и обычного приложений , серверные процедуры и функции следует размещать в общих модулях с признаками:
- Сервер (флажок Вызов сервера сброшен) ,
- Клиент (обычное приложение) ,
- Внешнее соединение .

|     | Тип общего модуля               | Пример наименования                                     | Вызов сервера   | Сервер   | Внешнее соединение   | Клиент (обычное приложение)   | Клиент (управляемое приложение)   |
|-----|---------------------------------|---------------------------------------------------------|-----------------|----------|----------------------|-------------------------------|-----------------------------------|
| 1 . | Серверный                       | ОбщегоНазначения (или ОбщегоНазначенияСервер)           |                 | +        | +                    | +                             |                                   |
| 2 . | Серверный для  вызова с клиента | ОбщегоНазначенияВызовСервера                            | +               | +        |                      |                               |                                   |
| 3 . | Клиентский                      | ОбщегоНазначенияКлиент (или ОбщегоНазначенияГлобальный) |                 |          |                      | +                             | +                                 |
| 4 . | Клиент серверный               | ОбщегоНазначенияКлиентСервер                            |                 | +        | +                    | +                             | +                                 |

В таком случае гарантируется возможность вызова серверных процедур и функций с параметрами мутабельных типов (например , СправочникОбъект , ДокументОбъект и т . п . ) . Как правило , это:

- обработчики подписок на события документов , справочников и т . п . , которые принимают в качестве параметра мутабельное значение (объект) .
- серверные процедуры и функции , в которые в качестве параметра передается объект из модулей справочников , документов и пр . , а также из модулей с подписками на события .

Серверные общие модули называются по общим правилам именования объектов метаданных .

Например: РаботаСФайлами , ОбщегоНазначения

В отдельных случаях для предотвращения конфликта имен со свойствами глобального контекста может быть добавлен постфикс «Сервер» .

Например: РегламентныеЗаданияСервер , ОбменДаннымиСервер .

- 2 . 2 . Серверные общие модули для вызова с клиента содержат серверные процедуры и функции , доступные для использования из клиентского кода . Они составляют клиентский программный интерфейс сервера приложения . Такие процедуры и функции размещаются в общих модулях с признаком:
- Сервер (флажок Вызов сервера установлен)

Серверные общие модули для вызова с клиента называются по общим правилам именования объектов метаданных и должны именоваться с постфиксом «ВызовСервера» .

Например: РаботаСФайламиВызовСервера

Следует иметь в виду , что экспортные процедуры и функции в таких общих модулях не должны содержать параметров мутабельных типов (СправочникОбъект , ДокументОбъект и т . п . ) , так как их передача из (или в) клиентского кода невозможна .

См . также: Ограничение на установку признака «Вызов сервера» у общих модулей

- 2 . 3 . Клиентские общие модули содержат клиентскую бизнес­логику (функциональность , определенную только для клиента) и имеют признаки:
- Клиент (управляемое приложение)
- Клиент (обычное приложение)

Исключение составляют случаи , когда клиентские процедуры и функции должны быть доступны только в режиме управляемого приложения (только в режиме обычного приложения или только в режиме внешнего соединения) . В таких случаях , допустима иная комбинация двух этих признаков .

Клиентские общие модули именуются с постфиксом «Клиент» .

Например: РаботаСФайламиКлиент , ОбщегоНазначенияКлиент

См . также: минимизация кода , выполняемого на клиенте

- 2 . 4 . В отдельных случаях , допустимо создание клиент ­ серверных общих модулей с процедурами и функциями , содержание которых одинаково и на сервере , и на клиенте . Такие процедуры и функции размещаются в общих модулях с признаками:
- Клиент (управляемое приложение)
- Сервер (флажок Вызов сервера сброшен)
- Клиент (обычное приложение)
- Внешнее соединение

Общие модули этого вида именуются с постфиксом «КлиентСервер»

.

Например: РаботаСФайламиКлиентСервер , ОбщегоНазначенияКлиентСервер

В общем случае , не рекомендуется определять общие модули одновременно для сервера и для клиента (управляемое приложение) . Функциональность , определенную для клиента и для сервера , рекомендуется реализовывать в разных общих модулях – см . пп . 2 . 1 и 2 . 3 . Такое явное разделение клиентской и серверной бизнес­логики продиктовано соображениями повышения модульности прикладного решения , упрощения контроля со стороны разработчика над клиент­серверным взаимодействием и снижением риска ошибок из­за принципиальных отличий требований к разработке клиентского и серверного кода (необходимость минимизации кода , выполняемого на клиенте , разной доступностью объектов и типов платформы и др . ) . При этом нужно иметь в виду неизбежное увеличение числа общих модулей в конфигурации .

Особым случаем смешанных клиент­серверных модулей являются модули форм и команд , которые специально предназначены для реализации серверной и клиентской бизнес­логики в одном модуле .

- 3 . 1 . Имена общих модулей рекомендуется строить по общим правилам именования объектов метаданных . Название общего модуля должно совпадать с названием подсистемы или отдельного механизма , процедуры и функции которой он реализует . Рекомендуется избегать в названиях общих модулей таких общих слов как " Процедуры " , " Функции " , " Обработчики " , " Модуль " , " Функциональность " и т . п . и применять их только в исключительных случаях , когда они более полно раскрывают назначение модуля .

Для того чтобы различать общие модули одной подсистемы , которые созданы для реализации процедур и функций , выполняемых в разных контекстах , рекомендуется задавать им постфиксы , описанные ранее в пп . 2 . 1 ­ 2 . 4 .

- 3 . 2 . Дополнительно к общим модулям могут быть добавлены уточняющие постфиксы .
- 3 . 2 . 1 . Для глобальных модулей добавляется постфикс «Глобальный» , в этом случае постфикс «Клиент» добавлять не следует .

Например: РаботаСФайламиГлобальный

- 3 . 2 . 2 . Модули , выполняющиеся в привилегированном режиме , имеющие признак Привилегированный , именуются с постфиксом «ПолныеПрава» .

Например: РаботаСФайламиПолныеПрава

- 3 . 2 . 3 . Модули , предназначенные для реализации на сервере или на клиенте функций с повторным использованием возвращаемых значений (на время вызова или на время сеанса) , именуются с постфиксом «ПовтИсп» и

«КлиентПовтИсп» соответственно

.

Например: РаботаСФайламиКлиентПовтИсп

- 3 . 2 . 4 . Серверные и клиентские модули библиотечных конфигураций (которые предназначены не для самостоятельного использования , а для разработки других конфигураций) с процедурами и функциями , допускающие изменение своей реализации , именуются с постфиксами «Переопределяемый» и «КлиентПереопределяемый» . Например: РаботаСФайламиКлиентПереопределяемый

См .

также: Переопределяемые и поставляемые объекты библиотеки

## См . также

- Тексты модулей
- Структура модуля

## Работа с пользовательскими настройками

1 . 1 . Для хранения персональных настроек пользователя следует использовать хранилище общих настроек . Например , чтение и запись значения настройки «Задавать вопрос при выходе из программы» для текущего пользователя реализуется на встроенном языке с помощью объекта ХранилищеОбщихНастроек:

```
ЗначениеНастройки = ХранилищеОбщихНастроек . Загрузить( " НастройкиПрограммы " , " ЗадаватьВопросПриВыходе " ); ХранилищеОбщихНастроек . Сохранить( " НастройкиПрограммы " , " ЗадаватьВопросПриВыходе " , ЗначениеНастройки);
```

При этом для хранения настроек пользователя не следует использовать какие ­ либо другие способы , в частности , другие объекты метаданных (регистры , реквизиты и табличные части справочников и др . ) , внешние файлы и пр .

- 1 . 2 . Для работы с пользовательскими настройками требуется , чтобы для пользователя было доступно право СохранениеДанныхПользователя .
- 1 . 3 . Для обращения к каждой настройке в хранилище общих настроек необходимо использовать уникальный строковый ключ настройки . Например , значения основной организации и основного склада , с которыми работает текущий пользователь – это две разные настройки , которые хранятся раздельно под ключами «ОсновнаяОрганизация» и «ОсновнойСклад» .

См . также: Стандартные роли

В то же время , некоторые настройки могут быть объединены в структуру , массив или соответствие , если все обращения к ним выполняются одновременно , как к одной настройке . Например , параметры прокси ­ сервера для доступа к сети Интернет представляют из себя набор из нескольких значений (адрес прокси­сервер , имя и пароль пользователя) , однако хранятся все вместе в виде одной структуры как одна самостоятельная настройка .

- 2 . 1 . В конфигурации должно быть предусмотрено общее место для редактирования всех пользовательских настроек . Как правило , это общая форма персональных настроек пользователя .

Пример реализации формы персональных настроек «Мои настройки» имеется в демонстрационной конфигурации Библиотеки стандартных подсистем .

<!-- image -->

- 2 . 2 . В то же время , форма персональных настроек может являться не единственным местом для их редактирования . Для повышения удобства работы пользователя поля с отдельными настройками могут быть размещены непосредственно в тех рабочих местах , к которым эти настройки относятся . Например , флажок «Больше не показывать подсказки при редактировании файла» может быть размещен прямо на форме с самой подсказкой , которая выводится при работе с файлами .
- 2 . 3 . Форма персональных настроек пользователя , другие формы (рабочие места) , а также отдельные элементы форм для работы с персональными настройками должны быть доступны только пользователям с правом СохранениеДанныхПользователя .

См . также: Стандартные роли

- 3 . 1 . При работе с хранилищем общих настроек следует иметь в виду , что настройки не мигрируют между узлами информационной базы , а специфичны для определенного узла . При необходимости , передача настроек пользователей между узлами может быть реализована дополнительно средствами встроенного языка .
- 3 . 2 . Все настройки в хранилище общих настроек сохраняются в разрезе пользователей информационной базы , по строковому имени пользователя . Поэтому в случае переименования пользователя прежние настройки теряются . В частности , если впоследствии будет создан пользователь , имя которого совпадает с именем переименованного пользователя , то для него будут использованы ранее сохраненные настройки .

Для того чтобы этого избежать , рекомендуется переносить настройки при переименовании пользователя , и очищать настройки при удалении .

При использовании в конфигурации Библиотеки стандартных подсистем (БСП) в распоряжении разработчика имеются обработчики записи и удаления пользователя информационной базы (см . процедуры ПриЗаписиПользователяИнформационнойБазы и ПослеУдаленияПользователяИнформационнойБазы в общем модуле ПользователиПереопределяемый) , в которых возможно выполнить перенос и удаление настроек . Пример использования см . в демонстрационной конфигурации БСП .

## Начальные действия при работе конфигурации

- 1 . В конфигурации должен быть предусмотрен механизм , автоматически определяющий как факт первого запуска конфигурации и выполняющий первоначальное заполнение информационной базы минимально необходимыми данными , так и факт первого запуска нового релиза и выполняющий необходимые изменения в базе (обновление данных ИБ) .

При использовании в конфигурации Библиотеки стандартных подсистем такую возможность следует предоставлять средствами подсистемы «Обновление версии ИБ» .

В случае если в конфигурации не используется Библиотеки стандартных подсистем , ниже приведены общие требования к начальным действиям , выполняемым при работе конфигурации .

Методическая рекомендация (полезный совет)

- 2 . Первоначальное заполнение ИБ может быть разделено на обязательное , без чего конфигурация не будет работать , и необязательное , которое облегчает начало эксплуатации продукта , но не является строго обязательным .
- 3 . По результатам обработки информационной базы при первом запуске конфигурации или при первом запуске нового релиза конфигурации рекомендуется выводить администратору системы описание конфигурации или описание изменений в этой версии конфигурации .
- 4 . Ситуации , когда обработка не проведена в требуемом объеме , должны контролироваться конфигурацией . При этом пользователю должно выводиться предупреждение о возникновении проблемной ситуации . Для вывода подробного протокола о выполненных операциях и возникших ошибках следует использовать журнал регистрации .
- 5 . При наличии в конфигурации возможности работы в распределенной информационной базе (РИБ) , следует реализовывать логику обновления данных ИБ в подчиненных узлах таким образом , чтобы она
- выполнялась после загрузки уже обновленных данных из главного узла;
- исключала повторную обработку одних и тех же данных , а тем более – повторное создание новых данных . Другими словами , повторная

обработка ИБ должна отрабатывать корректно

## В противном случае:

- если при обновлении подчиненного узла ИБ безусловно создаются новые данные , то они будут многократно созданы в каждом из узлов РИБ и размножены во всех узлах при очередном обмене данными .
- если при обновлении подчиненного узла ИБ безусловно изменяются какие­либо данные , то они будут зарегистрированы к выгрузке обратно в главный узел . Это приведет к дополнительной избыточной нагрузке на канал связи между узлами .

## Например , неправильно:

```
ПрофильОбъект = Справочники . ПрофилиГруппДоступа . СоздатьЭлемент(); ПрофильОбъект . Наименование = НСтр( " ru = ' Бухгалтер ' " ); ПрофильОбъект . Предустановленный = Истина; ПрофильОбъект . Записать(); правильно: НаименованиеПрофиля = НСтр( " ru = ' Бухгалтер ' " ); Запрос = Новый Запрос( " ВЫБРАТЬ | ИСТИНА |ИЗ | Справочник . ПрофилиГруппДоступа КАК ПрофилиГруппДоступа |ГДЕ | ПрофилиГруппДоступа . Наименование = &Наименование И | ПрофилиГруппДоступа . Предустановленный = ИСТИНА " ); Запрос . УстановитьПараметр( " Наименование " , НаименованиеПрофиля); // Если элемента нет , только тогда нужно создать новый . Если Запрос . Выполнить() . Пустой() Тогда ПрофильОбъект = Справочники . ПрофилиГруппДоступа . СоздатьЭлемент(); ПрофильОбъект . Наименование = НаименованиеПрофиля; ПрофильОбъект . Предустановленный = Истина; ПрофильОбъект . Записать(); КонецЕсли;
```

.

## Поддержка толстого клиента , управляемое приложение , клиент­сервер

- 1 . Для обеспечения работы конфигурации в толстом клиенте , управляемое приложение , клиент­сервер следует иметь в виду , что серверный код конфигурации в этом режиме может выполняться на стороне клиента .

Необходимость поддержки толстого клиента в управляемом режиме может возникнуть из ­ за ряда возможностей , которые не поддерживаются в тонком клиенте . Подробнее см . Функциональность обычного приложения , отсутствующая в управляемом приложении .

- 2 . Для этого может потребоваться обеспечить работу на клиенте отдельных фрагментов серверного кода:
- обработчики событий в модулях менеджеров (ОбработкаПолученияДанныхВыбора , ОбработкаПолученияФормы и др . )
- подписки на эти же события модулей менеджеров .

Весь остальной серверный код конфигурации , который размещается в модуле сеанса , модулях объектов , модулях менеджеров и др . модулях объектов метаданных (кроме модулей форм , команд и общих модулей) следует заключить в инструкцию препроцессора:

#Если Сервер Или ТолстыйКлиентОбычноеПриложение Или ВнешнееСоединение Тогда

…

#КонецЕсли

- 3 . При необходимости вызова серверных процедур (и функций) из клиентского кода следует размещать вызываемые процедуры в серверных общих модулях с признаком Вызов сервера . При этом нужно убедиться , что в параметры процедур (и в возвращаемые значения функций) не передаются значения мутабельных типов (СправочникОбъект , ДокументОбъект и пр . )

Важно: не следует для этих целей всем общим модулям с признаком Сервер принудительно устанавливать флажок Вызов сервера . Подробнее см . Ограничение на установку признака «Вызов сервера» у общих модулей .

Например , некорректный обработчик события

ОбработкаПолученияДанныхВыбора:

Процедура ОбработкаПолученияДанныхВыбора(ДанныеВыбора , Параметры , СтандартнаяОбработка)

Взаимодействия . ОбработкаПолученияДанныхВыбора(ДанныеВыбора , Параметры); СтандартнаяОбработка = Ложь;

<!-- image -->

## Технология разветвленной разработки конфигураций

Методическая рекомендация (полезный совет)

Цели внедрения технологии:

- Повышение качества разрабатываемой конфигурации
- Повышение культуры разработки и тестирования
- Обеспечение непрерывного развития конфигураций в условиях жестких сроков разработки

## 1 . Определения

Плановая версия конфигурации – версия , содержащая существенное развитие функционала , срок выпуска которой назначается заранее .

Исправительная версия – версия , которая выпускается при необходимости срочной публикации исправлений критичных ошибок . В исключительных случаях исправительная версия может содержать какой­то новый функционал (например , доработки , связанные с поддержкой изменения законодательства) . Срок выпуска определяется при анализе количества и критичности обнаруженных ошибок плановой версии .

Технический проект – задание на доработку конфигурации . Каждый технический проект имеет четко сформулированную цель и конечный список изменений , которые нужно выполнить , чтобы достигнуть этой цели .

Для организации работ по разработке и сопровождению конфигураций (в т . ч . ведению информации о технических проектах и списка ошибок) рекомендутся использовать Систему проектирования прикладных решений (СППР) .

## 2 . Разработка исправительных версий

- 2 . 1 . Для выпуска каждой исправительной версии создается новое хранилище на основе конфигурации последней выпущенной версии .

Важно – нужно создавать новое хранилище , а не копировать основное!

- 2 . 2 . В исправительной версии не должно быть объемных доработок конфигурации , в противном случае нужно пересматривать сроки выпуска плановой версии .
- 2 . 3 . Все закладки в хранилище исправительной версии должны содержать комментарий .
- Требования к содержанию комментариев аналогичны требованиям к закладкам в хранилище плановой версии (см . п . 3 . 4) .
- 2 . 4 . Все изменения , которые выполняются в исправительном релизе , должны синхронно повторяться в основном хранилище . Если в исправительном релизе добавляются новые объекты (реквизиты объектов) , то переносить изменения нужно исключительно с помощью сравнения/объединения конфигураций , для того чтобы не различались внутренние идентификаторы объектов конфигурации .
- 2 . 5 . При сборке исправительной версии рекомендуется устанавливать метку с информацией о номере сборки на закладке той версии хранилища , конфигурация которой идет в сборку . Обычно это последняя на момент сборки закладка .

## 3 . Разработка плановой версии

- 3 . 1 . Разработка плановых версий ведется в основном хранилище конфигурации .
- 3 . 2 . Закладки в основное хранилище должны осуществляться таким образом , чтобы каждая закладка переводила конфигурацию хранилища из одного рабочего (готового к выпуску) состояния в другое .

Не допускается закладка не полностью отлаженного функционала! Основное хранилище всегда должно находиться в «неразваленном» состоянии , чтобы в любой момент можно быть начать сборку плановой версии .

- 3 . 3 . В основном хранилище разрешается выполнять следующие работы:
- исправление ошибок , не требующих перепроектирования , объемного кодирования и тестирования . Если ошибка требует больших переработок и/или пересмотра проектных решений , то исправление такой ошибки должно вестись в рамках технического проекта . Порядок работы с основным хранилищем должен быть таким же , как и по другим техническим проектам;
- встраивание новых версий библиотек;
- встраивание полностью отлаженных , прошедших отладочное тестирование проектов;
- в исключительных случаях в основном хранилище может вестись разработка некоторых проектов , (например , проектов по массовому рефакторингу) .

Рекомендуется использовать реализованные в СППР возможности автоматической генерации текстов комментариев для закладок , связанных с исправлением ошибок и встраиванием технических проектов .

- 3 . 4 . Все закладки в основное хранилище должны содержать комментарий .

Содержание комментария зависит от характера выполненных работ:

- при исправлении ошибки обязательно должен быть указан номер и краткое наименование ошибки в системе баг ­ трекинга;
- при встраивании новой версии библиотеки должно быть указано название библиотеки и точный номер версии библиотеки;
- при встраивании технических проектов – номер проекта в системе ведения проектной документации , а также краткое наименование;
- при выполнении работ по техническому проекту в основном хранилище комментарий , помимо номера и краткого наименования проекта , должен содержать краткое описание сделанных в этой закладке изменений .
- 3 . 5 . Все изменения по техническому проекту должны переноситься в основное хранилище за одну закладку . Если необходимо переносить изменения несколько раз , то нужно открывать несколько проектов .

3 . 6 . После переноса изменений в основном хранилище можно исправлять ошибки , наведенные техническим проектом . Для пересмотра проектных решений нужно открывать новый проект .

- 3 . 7 . При сборке плановой версии рекомендуется устанавливать метку с информацией о номере сборки на закладке той версии хранилища , конфигурация которой идет в сборку . Обычно это последняя на момент сборки закладка .

## 4 . Разработка технических проектов

4 . 1 . Разработка каждого технического проекта ведется в отдельном хранилище .

При использовании СППР хранилище технического проекта может быть созданно автоматически . Если СППР не используется , хранилище технического проекта нужно будет создавать вручную , в соотвествии с порядком , описанном в Приложении 1 .

4 . 2 . При постановке хранилища технического проекта на поддержку от основного хранилища , платформа для всех объектов устанавливает правило «Объект поставщика , не редактируется» . Для работы над техническим проектом нужно изменить это правило на «Объект поставщика редактируется с сохранением поддержки» .

Правило «Объект поставщика редактируется с сохранением поддержки» нужно устанавливать только для тех объектов , которые изменяются при выполнении технического проекта . Правило нужно менять как можно более точечно – например , если изменения в проекте будут затрагивать только форму , то нужно изменить правило только для этой формы , а для объекта , которому эта форма принадлежит , нужно оставить правило «Объект поставщика , не редактируется» .

Для изменения правил поддержки нужно захватить только корень конфигурации , захватывать сами объекты не нужно .

Выполнение этих рекомендаций позволит упростить процесс переноса изменений между основным хранилищем и хранилищем тех . проекта .

4 . 3 . Ответственный за технический проект может периодически обновлять конфигурацию хранилища проекта . Периодичность обновления разработчик определяет самостоятельно .

На частоту обновления могут влиять следующие факторы:

- затрагивает ли технический проект объекты других ответственных;
- проводится ли в данное время рефакторинг общих механизмов;
- ведется ли сейчас в основном хранилище массовое исправление ошибок .

Порядок обновления хранилища технического проекта описан в приложении 2 .

- 4 . 4 . После окончания разработки ответственный согласует сроки завершения отладочного тестирования и сроки внесения технического проекта в основное хранилище . Проекты , затрагивающие большое количество объектов рекомендуется вноситься в основное хранилище ближе к сроку окончания разработки , чтобы уменьшить влияние на другие проекты .

Ответственные за другие технические проекты могут попросить перенести сроки внесения в основное хранилище .

В СППР согласовывать сроки встраивания технических проектов можно , используя функциональность контрольных точек по техническому проекту .

- 4 . 5 . Внесение проекта в основное хранилище должно осуществляться после завершения отладочного тестирования . Рекомендуется по окончании исправления ошибок , выявленных отладочным тестированием технического проекта , сформировать файл сравнения конфигурации проекта и конфигурации основного хранилища .
- 4 . 6 . Внесение наработок технического проекта в основное хранилище не должно проводить к длительному захвату объектов основного хранилища . Это достигается тем , что сначала хранилище технического проекта обновляется до состояния основного хранилища (по методике , описанной в приложении 2 . Если изменений много , то такое обновление может занять достаточно много времени (до нескольких дней) – за это время конфигурация основного хранилища может измениться . Поэтому процесс обновления может быть итеративным – на каждой итерации обновления отличия в конфигурациях будут становиться все ближе к величине изменений , внесенных техническим

проектом

.

После каждой итерации обновления целесообразно проводить быструю проверку работоспособности функционала , разрабатываемого в рамках проекта .

Начинать перенос изменений в основное хранилище (захватывать объекты в основном хранилище) следует только тогда , когда конфигурация технического проекта будет отличаться от конфигурации основного хранилища практически только на изменения , вносимые проектом .

- 4 . 7 . Ответственный за технический проект должен внимательно относиться к внесению изменений в основное хранилище . Нужно помнить , что основное хранилище должно в любой момент времени находиться в состоянии готовности к выпуску плановой версии .

После внесения изменений в основное хранилище разработчики технического проекта совместно с тестировщиками проводят быструю проверку того , что изменения перенесены корректно и не повлияли на работоспособность смежного функционала . Объем проверок и порядок их проведения определяет ответственный за проект .

- 4 . 8 . После проверки переноса изменений и до закладки изменений в основное хранилище , ответственный обязательно должен запустить проверку конфигурации . Проверку нужно проводить с максимальными настройками . Закладка изменений в основное хранилище допускается только после того , как будут исправлены все ошибки , выявленные проверкой конфигурацией , которые были привнесены проектом .
- 4 . 9 . После переноса изменений в основное хранилище ответственный за технический проект удаляет хранилище проекта

## 5 . Нумерация сборок

Изменение номеров версий регламентируется стандартом Нумерация редакций и версий Здесь будут уточнены правила изменения номера сборки (четвертое число в номере версии)

- 5 . 1 . Номер сборки следует увеличивать как в основном хранилище , так и в хранилище исправительного релиза в двух случаях:
- непосредственно перед сборкой релиза . Это необходимо , чтобы полный номер собранного релиза гарантированно отличался от полного номера предыдущего релиза;
- при закладке в хранилище обработчика обновления информационной базы . Это необходимо , чтобы после обновления из хранилища у всех участников разработки добавленный обработчик обновления запускался автоматически (только для конфигураций , основанных на Библиотеке Стандартных Подсистем) .
- 5 . 2 . 1 . При добавлении в хранилище обработчиков обновления информационной базы рекомендуется в рамках этой же закладки повышать номер сборки . Существует два возможных сценария:
- Обработчик обновления добавляется при разработке технического проекта в хранилище технического проекта . В этом случае при переносе изменений в основное хранилище следует увеличить номер сборки основного хранилища .
- Обработчик обновления добавляется в рамках исправления ошибки . Если ошибка исправляется только в одном хранилище (основном или исправительном) , то номер сборки повышается только в нем , если в двух – значит нужно увеличить номер в обоих хранилищах .
- 5 . 2 . 2 . Обработчик и изменение номера сборки должны помещаться в хранилище в рамках одной закладки . При этом обработчик обновления должен быть «привязан» к тому номеру сборки , который вместе с ним помещается в хранилище .
- 5 . 2 . 3 . Если в рамках одной конфигурации обработчики обновления разбиты по технологическим подсистемам (например , в конфигурации 1С:ERP обработчики разбиты на подсистемы УправлениеПредприятием и УправлениеТорговлей) , то нужно повышать номер сборки как подсистемы , к которой относится обработчик , так и конфигурации .
- 5 . 3 . Номер сборки необходимо изменять:
- 1 . В свойствах конфигурации .
- 2 . В процедуре ОбновлениеИнформационнойБазы&lt;ИмяБиблиотеки&gt; . ПриДобавленииПодсистемы (только для конфигураций , основанных на Библиотеке Стандартных Подсистем) .

## Приложение 1 . Порядок создания хранилища технического проекта

- 1 . Обновить из хранилища конфигурацию информационной базы , подключенную к основному хранилищу
- 2 . Создать файл поставки конфигурации основного хранилища ( * . cf)
- 3 . В информационную базу , которая будет использоваться для работы над техническим проектом , загрузить конфигурацию из файла поставки . После загрузки конфигурации из файла поставки конфигурация будет находиться на поддержке без возможности изменения .
- 4 . Создать хранилище конфигурации в соответствующей общей папке (при создании хранилища платформа включит в конфигурации возможность изменения)
- 5 . Добавить пользователя ТолькоПросмотр (без пароля , без права захвата объектов) . Этого пользователя не нужно использовать для подключения базы к хранилищу – только для обновления из хранилища (получения

конфигурации хранилища)

- 6 . Добавить в хранилище пользователей , перечисленных в проекте (логин – фамилия сотрудника , без пароля , с правом захвата объектов) . Не нужно использовать для работы участников проекта логин пользователя ТолькоПросмотр .

## Приложение 2 . Порядок обновления хранилища технического проекта до состояния основного хранилища

Перед выполнением переноса изменений из хранилища технического проекта (далее ХТП) в основное хранилище (далее ОХ) выполняется обновление ХТП до состояния ОХ .

Для того чтобы обновить ХТП до состояния ОХ необходимо выполнить следующее:

- 1 . Обновить информационную базу , подключенную к ОХ .
- 2 . Создать файл поставки конфигурации ОХ .
- 3 . Захватить все объекты в ХТП .
- 4 . Запустить сравнение основной конфигурации и конфигурации поставщика (Конфигурация – Сравнить конфигурации) . Результаты сравнения сохранить в файл – это изменения , внесенные в конфигурацию при работе над техническим проектом . В меню «Действия» выбрать пункт «Отчет о сравнении конфигураций» . Для дальнейшего использования лучше вывести и сохранить отчет о сравнении и в текстовом формате и формате табличного документа .
- 5 . Обновить конфигурацию (Конфигурация – Поддержка – Обновить конфигурацию – Выбор файла обновления – указать файл поставки конфигурации созданный на шаге 2) .

<!-- image -->

В появившемся окне сравнения и объединения конфигураций нажать кнопку " Фильтр " и установить флажок Показывать только дважды измененные свойства " .

<!-- image -->

Н
аэтиобъекты нужнообратитьвниманиеприобъединении , остальныеизменения можнообъединятьбез проверки .

<!-- image -->

- 6 . В диалоге , который появляется при нажатии на кнопку «Выполнить» окна сравнения и объединения конфигураций , для новых объектов поставщика нужно установить правило «Объект не редактируется» ­ как для объектов с правилом «Изменения разрешены» так и для объектов с правилом «Изменения не рекомендуются» , для всех остальных установить флаг «Сохранять текущий режим» (по умолчанию он установлен) .
- 7 . После завершения объединения нужно исправить объекты , затрагиваемые техническим проектом , изменения в которых затерлись при обновлении . По сути это означает , что нужно выполнить повторное внесение доработок , реализованных в рамках технического проекта в объекты конфигурации .
- 8 . Запустить сравнение обновленной основной конфигурации технического проекта и обновленной конфигурации поставщика (Конфигурация – Сравнить конфигурации)
- 9 . Результаты сравнения сохранить в файл , имя файла должно отличаться от имени файла созданного на шаге 6 . В меню «Действия» выбрать пункт «Отчет о сравнении конфигураций» . Для дальнейшего использования лучше вывести и сохранить отчет о сравнении в текстовом формате .
- 10 . Сравнить файлы , созданные на шаге 4 и шаге 9 . При правильном обновлении , сравнение файлов не должно показать отличий .

<!-- image -->

<!-- image -->

## Особенности разработки конфигураций для ОС Linux и OS X

- 1 . В большинстве случаев , в конфигурации не требуется предпринимать каких­либо специальных мер для обеспечения работы конфигурации (клиентское приложение и сервер) на ОС Linux и OS X . В этой статье перечислены отдельные рекомендации для специфических случаев , описанных в приложении 7 документации по платформе 1С:Предприятие .
- 2 . Для реализации всех ключевых функций прикладного решения следует использовать возможности платформы 1С:Предприятие по унификации работы на различных операционных системах .
- 2 . 1 . Вместо Windows ­ технологии COM (объект COMОбъект) следует использовать специализированные кроссплатформенные механизмы платформы:
- Для администрирования кластера серверов 1С:Предприятия , вместо работы с объектной моделью агента сервера через COM­объект v83 . ComConnector , следует использовать сервер администрирования (ras) и утилиту администрирования (rac) . При работе в OS X утилиты rac и ras недоступны .
- Для получения путей к рабочим каталогам , вместо COM ­ объектов ОС Windows , следует использовать методы глобального контекста РабочийКаталогДанныхПользователя , КаталогДокументов , КаталогВременныхФайлов .

В остальных случаях следует рассмотреть другие альтернативы технологии COM , работающие в ОС Linux и OS X , например , технологию создания внешних компонент Native API .

- 2 . 2 . Внешние компоненты (клиентские и серверные) , поставляемые в составе конфигурации , следует разрабатывать с использованием технологии Native API . Это позволяет создавать кроссплатформенные внешние компоненты для различных операционных систем , а также для веб­клиента , работающего в веб ­ браузерах , которые поддерживаются платформой 1С:Предприятие . Подробнее о разработке внешних компонент см . документацию по платформе .
- 2 . 3 . Для механизмов , использующих объект Почта , следует рассмотреть альтернативные варианты:
- По переводу на объект ИнтернетПочта;
- По разработке внешних компонент для ОС Linux и OS X , которые поддерживают работу с установленными почтовыми клиентами в ОС Linux и OS X .
- 2 . 4 . Внешний вид элемента управления ПолеHTMLДокумента может отличаться в зависимости от того , в какой ОС – Windows или Linux/OS X запущено клиентское приложение . Это связано с тем , что в ОС Linux и OS

X поле реализовано на основе библиотеки WebKit (вместо Internet Explorer в ОС Windows) .

Следует учитывать , что внешний вид и объектная модель HTML­документа (DOM­модель) , доступ к которому осуществляется с помощью свойства ПолеHTMLДокумента . Документ , могут отличаться в ОС Linux и OS X от таковых при работе в клиентском приложении , работающего на ОС Windows:

- Задействовать только стандартные элементы DOM­модели , которые доступны во всех вариантах работы .
- При подготовке HTML содержимого ориентироваться на стандарты вебразработки ­ не следует использовать методы и свойства , специфичные для конкретного веб­браузера .

## Например , неправильно:

```
Элементы . ПолеHTML . Документ . execCommand( " SaveAs " );
```

так как команда «SaveAs» поддерживается не во всех веб­браузерах (см . например: http://help . dottoro . com/larpvnhw . php) .

## Правильно:

```
АдресВоВременномХранилище = ПолучитьМакет( . . . ); ПолучитьФайл(АдресВоВременномХранилище , " Инструкция . html " );
```

- 2 . 5 . Если в составе конфигурации поставляются картинки в форматах WMF и EMF (метафайлы Windows) , их следует заменить на растровые , например PNG или JPG .
- 2 . 6 . Также следует использовать возможности платформы 1С:Предприятие по унификации работы с файловой системой .
- 2 . 6 . 1 . В ОС Linux имена файлов регистро­зависимые , поэтому во всех местах кода , который работает с конкретным файлом , его имя (путь) должен указываться в одном регистре .
- 2 . 6 . 2 . Не следует указывать разделить пути файла и маску всех файлов вручную (например , «/» , «* . *») , для этого необходимо использовать функции ПолучитьРазделительПути и ПолучитьМаскуВсеФайлы .

При использовании в конфигурации Библиотеки стандартных подсистем для работы с именами файлов также рекомендуется использовать функции общего модуля ОбщегоНазначенияКлиентСервер .

- 3 . Для отдельных второстепенных (сервисных) функций прикладного решения допустимо отключать их работу в ОС Linux и OS X . Например , для прикладного решения в области торгового учета второстепенными могут считаться возможности по синхронизации данных через прямое подключение с другими программами , по импорту почты из сторонних почтовых клиентов и т . п .

Для этого следует скрывать команды таких механизмов из командного интерфейса программы при работе в ОС Linux и OS X , либо (если технически скрыть невозможно) выводить сообщение вида «&lt;Операция&gt; доступна только при работе в ОС Windows» .

## Например:

```
&НаКлиенте Процедура ОбработкаКоманды(ПараметрКоманды , ПараметрыВыполненияКоманды) Информация = Новый СистемнаяИнформация; Если Информация . ТипПлатформы <> ТипПлатформы . Windows _ x86 Или Информация . ТипПлатформы <> ТипПлатформы . Windows _ x86 _ 64 Тогда ПоказатьПредупреждение( , НСтр( " ru = ' Печать в Microsoft Word доступна только при работе в ОС Windows . ' " )); Возврат; КонецЕсли;
```

```
< . . . > КонецПроцедуры
```

При использовании в конфигурации Библиотеки стандартных подсистем рекомендуется использовать функции ЭтоLinuxКлиент , ЭтоOSXКлиент и ЭтоWindowsКлиент из общего модуля ОбщегоНазначенияКлиентСервер .

## См . также

- Общие требования к конфигурации
- Глава " 35 . Особенности разработки кроссплатформенных прикладных решений " документации по платформе 1С:Предприятие

## Оформление карты маршрута бизнеспроцесса

Пример оформления бизнес­процесса:

<!-- image -->

## 1 . Общие рекомендации

- 1 . 1 Бизнес­процессы рисуются сверху ­ вниз . Другая ориентация (например , слева направо) допустима , если позволяет изобразить бизнес­процесс наилучшим образом .
- 1 . 2 Используется стандартная сетка – шаг 20 точек , нарисованная линиями .
- 1 . 3 Не используются жирные и разноцветные шрифты .
- 1 . 4 Количество изгибов соединительных линий должно быть минимальным . Если можно соединить две точки , изогнув соединительную линию один раз , то нужно стараться сделать именно так , подгоняя размеры и положение точек .
- 1 . 5 При размещении декораций и точек маршрута рекомендуется соблюдать отступ в одну клетку от левого и верхнего края карты маршрута .
- 1 . 6 Ширину точек маршрута нужно делать равной четному количеству клеток . Это необходимо для того , чтобы соединительные линии сходились без дополнительных изгибов . Размеры точек и декораций нужно стремиться приближать к пропорциям спичечного коробка (например , 3х6 клеток) . Следует избегать вытянутых по вертикали или горизонтали точек – они мешают восприятию схем .
- 1 . 7 Выравнивание текста в точках маршрута и декорациях следует делать по центру (по умолчанию) , за исключением комментариев – их лучше делать выровненными влево , как обычный текст .
- 1 . 8 Рекомендуется размещать декорации и точки маршрута так , чтобы они не пересекали границы печатного листа (меню Графическая схема ­ Режим просмотра страниц) .

## 2 . Рекомендации по оформлению отдельных элементов

- 2 . 1 Точки Старт и Завершение устанавливаются размером 2х2 клетки , без наименования . Количество точек старта и завершения неограниченно и определяется логикой бизнес­процесса . Отступ от точки старта или завершения до другой точки бизнес­процесса рекомендуется устанавливать в две клетки:
- 2 . 2 Точки " Действие " , " Автоматическая обработка " , " Вложенный бизнеспроцесс " должны иметь размер сообразно размещаемому в них тексту . Текст должен носить характер короткой директивы и отвечать на вопрос " Что нужно сделать? " (например " Выписать счет " , а не " Выписка счета " ) . Слева от этих точек нужно располагать декорации , описывающие исходные или входящие данные , требуемые для выполнения действий , предусмотренных данной точкой .

<!-- image -->

Справа от точки нужно располагать декорации , описывающие результирующие или исходящие данные , которые получаются в результате выполнения действий , предусмотренных данной точкой .

- 2 . 3 Изображения входящих документов , служащих основой для выполнения действий , предусмотренных в точках маршрута нужно располагать слева от точки на расстоянии двух клеток и соединять пунктирной линией со стрелкой . Исходящие документы , являющие результатом выполнения действий , предусмотренных точкой маршрута , нужно располагать справа от точки на расстоянии двух клеток и соединять пунктирной линией со стрелкой . Документы оформляются фигурой вида Документ:

<!-- image -->

Пропорции декорации , изображающей документ должны по возможности приближаться к формату А4 (например , 4х5 или 3х4 клетки стандартной сетки) .

- 2 . 4 Комментарии к точкам маршрута нужно изображать на расстоянии двух клеток слева от точки маршрута , если они относятся к входящему документу , или справа от точки маршрута , если к исходящему документу . Комментарий оформляется в виде фигуры " Скобки вертикальные " или " Скобки горизонтальные " и соединяется с левой или правой гранью точки маршрута пунктирной линией без стрелки:
- 2 . 5 Точки условного перехода включают в себя короткий текст вопроса , заканчивающийся знаком вопроса . Вопрос нужно формулировать так , чтобы на

<!-- image -->

него можно было ответить только Да или Нет (например , Счет есть? , Отгрузка разрешена? , ОК?) . Точки условия нужно стремиться сделать как можно более компактными , но не в ущерб наглядности . Это связано с тем , что , точки условия являются точками перехода , а не точками действия , и поэтому для участников бизнес­процесса второстепенны . Соединительные линии точек условия (как входящие , так и исходящие) должны иметь суммарную длину не менее двух клеток для того , чтобы надписи Да и Нет читались нормально , например:

<!-- image -->

## Ограничения на переименование объектов метаданных

- 1 . Запрещается переименовывать общий модуль и создавать новый с тем же именем . Следует создавать новый общий модуль с новым именем , а код исходного модуля переносить в новый модуль .

В противном случае , при сравнении и объединении с новой конфигурацией поставщика , например , в подписках на события , которые ссылаются на общий модуль , будет установлена связь по имени с новым общим модулем (а не переименованным) , где нет требуемых процедур .

- 2 . В некоторых случаях , при изменении структуры метаданных возникает необходимость удалить объект метаданных и создать новый с тем же именем . Например , при «сужении» состава измерений в регистре . В таких случаях следует переименовать устаревший объект метаданных , добавив ему к имени префикс Удалить .

В противном случае , если удалить объект метаданных и создать новый с тем же именем , может возникнуть ошибка при обновлении конфигурации на поддержке . Если в конфигурации на поддержке в устаревший объект вносились изменения с сохранением поддержки (например , в целях переопределения поведения объекта или исправления ошибок) , то он не будет удален при объединении конфигураций , и попытка обновления конфигурации базы данных завершится неудачно из­за наличия двух объектов метаданных (старого и нового) с одинаковым именем .

См . также Удаление устаревших объектов метаданных из конфигурации

Методическая рекомендация (полезный совет)

- 3 . Если в конфигурации возникает необходимость хранить ссылки на объекты метаданных , то рекомендуется придерживаться следующих правил .
- 3 . 1 . Если в конфигурации не используется Библиотека стандартных подсистем (БСП) , то рекомендуется заводить строковые реквизиты (Строка , 255) для хранения полных имен объектов метаданных . Например , в справочнике ШаблоныСообщений – реквизит ПолноеИмяТипаПараметраВводаНаОсновании , в регистре сведений НастройкиПечатиОбъектов ­ измерение ТипОбъекта и т . п .

При этом если в конфигурации переименовываются (или удаляются) какие­либо объекты метаданных , то при обновлении информационной базы требуется также предусмотреть

соответствующую замену (удаление) всех имен , хранимых в базе . В противном случае , ссылки на имена объектов метаданных станут рассогласованными , что приведет к различным ошибкам в тех подсистемах конфигурации , которые опираются на имена объектов метаданных .

3 . 2 . При использовании в конфигурации Библиотеки стандартных подсистем (БСП) следует использовать ссылки на справочник ИдентификаторыОбъектовМетаданных , который

- централизованно хранит ссылки на имена объектов метаданных конфигурации , автоматически отслеживает переименования , удаления и добавление объектов метаданных и позволяет избежать массовых операций по замене имен в таблицах;
- а также позволяет сократить размер записей таблиц (ссылка вместо строки длиной 255) , что улучшает общую производительность системы .

Исключение составляют роли и подсистемы , для которых автоматически не отслеживаются переименования , и для них требуется в явном виде описать переименования . Подробнее см . документацию к БСП .

В противном случае , если не указать переименование ролей и подсистем , то их ссылки в справочнике

ИдентификаторыОбъектовМетаданных станут рассогласованными (старый элемент справочника будет помечен на удаление , а вместо него будет создан новый) , что приведет к различным ошибкам в тех подсистемах конфигурации , которые опираются на данные этого справочника . Например:

- варианты отчетов , связанные с переименованной подсистемой , исчезнут из панели отчетов;
- дополнительные отчеты и обработки , выведенные пользователями в раздел , связанный с переименованной подсистемой , пропадут из списка;
- переименованные роли , указанные в профилях групп доступа , не будут назначены пользователям .

## 3 . 3 . При этом справочник

ИдентификаторыОбъектовМетаданных не предназначен для хранения ссылок на объекты метаданных других конфигурации (например , в механизмах интеграции с другими системами) . Для этих целей рекомендуется использовать строковые реквизиты и реализовывать специальные механизмы по поддержанию актуальности их значений .

- 3 . 4 . В случаях , когда ведется две и более параллельных «веток» разработки , например , выпускаются версии 2 . 0 и 3 . 0 (или организован выпуск исправительных релизов параллельно с выпуском новых функциональных релизов) нужно учесть следующее: в текущей и младших версиях конфигурации запрещается переименование с последующим созданием нового объекта метаданных с тем же полным именем , а также двойное переименование . Правильно выполнять такие переименования – 3 . 0 .

только в самой последней версии В противном случае , при переходе с младшей версии на старшую версию это переименование будет учтено дважды , что приведет к рассогласованию ссылок на объекты метаданных . При использовании ссылок на справочник ИдентификаторыОбъектовМетаданных Библиотеки стандартных подсистем , такой запрет действует только для ролей и подсистем .

Подробнее см . документацию к БСП

## Требования к установке и обновлению прикладных решений

- 1 . Подготовка дистрибутивов установки и обновления прикладных решений (конфигураций) системы 1С:Предприятие 8 должна выполняться в соответствии с рекомендациями , изложенными в главе 30 «Поставка и поддержка конфигурации» Руководства разработчика из комплекта документации к программным продуктам системы 1С:Предприятие 8 .
- 2 . Исходя из данных требований , полный путь к каталогу поставляемых разработчиком шаблонов конфигурации (информационных баз) , в общем случае , имеет вид:

```
<Каталог шаблонов>\<каталог разработчика>\<каталог конфигурации>\ <каталог версии>
```

При этом в каталоге версии вместо точек должны использоваться подчеркивания .

Например , версия 11 . 1 . 3 . 6 конфигурации «Управление торговлей» , редакция 11 . 1 , будет устанавливаться в каталог:

```
<Каталог шаблонов>\1C\Trade\11 _ 1 _ 3 _ 6\
```

- 3 . В каталоге версии должен быть расположен файл­манифест 1cv8 . mft , в котором описываются установленные шаблоны конфигурации ( . cf) и демонстрационные информационные базы ( . dt) .

Например , файл­манифест конфигурации «Управление торговлей» , редакция 11 . 1 , при установке которой устанавливаются 2 шаблона информационных баз ­ пустой (рабочей) и демонстрационной базы .

```
Vendor=Фирма " 1С " Name=УправлениеТорговлей Version=11 . 1 . 3 . 6 AppVersion=8 . 3 [Config1] Catalog=1С:Управление торговлей/Управление торговлей Destination=1C\Trade Source=1cv8 . cf [Config2] Catalog=1С:Управление торговлей/Управление торговлей (демо) Destination=1C\DemoTrd Source=1Cv8 . dt
```

- 4 . 1 . В целях исключения совпадения названий конфигураций и возможных в таком случае коллизий при отображении шаблонов информационных баз в диалоге создания ИБ , рекомендуется .
- В строке Catalog файла­манифеста , в наименование шаблона конфигурации (часть значения до символа «/») следует включать в явном виде название разработчика . Название разработчика может присутствовать в любом месте наименования шаблона конфигурации , например:

## 1С:Управление торговлей

или

## Управление торговлей (1С)

- В строке Destination рекомендуемый каталог создания информационной базы следует указывать в виде:

## Destination = &lt;каталог разработчика&gt;\&lt;каталог информационной базы&gt;

&lt;каталог разработчика&gt; должен содержать название разработчика , но в этом случае ­ адаптированное для использования в именах файловых каталогов . Например: 1C\Trade

- 4 . 2 . Для исключения повторений названия разработчиков – поставщиков прикладных решений (конфигураций) должны быть глобально уникальными: название для использования в наименованиях шаблонов конфигураций и название для использования в именах файловых каталогов .

Название разработчика выбирается один раз и в дальнейшем может использоваться разработчиком при установке и регистрации шаблонов всех разработанных им прикладных решений для системы программ 1С:Предприятие 8 .

- 5 . Для обновления версий прикладных решений (конфигураций) выпускаются отдельные дистрибутивы обновлений , которые включают в себя файл обновления конфигурации ( . cfu) .

Основным рекомендуемым способом обновления с помощью конфигуратора является поиск подходящих файлов обновления (меню Конфигурация – Поддержка – Обновить конфигурацию) . Кроме того , в конфигурациях могут быть предусмотрены и другие средства для обновления версий . При использовании в конфигурации Библиотеки стандартных подсистем (БСП) такая возможность предусмотрена в подсистеме «Обновление конфигурации» .

## Несущественные предупреждения проверки конфигурации

- 1 . Следующие предупреждения проверки конфигурации (конфигуратор – меню Конфигурация – Проверка конфигурации … ) не являются существенными для работоспособности прикладных решений и поэтому не подлежат обязательному исправлению:
- Пустой обработчик (для обработчиков оповещений в программных модулях);
- Неразрешимые ссылки на объекты метаданных (в формах и в справке);
- Неразрешимые ссылки на картинки (в формах);
- Неправильные пути к данным (в формах) .

Кроме того методика поиска и исправления подобных мест отсутствует .

2 . При регламентной проверке конфигурации не следует включать флажок Поиск использования синхронных вызовов , так как в результатах проверки выводятся , в том числе , корректные места вызовов в коде , который не исполняется в веб ­ клиенте (например , серверный код) . См . также: Ограничение на использование модальных окон и синхронных вызовов .

## См . также

- Общие требования к конфигурации

## Общие сведения о выпуске конфигураций

1 . Конфигурации выпускаются версиями и редакциями . 2 . Версия ­ исправление текущих ошибок и внесение незначительных усовершенствований . Выпуск новой версии должен обеспечивать переход с предыдущей с сохранением данных . 3 . Редакция ­ внесение существенных изменений в структуру учета , требующих преобразования данных . Формальным , но не обязательным , признаком новой редакции является необходимость переноса данных путем конвертации . При выпуске новой редакции желательно обеспечивать переход с сохранением данных . Если по каким либо причинам это невозможно , необходимо описать процедуру перехода на новую редакцию (начало работы , и т . . .

- перенос начальных остатков д )

## См . также

- Нумерация редакций и версий

## Нумерация редакций и версий

- 1 . Номер очередной редакции конфигурации , начинается со следующего целого номера относительно предыдущей редакции . Для обозначения редакции обычно номер редакции объединяют через точку с номером подредакции , например: редакция 1 . 5 , редакция 1 . 6 и т . д . Для новых конфигураций нумерация начинается с 1 . 0 .
- 2 . Все версии одной подредакции (включая альфа , ознакомительные , бета и финальные версии) нумеруются подряд . Нумерация версий начинается с 1 .
- 3 . Информация о номере редакции , номере подредакции и номере версии объединяются в полный номер версии конфигурации . Он указывается в свойстве Версия конфигурации и представляет собой строку символов следующего вида:

```
{Р|РР} . {П|ПП} . {З|ЗЗ} . {С|СС} где: Р ­ номер редакции (минимум 1 цифра , может занимать и больше разрядов); П ­ номер подредакции (минимум 1 цифра , может занимать и больше разрядов); З ­ номер версии (минимум 1 цифра , может занимать и больше разрядов); С ­ номер сборки (минимум 1 цифра , может занимать и больше разрядов) . Пример: 1 . 6 . 4 . 7 – 7 ­ я сборка , 4 ­ ой версии , редакции 1 . 6
```

## См . также

- Общие сведения о выпуске конфигураций

## Заполнение свойств конфигурации информацией о выпуске

1 . Синоним . В синониме указывается официальное название конфигурации , которое будет идентифицировать конфигурацию в документации , на коробке с продуктом , прайс­листе , рекламе , в информационных и методических материалах . В конце официального названия через запятую указывается слово " редакция " и номер редакции . Например: " Бухгалтерия предприятия , редакция 1 . 6 " 2 . Имя . Имя образуется по правилам образования имен из синонима; слово " редакция " , номер редакции (и подредакции) – не указываются . Например: " БухгалтерияПредприятия " 3 . Краткая информация . Краткая информация повторяет синоним . 4 . Подробная информация . Подробная информация повторяет синоним . 5 . Логотип . Для типовых конфигураций фирмы " 1С " картинка логотипа не заполняется . 6 . Заставка . В качестве заставки устанавливается картинка размером 305х110 точек . 7 . Авторские права . Указывается строка вида: Copyright (C) &lt;разработчик&gt; , хххх­хххх . Все права защищены Вместо " хххх­хххх " указываются конкретные годы выпуска конфигурации . Например: Copyright (C) ООО " 1С ­ Софт " , 2009 ­ 2016 . Все права защищены 8 . Адрес информации о поставщике . Для типовых конфигураций фирмы " 1С " указывается строка: http://www . 1c . ru 9 . Адрес информации о конфигурации . Для типовых конфигураций фирмы " 1С " указывается строка: http://v8 . 1c . ru/&lt;короткое имя&gt;/ , где вместо &lt;короткое имя&gt; указывается англоязычное короткое имя конкретной конфигурации , например: http://v8 . 1c . ru/trade/ 10 . Поставщик . Для типовых конфигураций фирмы " 1С " в качестве

поставщика указывается:

- 11 . Версия . Указывается полный номер версии конфигурации . Например , 1 . 6 . 4 . 7

Подробнее об образовании номера версии написано в разделе Нумерация .

Фирма " 1С " редакций и версий

- 12 . Адрес каталога обновлений . Для типовых конфигураций фирмы " 1С " указывается строка:

http://downloads . v8 . 1c . ru/tmplts/

## Общие сведения об организации хранения данных

Методическая рекомендация (полезный совет)

- 1 . При проектировании системы одной из задач является выбор типов объектов метаданых для реализации хранения соответствующих сущностей предметной области . Неправильный выбор типов объектов ведет к неэффективности прикладного решения , невозможности его последующего развития и делает невозможным адаптацию к возможным изменениям состава решаемых задач .
- 2 . При выборе типа объектов метаданных в общем случае следует руководствоваться следующей схемой прикладного решения:
* Стрелки на схеме обозначают взаимосвязи между данными (взаимные ссылки) .

<!-- image -->

На схеме выделяются следующие блоки:

- 1 . Условно­постоянная информация . К этой части относится информация , которая вводится один раз , сравнительно редко изменяется и многократно используется . Примером
- такой информации могут служить различные классификаторы , настройки , перечни , реестры , нормативно ­ справочная информация и т . п .
- 2 . Различные события процессов предметной области , которые привязаны ко времени и могут порождать при регистрации различные сведения , изменять значения показателей . Пример – документооборот предприятия , ведение учета; регистрация заявок , звонков и т . п .
- 3 . Накопленные сведения , значения показателей , которые характеризуют процессы и текущее состояние прикладной области . В отличие от первых двух частей , эти данные имеют необъектную природу и не являются самостоятельными сущностями с точки зрения прикладной области . Пример – история продаж товара , остатки на складах , текущий бухгалтерский баланс , история изменения курсов валют и т . п .

Отдельно выделяются средства для анализа и обработки данных , отчеты , механизмы , которые опираются на данные всех остальных блоков , но сами данных не содержат .

Подробнее о задачах и принципах хранении информации см . в книге «Профессиональная разработка в системе 1С Предприятие 8» глава 6 .

- 2 . 1 . Таким образом , упрощенно , для каждой сущности предметной области необходимо выбрать соответствующий блок по следующей схеме:
- Если необходимо хранить сравнительно редко изменяющуюся информацию , не привязанную ко времени , то это блок условно постоянной информации (1) .
- Если необходимо регистрировать события , требующие документально подтверждения с отслеживанием последовательности событий на временной оси , то это блок событий процессов предметной области (2) .
- В противном случае сущность должна относиться к блоку сведений и значений показателей (3) .

Более подробные критерии выбора того или иного блока:

| Критерий / блок                  | Условно постоянная информация                                  | События процессов предметной области                                                                                                                                      | Накопленные сведения , значения показателей                                                      |
|----------------------------------|-----------------------------------------------------------------|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------|--------------------------------------------------------------------------------------------------|
| Основное предназначение          | Необходимо хранить нормативно  справочную информацию , реестры | Необходимо регистрировать события  процессов ,  обеспечивать документальное подтверждение сведениям                                                                       | Необходимо хранить данные которые характеризуют процессы  и текущее состояние прикладной области |
| Отслеживание изменения состояния | Не требуется                                                    | Требуется регистрация документа к учету ,  отмена регистрации учета документа ,  учет запусков или окончаний процесса , изменения состояния задач , формирование движений | Не требуется                                                                                     |
| Иерархия , группировка данных    | Требуется иерархия  и группировка , возможно между разными      | Не требуется                                                                                                                                                              | Не требуется                                                                                     |
| Ключевые                         | Необходимо                                                      | Необходимо учитывать дату                                                                                                                                                 | Не требуется                                                                                     |

| свойства                                                                          | иметь наименование , события ,                                                                                                          | его номер                                                              |                                                      |
|-----------------------------------------------------------------------------------|-----------------------------------------------------------------------------------------------------------------------------------------|------------------------------------------------------------------------|------------------------------------------------------|
| Необходимо хранить редко изменяемые реквизиты произвольных данных                 | Необходимо хранить ссылки  на другие объекты  и значения параметров ,  характеризующие событие                                          | Необходимо хранить только значения реквизитов для других объектов базы | Хранение значений дополнительных реквизитов сущности |
| Необходимы серии  кодов  по всем элементам данного типа или  в  пределах иерархии | Необходимы серии  номеров  по всем элементам данного типа  или в  пределах периода  по дате , сквозная  нумерация объектов разных типов | Не требуется                                                           | Нумерация                                            |

- 2 . 2 . Затем , необходимо принять решение о конкретном виде типа объекта метаданных внутри выбранного блока:
- 2 . 2 . 1 . Для хранения условно ­ постоянной информации:

Область применения (уточнение): управляемое приложение , обычное приложение .

- 1 . Если требуется хранение плана счетов для организации учета по принципам двойной записи , то используется специализированный объект метаданных «План счетов»
- 2 . Если требуется хранение перечня видов расчета для организации учета начислений и удержаний , то используется специализированный объект метаданных «План видов расчета»
- 3 . Если требуется хранить список характеристик (свойств) , причем состав самого списка , тип характеристик , их состав определяются пользователем , то используется объект метаданных «План видов характеристик»
- 4 . Если требуется хранить одиночное значение , которое редактирует пользователь (как правило , это администратор , выполняющий настройки системы) , не требующего ссылок из других данных , то используется объект метаданных «Константа»
- 5 . Если необходимо определить фиксированный список значений не редактируемый пользователем , без каких ­ либо дополнительных реквизитов , то используется объект метаданных «Перечисление»
- 6 . В остальных случаях , как правило , используется объект метаданных «Справочник»

Более подробные критерии выбора того или иного вида объекта метаданных:

| Критерий / тип объекта      | Константа                                                        | Перечисление                                                                        | План видов характеристик *                                                         | Справочник                                                  |
|-----------------------------|------------------------------------------------------------------|-------------------------------------------------------------------------------------|------------------------------------------------------------------------------------|-------------------------------------------------------------|
| Основное предназначение     | Необходимо хранение одиночных значений , предопределенных данных | Необходимо хранение списка неизменных представлений без дополнительных их атрибутов | Необходимо хранение списка сущностей и значений характеристик экземпляров сущности | Требуется хранение списка объектов  и значений их атрибутов |
| Добавление и редактирование | Требуется только изменение                                       | Не требуется                                                                        | Требуется добавление ,                                                             | Требуется добавление ,                                      |

| пользователем                                        | значения     |              | удаление и изменение элементов , редактирование состава  и значений характеристик сущности   | удаление , изменение элементов                                                                      |
|------------------------------------------------------|--------------|--------------|----------------------------------------------------------------------------------------------|-----------------------------------------------------------------------------------------------------|
| Иерархия , группировка данных                        | Не требуется | Не требуется | Требуется  в пределах одной сущности                                                         | Требуется  в пределах одной сущности  или между разными сущностями                                  |
| Хранение значений дополнительных реквизитов сущности | Не требуется | Не требуется | Необходимо хранить произвольные данные для атрибутов сущности                                | Необходимо хранить произвольные данные для атрибутов сущности                                       |
| Хранение списков значений дополнительных реквизитов  | Не требуется | Не требуется | Требуется хранение списков наборов значений реквизитов для сущности                          | хранение списков наборов значений реквизитов для сущности                                           |
| Возможность ввода  на основании других объектов      | Не требуется | Не требуется | Необходим  ввод новых элементов с использованием информации других объектов                  | Необходим ввод новых элементов с использованием информации других объектов                          |
| Нумерация                                            | Не требуется | Не требуется | Необходимы серии  кодов  по всем элементам одного типа  или  в пределах группировки          | Необходимы серии  кодов  по всем элементам одного типа  или в  пределах группировки или  подчинения |

* область применения (уточнение): управляемое приложение , обычное приложение .

## 2 . 2 . 2 . Для хранения событий процессов предметной области:

Область применения (уточнение): управляемое приложение , обычное приложение .

- 1 . Если требуется учет одиночных событий , адресованных некоторому исполнителю (пользователю , сотруднику , группе или роли) не требуется формирование движений по результатам события: то используется объект метаданных «Задача»
- 2 . Если требуется регистрировать в системе возникновение и ход регулярного процесса , состоящего из последовательности действий (событий) , то используется объект метаданных «Бизнес­процесс» . Для учета событий , действий в рамках процесса используется объект метаданных «Задача»
- 3 . В остальных случаях , как правило , используется объект метаданных «Документ»

Более подробные критерии выбора того или иного вида объекта метаданных:

| Задача *                                                                                                                                             | Бизнес­процесс * (с задачами)                                                                                                                           | Критерий / тип объекта Документ                                     |
|------------------------------------------------------------------------------------------------------------------------------------------------------|---------------------------------------------------------------------------------------------------------------------------------------------------------|---------------------------------------------------------------------|
| Необходимо вести одиночных событий , адресованных исполнителям Необходимо вести учет последовательности событий адресованных некоторым исполнителям  | , Необходима регистрация событий во времени , генерация вторичных данных , соответствующих этим событиям                                                | Основное предназначение учет некоторым                              |
| Не требуется                                                                                                                                         | Не требуется                                                                                                                                            | Вложенность  Требуется учет процессов , вложенных в другие процессы |
| Не требуется  Не требуется                                                                                                                           | объединение документов разных видов  в                                                                                                                  | Объединение в журналы                                               |
| «новый» , Требуются состояния  работе» ,  «завершен»                                                                                                 | «новый» ,  «в Требуются состояния «проведен» ,  «не проведен»                                                                                           | Состояние объекта Требуются состояния  «выполнено»                  |
| Необходимы серии номеров  по всем задачам данного вида  или  в пределах периода по дате Необходимы серии  пределах периода  нумерация событий внутри | номеров  по процессам данного вида  или по дате , Необходимы серии  номеров для документов разных видов  – сквозные ,  или  в пределах периода  по дате | Нумерация всем  в  процесса                                         |

* область применения (уточнение): управляемое приложение , обычное приложение .

## 2 . 2 . 3 . Для хранения накопленных сведений , значений показателей:

Область применения (уточнение): управляемое приложение , обычное приложение .

- 1 . Если требуется хранение данных учета с использованием принципа двойной записи , то используется специализированный объект метаданных «Регистр бухгалтерии»
- 2 . Если требуется хранение результатов расчета учета начислений и удержаний , то используется специализированный объект метаданных «Регистр расчета»
- 3 . Если требуется хранение изменений показателей – приход и расход , получение остатков и оборотов за период , то используется объект метаданных «Регистр накопления» .
- 4 . Во всех остальных случаях используется объект метаданных «Регистр сведений» .

Более подробные критерии выбора того или иного вида объекта метаданных:

| Критерий /   | Регистр накоплений   | Регистр сведений   |
|--------------|----------------------|--------------------|
| тип объекта  | Регистр накоплений   | Регистр сведений   |

<!-- image -->

| Основное предназначение            | Требуется хранение изменений данных  ­  прихода  и расхода значений показателей   | Требуется хранение информации  в виде наборов записей ,  регистрация некоторых сведений ,  значений   |
|------------------------------------|-----------------------------------------------------------------------------------|-------------------------------------------------------------------------------------------------------|
| Получение данных                   | Требуется  получение остатков , оборотов данных                                   | Необходимо получение среза информации  на  момент времени  или текущего значения  показателей         |
| Подтверждение происхождения данных | Требуется обязательная связь с регистрирующим документом                          | Связь не обязательна                                                                                  |

- 3 . Пример выбора типов объектов метаданных .

Пусть некоторая организация занимается периодическим анкетированием . При заполнении анкеты указывается дата анкетирования . В анкете указывается набор вопросов , результатом заполнения анкеты является набор ответов . Сущность «Анкета» привязана к дате , порождает статистику – ответы на вопросы .

## Таким образом , имеем:

- Периодическое событие , привязано к дате , порождает значение параметров . Это ­ второй блок «события предметной области» .
- Далее уточняем внутри блока «событий предметной области»: т . к . анкета формирует вторичные данные ­ результаты ответов на вопросы , то следовательно , это должен быть документ .

## Уточнение сущности объекта метаданных

- 1 . При описании структуры прикладного решения следует использовать разные типы объектов метаданных для реализации разных по смыслу сущностей . Например , сущность «организации» описывается справочником Организации , а сущность «подразделение» ­ отдельным справочником Подразделения .
- 2 . В то же время для уточнения сущности того или иного объекта , у объекта могут быть заведены реквизиты , в зависимости от значения которых меняется его смысловая нагрузка и поведение . Например , в справочнике Организации могут одновременно храниться «обычные» организации и обособленные подразделения (т . е . организации , у которых имеется головная организация) , а в справочнике Сотрудники – принятые на работу и уволенные сотрудники .

В этих случаях рекомендуется заводить отдельные реквизиты , которые бы однозначно определяли вид или состояние объекта . Это могут быть реквизиты типа Булево или перечисления с видами объекта . Не следует трактовать вид объекта по косвенным признакам , в частности в зависимости от заполнения того или иного реквизита .

## Например , неправильно

- заводить в справочнике Организации реквизит ГоловнаяОрганизация , в зависимости от заполнения которого прикладная логика трактует вид организации – «обычная» или обособленное подразделение;

## правильно:

- помимо реквизита ГоловнаяОрганизация , завести в справочнике Организации булев реквизит ОбособленноеПодразделение , в зависимости от значения которого (Истина или Ложь) однозначно трактуется вид организации , и в частности необходимость заполнения реквизита ГоловнаяОрганизация .
- 3 . В то же время , если например , у справочника Сотрудники имеются реквизиты ДатаПриема и ДатаУвольнения , то введение пары реквизитов булево типа ПринятНаРаботу и Уволен не оправдано . Для подобных сущностей с несколькими состояниями целесообразно завести один реквизит типа перечисление со статусами , например: «работает» , « уволен» , состав которых при необходимости может быть расширен и другими значениями .

## Имя , синоним , комментарий

- 1 . 1 . Синоним объекта должен быть определен так , чтобы осмысленно , лаконично описывать объект . Заполняется обязательно .

Данное требование продиктовано тем , что синонимы непосредственно участвуют в формировании пользовательского интерфейса (отображаются в формах , отчетах , командном интерфейсе и т . д . ) и поэтому должны корректно и одинаково во всех местах пользовательского интерфейса идентифицировать ту сущность , к которой они относятся . Помимо объектов метаданных , требование распостраняется также и на реквизиты объектов метаданных , табличные части , реквизиты табличных частей , измерения регистров , ресурсы и другие объекты конфигурации , у которых имеется синоним .

- 1 . 2 . Не рекомендуется в синонимах объектов использовать сокращения . Исключением являются только общеупотребительные и соответствующие целевой аудитории сокращения (например , Сумма (регл . ) ) и аббревиатуры (например , НДС или МСФО) .
- 1 . 3 . В синонимах объектов и текстовых сообщениях пользователю должны использоваться общепринятые термины , понятные пользователю . Не должно быть сленга , искажения названий продуктов и компаний; англоязычных фраз , записанных русскими буквами; русскоязычных английскими буквами и т . п .

В частности , если для англоязычного термина нет общепринятого перевода на русский язык , то следует использовать оригинальный англоязычный термин . Например , неправильно: «Загрузка данных из Эксель» , «Загрузка данных из MS Excel» ,

правильно: «Загрузка данных из Microsoft Excel» .

- 1 . 4 . В случае если у объекта метаданных имеются стандартные реквизиты (стандартные табличные части) , для них также следует указывать синонимы , исходя из прикладного смысла каждого реквизита .
- 1 . 5 . При этом для стандартных реквизитов Родитель и Владелец , следует всегда указывать синонимы , отличные от синонимов по умолчанию . Например , в конфигурации имеется справочник Файлы со стандартным реквизитом Владелец типа СправочникСсылка . ПапкиФайлов . В этом случае неправильно
- оставлять синоним стандартного реквизита Владелец по умолчанию: «Владелец»;

## правильно

- вложить в синоним прикладной смысл: «Папка» или «Папка с файлом» .

Другой пример . В то время как для стандартного реквизита Наименование некоторых справочников может вполне подойти синоним по умолчанию «Наименование» , в случае со справочником Файлы целесообразнее

назначить синоним «Имя файла» , а для справочника ФизическиеЛица – дать синоним «ФИО» .

См . также: Пользовательские представления объектов , Тексты

- 1 . 6 . В случае , когда есть два (или более) объекта метаданных со схожим назначением , необходимо , чтобы синонимы каждого объекта полностью описывали каждый объект .

Например , неправильно давать справочникам следующие синонимы:

- Банковские счета ,
- Банковские счета контрагентов

## правильно:

- Банковские счета организаций ,
- и Банковские счета контрагентов

Следует называть эти объекты явным образом , чтобы пользователь не задавался вопросом: «Если в справочнике Банковские счета контрагентов хранится информация о счетах контрагентов , то информация о чьих счетах хранится справочнике Банковские счета?»

Это требование справедливо и для синонимов подчиненных объектов метаданных (реквизитов , табличных частей , измерений , ресурсов и пр . ) . Пример с реквизитами табличной части «Товары» документа «Пересчет товаров» .

## Неправильно:

- Количество
- Количество (по учету)

## правильно:

- Количество (в наличии)
- Количество (по учету)

Пример со стандартным реквизитом Наименование и еще одним реквизитом справочника «Номенклатура» . Неправильно:

- Наименование
- Полное наименование

## правильно:

- Рабочее наименование
- Наименование для печати
- 2 . 1 . Имя объекта рекомендуется строить на основе синонима: пробелы и пр . недопустимые в имени символы , удаляются , а первые буквы слов делаются

прописными .

## Например , неправильно:

- у справочника НаборыДополнительныхРеквизитовИСведений задан синоним «Дополнительные свойства»
- у общей команды ПрисоединенныеФайлы – синоним «Файлы присоединенные»;

## правильно:

- у справочника НаборыДополнительныхРеквизитовИСведений задан синоним «Наборы дополнительных реквизитов и сведений»
- у общей команды ПрисоединенныеФайлы – синоним «Присоединенные файлы» .

Также допустимы ситуации , когда имя более кратко описывает объект , чем синоним – когда в имени «сокращены» одно или несколько последних «малозначащих» слов из синонима . Например:

- ДлительностьОжиданияСервера – синоним «Длительность ожидания сервера (сек)»
- КоличествоЕдиниц – синоним «Количество единиц измерения»
- Обработки . ГрупповоеИзменениеОбъектов . Операции . ИмяРеквизита
- – синоним «Имя реквизита (свойство)»

Имя также может не включать союзы и предлоги из текста синонима , например: для реквизита ЗначениеСкидкиНаценки синоним «Значение скидки или наценки» .

А также наоборот , допустимы ситуации , когда синоним более кратко описывает объект , чем имя – когда в синониме «сокращены» одно или несколько последних «технических» слов из имени .

Данное требование продиктовано тем соображением , что объекты конфигурации и их представления в пользовательском интерфейсе должны быть максимально легко узнаваемыми , например , на внедрении , которое проводится не самими разработчиками конфигурации , а силами технических специалистов по внедрению .

См . также: Дополнительные требования по именам объектов метаданных в конфигурациях

2 . 2 . Исключение из этого правила составляют объекты метаданных с префиксом Удалить .

Также не следует переименовывать объекты метаданных (их реквизиты , формы и пр . ) при пересмотре их синонимов , если на эти объекты распространяются требования обеспечения обратной совместимости . В частности , при разработке библиотек необходимо обеспечивать обратную совместимость между различными версиями библиотек в пределах одной редакции библиотеки .

- 2 . 3 . Имена объектов метаданных не должны превышать 80 символов .
- 2 . 4 . Для подчиненных объектов метаданных , таких как реквизиты , измерения , ресурсы рекомендуется не использовать имена , совпадающие с именами объектов ­ владельцев . Например , измерение Пользователь (типа СправочникСсылка . Пользователи) регистра сведений ИсполнителиЗадач названо некорректно; правильное название измерения , раскрывающее его смысл: Исполнитель .
- 2 . 5 . Также рекомендуется не использовать имена , которые применяются при именовании таблиц языка запросов (например , Документ , Справочник , РегистрСведений и т . д . ) . Такие имена могут приводить к ошибкам при исполнении запроса , затрудняют использование конструктора запроса и снижают наглядность текста запроса . Например , выполнение данного запроса вызывает ошибку:

ВЫБРАТЬ Сведения . Сведения ИЗ

РегистрСведений . Сведения КАК Сведения

- 3 . 1 . Комментарий задается только в тех случаях , когда необходимо дать участнику разработки конфигурации какие­либо пояснения по данному объекту конфигурации . Например , комментарий к реквизиту справочника может быть таким: " Индексирование поставлено для оптимизации отчетов с отбором по виду контрагента " , или: " Используется в регламентированном учете " .
- 3 . 2 . Комментарий начинается с прописной буквы , точки ставятся только после сокращений .
- 4 . В именах , синонимах и комментариях не допускается использовать букву " ё " .

## См . также

- Пользовательские представления объектов
- Подсказка и проверка заполнения
- Реквизит " Комментарий " у документов

## Подсказка и проверка заполнения

Область применения (уточнение): управляемое приложение , обычное приложение .

- 1 . 1 . Свойство «Подсказка» . Задается для тех объектов (реквизитов объектов , реквизитов табличных частей , измерений и ресурсов регистров) , которые выводятся пользователю в виде элементов интерфейса и которые требуют пояснения , расшифровки и донесения до пользователя подробного описания их назначения . Для реквизитов , используемых в ежедневной работе , подсказки добавлять не следует .

В тексте подсказки не рекомендуется приводить инструкции и объяснять работу реквизита , вместо этого следует оптимизировать сценарии работы , с ним связанные .

## См . также:

- Подсказки на форме , Подсказки для интерфейсных подсистем , Тексты
- методические рекомендации по составлению текстов подсказок с примерами в книге «Как создать удобное и понятное приложение в «1С:Предприятии 8 . 2» , глава «Интерфейсные тексты» .

При этом бессмысленные подсказки , автоматические генерируемые конфигуратором при создании элементов управления (групп) на формах , нужно не забывать очищать . Например , «Группа шапка» и пр .

- 2 . 1 . Свойство «Проверка заполнения» . Для всех типизированных объектов метаданных , а также для стандартных реквизитов и табличных частей , которые в соответствии с логикой объекта являются обязательными к заполнению , свойство " Проверка заполнения " должно быть установлено в " Выдавать ошибку " .

В ряде случаев проведение документа с незаполненными реквизитами и табличными частями не имеет смысла с точки зрения отражения документа в учете . Например , документ Заказ клиента является запросом клиента на поставку определенного количества товара . Из определения понятно , что методически заказ с незаполненным клиентом и незаполненной табличной частью Товары не имеет смысла , поэтому у реквизита Клиент и табличной части Товары свойство " Проверка заполнения " должно быть установлено в " Выдавать ошибку " .

- 2 . 2 . При установке свойства «Проверка заполнения» следует исходить из того , что все ограничения и проверки должны быть (насколько это возможно полно) описаны в метаданных конфигурации . Поэтому если хотя бы один из сценариев работы с объектом требует обязательного заполнения реквизита ,

то свойство «Проверка заполнения» устанавливается в «Выдавать ошибку» . Если в других сценариях работы заполнять реквизит не обязательно , то такие случаи должны быть предусмотрены в обработчике события модуля объекта ОбработкаПроверкиЗаполнения .

При этом не следует придерживаться обратной схемы , когда свойство «Проверка заполнения» установлено в «Не проверять» , а в обработчике ОбработкаПроверкиЗаполнения дописаны какие­либо проверки заполнения . Такая схема затрудняет анализ логики работы конфигурации .

- 2 . 3 . Если проверка заполнения реквизита зависит от тех или иных условий , рекомендуется управлять автопометкой незаполненного значения с помощью условного оформления форм объектов . Убирать ее в случае , если при данном состоянии объекта заполнение реквизита проверять не требуется .

## См . также

- Имя , синоним , комментарий

## Длина кода (номера) объектов конфигурации

Методическая рекомендация (полезный совет)

Длины кодов (номеров) объектов конфигурации задаются в зависимости от их прикладного смысла .

- 1 . Если код используется как краткое представление элемента данных в виде строки , то автонумерация не используется .
- Пример ­ использование кода справочника Пользователи для хранения краткого имени пользователя . В этом случае длина устанавливается достаточной для хранения краткого строкового представления объектов исходя из прикладного смысла кода .
- 2 . Код (номер) используется для идентификации объекта числом , возможно со строковым префиксом числа . В этом случае длина кода (номера) выбирается , исходя из потенциального количества всех объектов , хранимых в базе данных; объектов , относящихся к определенному периоду (для документов и бизнес­процессов); или объектов , относящихся к определенному владельцу (иерархические и подчиненные справочники , задачи) . При этом в длине номера необходимо учитывать длину префиксов нумерации , например , префикс информационной базы , префикс организации , если это предусмотрено конфигурацией и т . п .

При разработке типовых конфигураций рекомендуемыми , но не обязательными к применению являются длины кодов (номеров) из следующего ряда:

- 3 , 5 , 9 , 11 . При этом в длине номера необходимо учитывать длину префиксов нумерации , например , префикс информационной базы , префикс организации , если это предусмотрено конфигурацией и т . п .

Если в конфигурации используется подсистема Префиксация объектов из Библиотеки стандартных подсистем , то совокупную длину (с учетом префикса) номеров документов и кодов справочников рекомендуется устанавливать не менее 11 символов (11 , 13 , 15 , … ) . Подробнее см . документацию к подсистеме " Префиксация объектов " на ИТС .

- 3 . Если необходимость в кодировании (нумерации) для объекта отсутствует , то длина кода (номера) устанавливается нулевой .

Рекомендуется устанавливать допустимую длину кода (номера) объектов переменной .

## Использование реквизитов строкового типа

- 1 . 1 . Для реквизитов строкового типа следует использовать переменную длину строки (свойство Допустимая длина = Переменная) и при этом указывать максимально допустимую длину строки . Свойство Допустимая длина может принимать значение Фиксированная только в тех случаях , когда при манипуляции этими данными действительно необходимо иметь гарантию , что строка имеет определенную длину (за счет автоматического дополнения концевыми пробелами) .
- 1 . 2 В тех случаях , когда максимальная длина строки заранее известна (например , она регламентирована) , следует указывать ее в свойстве Длина (или Длина наименования для стандартного реквизита Наименование) . Например , длина строкового реквизита ИНН справочника ФизическиеЛица должна составлять 12 символов .
- 1 . 3 . Если строка является конкатенацией других строк , то ее длина может быть определена как сумма длин исходных строк . Например , длина представления адреса должно равняться сумме длин полей , в которых хранятся части адреса .
- 1 . 4 Если длина строки не регламентирована , то рекомендуется выбирать такую длину , которой достаточно для хранения данных в большинстве случаев . Например , для хранения полного наименования контрагента в подавляющем большинстве случаев достаточно 250 символов , максимальная длина имени файла в большинстве файловых систем – 260 , полное имя физического лица – 100 и т . п .
- 2 . В отдельных случаях , допускается использование строк неограниченной длины:
- 2 . 1 . Предполагается , что в реквизит строкового типа может быть помещен пользовательский текст , объем которого может быть значительным . Как правило , это многострочные поля на форме . Например , в поле Дополнительное описание в заказе клиента менеджер может поместить всю историю переписки с клиентом , в поле Комментарий – пользователь может ввести произвольный многострочный текст и т . п .
- 2 . 2 . В строковом реквизите хранится различная техническая информация , которая генерируется программами и , чаще всего , не предназначена для чтения пользователем , а используется в различных алгоритмах обработки информации . Например , xml ­ документы , заголовки почтовых сообщений и т . п .
- 3 . В случае использования строковых реквизитов неограниченной длины следует иметь в виду возникающие при этом ограничения в языке запросов:
- 3 . 1 При необходимости сравнения значений , группировки и получения различных , такие реквизиты необходимо выражать как строку определенной

длины

,

такой

,

чтобы выражение было вычислено верно

.

Для этих целей в запросе рекомендуется использовать конструкцию

## ВЫРАЗИТЬ КАК СТРОКА(1000)

- 3 . 2 . В отчетах СКД для таких полей следует , вместо этого , задавать параметр Тип значения поля (на закладке Наборы данных) .

Следует иметь в виду , что частое приведение неограниченной строки к определенной длине в запросах и отчетах СКД может быть признаком неправильного проектного решения и служить сигналом для пересмотра типа строковго реквизита в пользу ограниченной длины строки .

- 3 . 3 . В остальных случаях , урезать строку в запросах не требуется .
- 4 . 1 . Если в печатных формах предусмотрено отображение строкового поля , то независимо от того , какая назначена длина строки , необходимо обеспечить вывод таких строк полностью , без обрезания части строки . В противном случае , может быть утеряна значимая часть информации . Например , номер дома и квартиры в поле с адресом доставки товара в печатной форме .

Для быстрого выявления в конфигурации всех строковых реквизитов неограниченной длины можно воспользоваться приложенной обработкой СтрокиНеограниченнойДлины . erf

## См . также

- Формирование печатных форм

## Ограничения на использование реквизитов составного типа

Методическая рекомендация (полезный совет)

- 1 . 1 . Реквизиты составного типа , используемые в условиях соединений , отборах , а также для упорядочивания , должны содержать только ссылочные типы (СправочникСсылка . [ … ] ,
- ДокументСсылка . [ … ] и пр . ) . В состав их типов не рекомендуется включать никаких других нессылочных типов , например: Строка , Число , Дата ,

УникальныйИдентификатор , Булево , а также ХранилищеЗначения .

В противном случае производительность запросов заметно снизится . Это обусловлено особенностями физического хранения реквизитов составных типов в колонках таблиц СУБД . См . Особенности хранения составных типов данных (статья на ИТС) .

- 1 . 2 . В отдельных случаях , для выполнения этой рекомендации можно применить следующий подход .

Например , в документе определен реквизит Адрес составного типа , который включает ссылку на справочник Контакты и «строку» для возможности ввода в реквизит произвольных строковых значений . Вместо этого , следует предусмотреть отдельный справочник ПроизвольныеАдреса и указать его в реквизите Адрес вместо строки . При этом добавление новых элементов в справочник ПроизвольныеАдреса следует обеспечить автоматически , «незаметно» от пользователя , в момент записи документа . А удаление ненужных элементов справочника ПроизвольныеАдреса можно организовать посредством регламентного задания .

- 2 . 1 . Для типизированных объектов метаданных , хранящихся в информационной базе , не следует использовать составные типы ЛюбаяСсылка , СправочникСсылка , ДокументСсылка и аналогичные . Состав типов того или иного типизированного объекта должен определяться явным образом .

Исключение составляют универсальные механизмы (алгоритмы) , рассчитанные на работу с произвольными ссылочными объектами .

приложение

.

- 2 . 2 . В случае если составной тип массово используется в объектах какойлибо подсистемы или во всей конфигурации , то рекомендуется использовать определяемые типы .

## См . также:

- Разыменование ссылочных полей составного типа в языке запросов

## Требования к проведению документов

- 1 . Документы предназначены для ввода первичной информации , связанной с регистрацией событий , воздействующих на учитываемые в системе показатели . Например , при автоматизации финансово­хозяйственной деятельности предприятия – это учет различных хозяйственных операций; в системах управления производственными процессами – регистрация производственных операций и т . д .
- 2 . 1 . Регистрация события в системе (т . е . отражение его в учете) выполняется с помощью проведения документа . Большинство документов должны проводиться (свойство Проведение установлено в значение Разрешить) .

Логически , непроведенный документ отличается от проведенного тем , что непроведенный документ является «черновиком» , не отраженным в учете . Такие документы могут быть сохранены в системе , даже если они не полностью или вообще не заполнены; к ним не применяются никакие проверки и ограничения бизнес­логики (проверки заполнения , дат запрета изменения и т . п . ) . Данные таких документов не отражаются в учете (не выводятся в отчетах и т . п . )

В то же время , проведенный документ – это «чистовик» , формирование и обработка которого завершены и по поводу которого принято решение , что данный документ должен участвовать в учете .

- 2 . 2 . Если жизненный цикл документа состоит из нескольких этапов , которые соответствуют этапам некоторого процесса , то для описания этих этапов у документа могут быть введены дополнительные статусы . Например , документ «Заказ клиента» может иметь статусы: «не согласован» , «к обеспечению» , «закрыт»; документ «Расходный кассовый ордер» – сначала зарегистрирован в журнале регистрации кассовых ордеров (КО­3) , затем подписан главным бухгалтером (руководителем) , передан в кассу , затем зарегистрирован в Кассовой книге , подписан главным бухгалтером (руководителем) .

В таких случаях , проведение документа соответствует моменту первичного отражения события в учете , а статусы проведенного документа уточняют , как именно событие отражено в учете .

Если документ проведен , то при переводе документа между статусами пользователям может быть предложено дозаполнить определенные данные документа , к этим данным могут быть применены определенные проверки и ограничения бизнес­логики , специфичные для каждого этапа . До момента проведения , перевод «черновика» документа по статусам не контролируется системой .

Примеры поведения документов с многоэтапным отражением в учете:

- для проведенного документа «Заказ клиента»:
- при переводе в статус «не согласован» система контролирует только основные параметры заказа;
- при переводе в статус «к обеспечению» – обязательно для заполнения поле «дата отгрузки» , так как логисту необходима информация , к какой дате нужно привезти заказ;
- для проведенного документа «Расходный кассовый ордер» перевод в финальный статус «зарегистрирован в Кассовой книге и подписан главным бухгалтером (руководителем)» означает , что система должна создать бухгалтерские записи , а отчет кассира будет зарегистрирован в журнале ­ ордере (или другом регистре учета , например , в бюджетных организациях ­ в журнале операций) .
- 2 . 3 . Исключение из этого правила («большинство документов должны проводиться») составляют
- документы , которые не предназначены для отражения событий в учете . С помощью таких документов только регистрируют различные события с привязкой ко времени: например , входящую корреспонденцию , звонки , встречи и т . п .
- отдельные документы , технология проведения которых сильно отличается от технологических возможностей платформы , но которые должны выглядеть для пользователя так , как будто они проводятся . Например , это документы «Операция (бухгалтерский и налоговый учет)» – для ввода операций вручную , «Регламентная операция» – для выполнения операции закрытия месяца с возможностью ручной корректировки движений и т . п .

Такие документы не проводятся .

- 2 . 4 . В случае если пользователь должен выполнять регистрацию события в системе и отражение его в учете за одно действие , необходимо записывать новый документ в режиме проведения .

При этом недопустимо решать эту задачу другими способами , в частности , с помощью отключения проведения у документа .

- 3 . 1 При отражении события в учете может возникнуть необходимость сформировать «вторичные» данные , со сложными привязками к моментам времени , периодам и к другим объектам системы . В этом случае следует помещать такие данные в регистры . Формирование движений по регистрам следует выполнять при проведении: автоматически или вручную .

При автоматическом формировании движений , пользователь вводит информацию о событии в данные документа , а при проведении на основе введенной в документ информации генерируются движения в различные регистры . Например , для бухгалтерских операций происходит формирование проводок .

При ручном формировании движений , пользователь вводит данные непосредственно в регистры . Такие документы обычно называются ручными операциями . Они могут использоваться для введения начальных остатков , или

- для ввода хозяйственных операций , которые не были предусмотрены разработчиком конфигурации .
- 3 . 2 . В отдельных случаях , формирование движений может выполняться отдельным документом . Это востребовано в случае схожей обработки разных видов документов , групповой обработки или реализации сложных бизнеспроцессов , требующих явного разделения функций исполнителей . Тогда разные стадии отражения событий в учете реализуются не переходом по статусам у одного документа , а разными документами , которые вводятся на основании друг друга . В этой цепочке только определенные документы при проведении формируют движения .

Например , рассмотрим ситуацию , когда платежное поручение формируется в финансовом отделе , и при этом бухгалтер при проведении не должен изменять первичный документ . В этом случае , документ «Платежное поручение» не делает движений , а движения по платежному поручению формируются отдельным документом «Списание с расчетного счета» , который специально предназначен для автоматизированного формирования движений .

- 3 . 3 . Непроведенные и помеченные на удаление документы не должны иметь активных движений .
- 3 . 4 . Даже если документ не формирует движений , он должен проводиться , чтобы логически отличаться от «черновика» .
- 4 . Для большинства событий отражение в учете может быть обратимым . В таком случае , для этого следует использовать механизм отмены проведения документов .

## См . также

- Имена объектов метаданных в конфигурациях
- Порядок записи движений документов
- Самодостаточность регистров

## Использование активности движений

В случае если в конфигурации применяются механизмы , использующие переключение активности движений определенных регистров (например , для ручной корректировки движений) , то следует придерживаться следующего подхода .

- 1 . Активность записей таких регистров должна учитываться во всех запросах и отчетах к ним . Для игнорирования неактивных записей условие выборки из регистра должно содержать дополнительное условие вида:

## ГДЕ Активность = ИСТИНА

Если в запросе выбираются записи из виртуальных таблиц , связанных с регистрами , то это условие автоматически учитывается платформой 1С:Предприятие (виртуальные таблицы регистров содержат только активные записи) .

- 2 . В частности , активность записей регистров должна учитываться в универсальных отчетах (или в любой универсальной бизнес­логике) , которые поддерживают работу с произвольными регистрами конфигурации . Среди таких регистров могут оказаться и те , где используется переключение активности движений .
- 3 . При отмене проведения документов , которые позволяют напрямую редактировать движения в своих регистрах (т . н . ручная корректировка движений) , следует отключать активность движений , а не удалять их . Пример такого документа: «Операция (бухгалтерский и налоговый учет)» , в котором имеется возможность «ручного» ввода операций .

## См . также

- Требования к проведению документов
- Порядок записи движений документов

## Самодостаточность регистров

При разработке структуры регистров необходимо придерживаться правила , что регистр должен быть логически независим от регистраторов . Любая логика , опирающаяся или анализирующая данные регистра , а также любые отчеты по этому регистру не должны обращаться к полям регистратора , им должно быть достаточно данных самого регистра .

Обращение к полям регистратора " через точку " приводит к неявному соединению с дополнительными таблицами . Кроме того , в распределенной информационной базе регистратора может и не быть , если движения в регистрах мигрируют между узлами , а регистраторы ­ нет .

## См . также

- Разыменование ссылочных полей составного типа в языке запросов
- Разработка планов обмена с отборами

## Реквизит «Комментарий» у документов

Методическая рекомендация (полезный совет)

- 1 . Для всех документов рекомендуется создавать реквизит Комментарий (строка неограниченной длины) . В этом реквизите пользователи могут записывать по документу различные заметки служебного характера , которые не относятся к прикладной специфике документа (например , причина пометки на удаления и т . п . ) . Доступ к реквизиту для пользователей должен быть настроен также как и к самому документу (если документ доступен только для чтения , то и комментарий – только для чтения; если же есть право записи документа , то и значение реквизита также можно изменять) .
- 2 . Если же штатный сценарий работы пользователя предусматривает внесение произвольной текстовой информации в документ , то для этого необходимо предусмотреть отдельные реквизиты «прикладного» характера . Например , в документе Заказ клиента для описания дополнительных договоренностей с клиентом следует предусмотреть реквизит Дополнительная информация , а не пользоваться служебным реквизитом Комментарий .
- 3 . В простейшем случае , в качестве внешнего редактора текста комментария рекомендуется использовать функцию ВвестиСтроку . При использовании в конфигурации Библиотеки стандартных подсистем можно воспользоваться специализированной процедурой

ОткрытьФормуРедактированияКомментария общего модуля ОбщегоНазначенияКлиент .

## См . также

- Поля " Ответственный " и " Комментарий " (8 . 2)
- Поля " Ответственный " и " Комментарий " (8 . 3)

## Поставка данных в составе конфигурации

Для поставки в составе конфигурации тех или иных данных (например , данных , предназначенных для заполнения справочников , настроек отчетов , правил обмена данными и т . п . ) рекомендуется использовать форматы , предназначенные для передачи данных (например , формат xml) и применять для этого макеты вида " Текстовый документ " или " Двоичные данные " .

Не следует использовать для целей поставки данных в составе конфигурации макеты вида " Табличный документ " .

Для быстрой конвертации табличных макетов в формат xml можно воспользоваться приложенной обработкой КонвертацияТабличногоМакетаВXML . epf .

## См . также

- Макеты: требования по локализации

## Удаление устаревших объектов метаданных из конфигурации

- 1 . Если при изменении структуры метаданных конфигурации планируется удалить объект метаданных (реквизит , измерение , ресурс и пр . ) , связанный с записями информационной базы , то необходимо принять решение об удалении или переносе данных этого объекта в новые структуры . При переносе данных в другие объекты рекомендуется придерживаться следующих правил .
- 1 . 1 . Не удалять из конфигурации устаревшие объекты метаданных и реквизиты безвозвратно , а пометить их как устаревшие , добавив к их именам префикс " Удалить " . Например: реквизит " ОсновнойДоговор " должен быть переименован в «УдалитьОсновнойДоговор» .

В синоним устаревшего объекта (реквизита) рекомендуется добавлять префикс " (не используется) " , например: " (не используется) Основной договор " . Если же устарел стандартный реквизит , то префикс " (не используется) " также добавляется в его синоним .

- 1 . 2 . После изменения структуры метаданных следует обеспечить перенос данных из устаревших реквизитов в новую структуру метаданных конфигурации .
- 1 . 3 . Если удаляемый объект метаданных является документом – регистратором движений , а соответствующие регистры с движениями остаются в составе конфигурации , то необходимо обратить внимание на необходимость сохранения движений . Для сохранения движений документов – устаревших объектов метаданных , рекомендуется:
- Запретить генерацию движений при проведении документов этого вида .
- Запретить снятие пометки удаления для документов этого вида .
- Во всех существующих движениях документов этого вида изменить регистратор на один или несколько замещающих документов -регистраторов: существующих универсальных или специально разработанных . Например " Перенос данных " , " Операция " .
- Пометить все документы этого вида на удаление .
- 1 . 4 . Произвести замену во всей конфигурации обращений к устаревшим реквизитам на обращение к новым данным , поскольку использование устаревших объектов и их реквизитов после изменения структуры метаданных методически неверно
- 1 . 5 . При сортировке устаревших объектов метаданных и реквизитов в дереве метаданных следует придерживаться общих требований к конфигурации .
- 1 . 6 . Также рекомендуется выполнить очистку устаревших данных с тем , чтобы они не влияли на размер базы и не потребляли ресурсы (при резервном копировании , реструктуризации и других операциях) .

В случае сложных (ошибкоемких) алгоритмов переноса данных , такую очистку целесообразно проводить не сразу , а через один или несколько релизов . Тем самым , остается возможность выпуска внепланового релиза для устранения последствий некорректной работы алгоритмов переноса .

- 2 . Необходимость в переносе данных также может возникнуть при пересмотре структуры измерений регистров . Следует создать новый регистр с правильной структурой , а старый отметить как устаревший и перенести записи из старого регистра в новый в тех случаях , когда измерение регистра сведений становится не актуальным: удаляется , либо изменяется его тип , либо у измерения составного типа уменьшается состав типов .
- При этом создать новый регистр не требуется , если в регистр добавляется новое измерение или у измерения составного типа расширяется состав типов .
- 3 . Безвозвратно удалять устаревшие объекты метаданных и реквизиты , помеченные префиксом " Удалить " , следует при выпуске очередных версий конфигурации в том случае , если соблюдается одно из условий:
- 1 . Переход со " старой " версии конфигурации на новые версии всегда выполняется пользователями последовательно , " через " версию с реализованным переносом данных из " устаревших " объектов метаданных и реквизитов . Например: если в конфигурации версии 1 . 1 реквизит " ОсновнойДоговор " был помечен как устаревший , то переход с версии 1 . 0 на версию 2 . 0 всегда выполняется только последовательно: сначала на версию 1 . 1 (в которой происходит обработка устаревших данных) , а затем на 2 . 0 (в которой устаревшие данные могут быть удалены безвозвратно) . Непосредственный переход с версии 1 . 0 на 2 . 0 технически невозможен (запрещен) .
- 2 . Вероятность того , что " старой " версией конфигурации еще пользуются , стала нулевой или пренебрежимо малой .

При этом может потребоваться выпустить промежуточный релиз , в котором обеспечить очистку устаревших данных ­ см . п . 1 . 6 . В противном случае , может завершиться ошибкой реструктуризация регистров , в измерениях которых остаются ссылки на устаревшие данные .

## Использование констант

Следует выполнять запись константы вне транзакций , т . к . ее запись может стать «узким» местом при конкурентой работе . Например , неправильно:

```
// Увеличиваем счетчик проведенных документов в константе Процедура ОбработкаПроведения(Отказ , РежимПроведения) ТекущееЗначение = Константы . СчетчикПроведенныхДокументов . Получить(); Константы . СчетчикПроведенныхДокументов . Установить(ТекущееЗначение + 1); КонецПроцедуры
```

На время записи значения в константу , работа других сеансов приостанавливается , если в это же время они выполняют запись этой же константы . Подробнее о причинах избыточных блокировок и методах оптимизации см . базу знаний «Технологические вопросы крупных внедрений» .

Вместе с тем , недопустимо решать проблему блокировок констант другими методами , в частности , тотальным кешированием констант в параметрах сеанса или в функциях общих модулей с повторным использованием возвращаемых значений .

## Работа с неактуальными (недействительными) объектами

Методическая рекомендация (полезный совет)

- 1 . Данная рекомендация действует для ситуаций , когда какой­либо объект информационной базы перестает быть актуальным – навсегда или на время (сотрудник увольняется или уходит в декретный отпуск , подразделение расформируется и т . д . ) . При этом удалять этот объект из базы недопустимо , чтобы не нарушать ссылочную целостность: на него должны ссылаться другие ранее созданные объекты . Например , объект типа Файл должен содержать в поле Автор ссылку на уволившегося сотрудника и после его увольнения .
- 2 . Для запрета выбора неактуальных объектов с помощью автоподбора и быстрого выбора в полях ввода следует выбрать один из двух подходов к реализации (2 . 1 или 2 . 2) . Проиллюстрируем их далее на примере пользователей информационной системы , учет которых ведется в справочнике Пользователи .

Для учета неактуальных пользователей у справочника Пользователи добавлен реквизит Недействителен (Булево) , по умолчанию Ложь .

- 2 . 1 . Если запрет должен действовать во всех или в большинстве полей ввода форм системы , то он задается по умолчанию .
- 2 . 1 . 1 . В модуле менеджера справочника Пользователи реализуются обработчики

ОбработкаПолученияДанныхВыбора и ОбработкаПолученияФормы для установки параметров отбора . Пример реализации этих обработчиков для справочника Пользователи:

```
Процедура ОбработкаПолученияДанныхВыбора(ДанныеВыбора , Параметры , СтандартнаяОбработка) Если Не Параметры . Отбор . Свойство( " Недействителен " ) Тогда Параметры . Отбор . Вставить( " Недействителен " , Ложь); КонецЕсли; КонецПроцедуры Процедура ОбработкаПолученияФормы(ВидФормы , Параметры , ВыбраннаяФорма , ДополнительнаяИнформация , СтандартнаяОбработка) Если ВидФормы = " ФормаВыбора " Тогда ПараметрИзменен = Ложь; Если Не Параметры . Свойство( " Отбор " ) Тогда Параметры . Вставить( " Отбор " , Новый Структура( " Недействителен " , Ложь)); ПараметрИзменен = Истина; ИначеЕсли Не Параметры . Отбор . Свойство( " Недействителен " ) Тогда Параметры . Отбор . Вставить( " Недействителен " , Ложь); ПараметрИзменен = Истина; КонецЕсли; // Этот код нужен , чтобы были использованы измененные нами значения параметров Если ПараметрИзменен Тогда СтандартнаяОбработка = Ложь; ВыбраннаяФорма = " ФормаВыбора " ; // передаем имя формы выбора КонецЕсли; КонецЕсли; КонецПроцедуры
```

- 2 . 1 . 2 . Для тех реквизитов , где это поведение нужно изменить (например , нужно выводить всех пользователей или должно работать другое ограничение) следует явно установить свойства «Параметры выбора» и «Связи параметров выбора» с необходимыми в конкретном контексте значениями выбора:
- если требуется выбирать недействующих пользователей , указываем в свойстве реквизита «Параметры выбора» значение Отбор . Недействителен(Ложь) ,
- а если не требуется ограничивать выбор вообще , то оба значения ­ Истина и Ложь .
- 2 . 2 . Если запрет на выбор неактуальных объектов сильно зависит от контекста (сценариев работы) , то не следует его устанавливать по умолчанию .
- Модуль менеджера справочника Пользователи не реализуется .
- В простейшем случае , во всех объектах , в которых есть реквизиты типа СправочникСсылка . Пользователи устанавливаются значения свойств «Параметры выбора» и «Связи параметров выбора» , как описано выше в пункте 2 . 1 . 2 .
- В тех случаях , когда критерий ограничения не может быть описан параметрами выбора , то реализуются обработчики формы ОбработкаПолученияДанныхВыбора , ОбработкаВыбора и ОкончаниеВводаТекста , а также разрабатывается отдельная форма выбора , в которой реализуется та же логика ограничения .
- 3 . В формах списка и выбора пользователей рекомендуется добавить флажок «Показывать недействительных пользователей» . С его помощью возможно выбрать или открыть карточку пользователя , а также снова сделать пользователя действительным (например сотрудницу , вернувшуюся из декретного отпуска) .
- 4 . Для отображения неактуальных объектов в списках рекомендуется использовать элемент стиля ТекстЗапрещеннойЯчейкиЦвет (192 , 192 , 192) .

<!-- image -->

## Использование предопределенных элементов

Действует для версии платформы 1С:Предприятие 8 . 3 . 3 и выше без режима совместимости с версией 8 . 2

- 1 . 1 . В справочниках , планах счетов , планах видов характеристик и планах видов расчета имеется возможность создавать предопределенные элементы автоматически или программно .
- 1 . 2 . В большинстве случаев , предопределенные элементы рекомендуется создавать автоматически , поскольку они постоянно нужны и требуется упростить обращение к этим элементам из кода . Например , предопределенная страна Россия в справочнике Страны мира , предопределенные профиль групп доступа Администратор и т . п .

## Для этого

- в свойстве ОбновлениеПредопределенныхДанных справочника , плана счетов , плана видов характеристик или плана видов расчета должно быть установлено значение Авто (по умолчанию) , а также не следует допускать программных вызовов метода УстановитьОбновлениеПредопределенныхДанных этих объектов для переключения этого режима .
- запретить удаление предопределенных элементов пользователями , выключив во всех ролях следующие права (по умолчанию выключены):
- ИнтерактивноеУдалениеПредопределенныхДанных
- ИнтерактивнаяПометкаУдаленияПредопределенныхДанных
- ИнтерактивноеСнятиеПометкиУдаленияПредопределенныхДанных
- ИнтерактивноеУдалениеПомеченныхПредопределенныхДанных

<!-- image -->

1

.

4

.

Для таблиц с предопределенными элементами

ссылаются другие таблицы

,

входящие в состав

,

которые не входят в состав

плана обмена РИБ) свойство

ОбновлениеПредопределенныхДанных необходимо устанавливать в значение ОбновлятьАвтоматически

которые не

.

Значение Авто в этом случае не подходит , так как для подчиненного узла Авто означает НеОбновлятьАвтоматически , то есть предопределенные элементы таблицы автоматически созданы не будут .

При включенном режиме совместимости с версией 8 . 3 . 3 также необходимо при первом запуске подчиненного узла РИБ (сразу после того , как была обновлена его конфигурация) устанавливать автоматическое обновление в данных с помощью вызова:

## Справочники .

&lt;ИмяСправочника&gt;

.

УстановитьОбновлениеПредопределенныхДанных(ОбновлениеПредопределенныхДанных

.

ОбновлятьАвтоматически);

- 2 . В некоторых случаях , предопределенные элементы не требуется создавать автоматически , если их наличие зависит от какого­либо условия: включенной функциональной опции , режима работы программы и т . п .

Например , те или иные предопределенные виды расчетов в плане видов расчета Начисления зависят от значений функциональных опций ИспользоватьУчетВремениСотрудниковВЧасах , ИспользоватьСдельныйЗаработок и др .

Для этого

плана обмена РИБ (и

на

<!-- image -->

## См . также

- Получение предопределенных значений на клиенте

## Обработчик события ПередЗаписью

- 1 . В данном обработчике модуля объекта , как правило , должны выполняться действия , связанные с заполнением значений реквизитов объекта (набора записей , значения константы; далее упрощенно ­ " объект " ) , проверки правильности их заполнения , связанности состояния объекта с некоторыми внешними данными . Также в данном обработчике следует выполнять действия , связанные с обращением к " старым " значениям реквизитов объекта , сохраненным в базу данных (имеет смысл при редактировании уже записанных ранее объектов , наборов записей и т . п . ) .

См . также раздел «Проверки, и, выполняемые в и вне транзакции записи объекта» статьи «Обработчик события ОбработкаПроверкиЗаполнения»

- 2 . Содержимое процедуры­обработчика события ПередЗаписью условно должно разделяться на две части:
- действия выполняемые при каждой записи объекта (в том числе и когда объект записывается механизмом обмена данными) ,
- и действия , которые не должны выполняться в случае записи объекта механизмом обмена .

```
Процедура ПередЗаписью(Отказ) // действия , которые должны выполняться всегда, в том числе и при обмене данных // . . . Если ОбменДанными . Загрузка Тогда Возврат; КонецЕсли; // действия , выполняемые в случае, если запись инициирована не механизмом обмена данными // . . . КонецПроцедуры
```

В большинстве случаев , все действия выполняемые в обработчике ПередЗаписью должны располагаться в модуле после конструкции

```
Если ОбменДанными . Загрузка Тогда Возврат; КонецЕсли;
```

То есть они не должны выполняться при записи объекта через механизм обмена данными , поскольку они уже были выполнены для объекта в том узле , где он был создан . В случае исключений , причина исключения из этого правила должна быть описана в комментарии к выполняемым действиям .

## Обработчик события ПриЗаписи

В данном обработчике модуля объекта (набора записей , значения константы; далее ­ " объект " ) , как правило , выполняются действия по записи связанной с объектом данных в других объектах конфигурации , а также выполняются другие действия , связанные с изменением объекта .

Запрещается в данном обработчике изменять содержимое записываемого объекта , поскольку на момент выполнения обработчика , объект уже записан в БД .

Для обработчика события ПриЗаписи действуют те же требования в отношении разделения действий выполняемых при записи объекта механизмом обмена данными , что и для события ПередЗаписью .

## См . также

- Раздел «Проверки , выполняемые в и вне транзакции записи объекта» статьи «Обработчик события ОбработкаПроверкиЗаполнения»

## Обработчик события ПередУдалением

- 1 . В данном обработчике модуля объекта , как правило , должны выполняться действия , которые необходимо выполнить перед удалением объекта . Например , перед удалением присоединенного файла может потребоваться произвести очистку ссылок на этот файл в объекте­владельце .
- 2 . Содержимое процедуры­обработчика события ПередУдалением условно должно разделяться на две части:
- действия выполняемые перед каждым удалением объекта (в том числе и когда объект удаляется механизмом обмена данными) ,
- и действия , которые не должны выполняться перед удалением объекта механизмом обмена .

```
Процедура ПередУдалением(Отказ) // действия , которые должны выполняться всегда, в том числе и при обмене данных // . . . Если ОбменДанными . Загрузка Тогда Возврат; КонецЕсли; // действия , выполняемые в случае, если событие перед удалением инициировано не механизмом обмена данными // . . . КонецПроцедуры
```

В большинстве случаев , все действия выполняемые в обработчике ПередУдалением должны располагаться в модуле после конструкции

```
Если ОбменДанными . Загрузка Тогда Возврат; КонецЕсли;
```

Т . е . они не должны выполняться перед удалением объекта через механизм обмена данными , так как это может привести к ошибкам . Примером таких ошибок является обращение к предопределенным объектам после очистки области данных . В случае исключений , причина исключения из этого правила должна быть описана в комментарии к выполняемым действиям .

## Обработчик события ПриКопировании

В данном обработчике модуля объекта выполняются действия , связанные с созданием нового объекта путем копирования .

В частности , в данном обработчике выполняются действия по очистке содержимого реквизитов объекта в случаях , когда значения этих реквизитов не должны сохраняться при копировании .

## Обработчик события ОбработкаПроверкиЗаполнения

- 1 . 1 . В данном обработчике модуля объекта выполняются действия , связанные с проверкой правильности заполнения значений реквизитов объектов (измерений , ресурсов , реквизитов табличных частей и т . п . , далее: просто " реквизиты " ) .

См . также Подсказка и проверка заполнения

- 1 . 2 . Данным обработчиком следует пользоваться в случаях , когда для проверки корректности значений реквизитов обычной проверки на заполненность уже недостаточно (например , значение реквизита логически связано со значением другого реквизита) , или же требование к тому , чтобы значение реквизита было заполнено не является безусловным .

Если проверка заполнения какого ­ либо реквизита ­ условная (т . е . зависит от значений других реквизитов или значения параметризированной функциональной опции) в обработчике следует предусмотреть код , который удаляет имя такого реквизита из массива проверяемых реквизитов ПроверяемыеРеквизиты . В общем виде , схема проверки заполнения выглядит следующим образом:

- создать МассивНепроверяемыхРеквизитов;
- в процессе проверки условий , добавлять в этот массив имена непроверяемых реквизитов (табличных частей);
- вызвать процедуру для удаления непроверяемых реквизитов (текст процедуры УдалитьНепроверяемыеРеквизитыИзМассива приведен ниже) .

При этом не рекомендуется использовать другие схемы проверки заполнения значений реквизитов , так как они затрудняют анализ логики работы конфигурации , поскольку скрывают из свойства " Проверка заполнения " случаи условной проверки заполнения значений объектов . Например , неправильно:

```
Процедура ОбработкаПроверкиЗаполнения(Отказ , ПроверяемыеРеквизиты) . . . // Проверка значения реквизита на соответствие некоторым требованиям Если НЕ ИННСоответствуетТребованиям(ИНН) Тогда Сообщение = Новый СообщениеПользователю(); Сообщение . Текст = НСтр( " ru = ' ИНН задан неверно . ' " ); Сообщение . Поле = " ИНН " ; Сообщение . УстановитьДанные(ЭтотОбъект); Сообщение . Сообщить(); Отказ = Истина; КонецЕсли;
```

.

.

.

```
// Значение реквизита не должно быть пустым в зависимости от значения другого реквизита Если ЮрФизЛицо = Перечисления . ЮрФизЛицо . ФизЛицо Тогда // Для индивидуального предпринимателя должно быть сопоставлено физ . лицо ПроверяемыеРеквизиты . Добавить( " ИндивидуальныйПредприниматель " ); КонецЕсли; . . . КонецПроцедуры правильно: Процедура ОбработкаПроверкиЗаполнения(Отказ , ПроверяемыеРеквизиты) МассивНепроверяемыхРеквизитов = Новый Массив(); . . . // Проверка значения реквизита на соответствие некоторым требованиям Если НЕ ИННСоответствуетТребованиям(ИНН) Тогда Сообщение = Новый СообщениеПользователю(); Сообщение . Текст = НСтр( " ru = ' ИНН задан неверно . ' " ); Сообщение . Поле = " ИНН " ; Сообщение . УстановитьДанные(ЭтотОбъект); Сообщение . Сообщить(); Отказ = Истина; МассивНепроверяемыхРеквизитов . Добавить( " ИНН " ); КонецЕсли; . . . // Значение реквизита не должно быть пустым в зависимости от другого реквизита Если ЮрФизЛицо <> Перечисления . ЮрФизЛицо . ФизЛицо Тогда МассивНепроверяемыхРеквизитов . Добавить( " ИндивидуальныйПредприниматель " ); КонецЕсли; . . . УдалитьНепроверяемыеРеквизитыИзМассива(ПроверяемыеРеквизиты , МассивНепроверяемыхРеквизитов); КонецПроцедуры; Процедура УдалитьНепроверяемыеРеквизитыИзМассива(МассивРеквизитов , МассивНепроверяемыхРеквизитов) Экспорт Для Каждого ЭлементМассива Из МассивНепроверяемыхРеквизитов Цикл // перед удалением реквизита из массива необходимо проверить , что он там есть // (не был удален ранее платформой или в коде) . ПорядковыйНомер = МассивРеквизитов . Найти(ЭлементМассива); Если ПорядковыйНомер <> Неопределено Тогда МассивРеквизитов . Удалить(ПорядковыйНомер);
```

КонецЦикла;

## КонецПроцедуры

- 1 . 3 . Следует учитывать , что обработчик ОбработкаПроверкиЗаполнения вызывается не при каждой записи объекта , в частности , он не вызывается в случаях если запись были инициирована программно .

Методическая рекомендация (полезный совет)

- 1 . 4 В случае использования в конфигурации подсистемы " Обмен данными " Библиотеки стандартных подсистем обработчик ОбработкаПроверкиЗаполнения вызывается при проведении документов , после их загрузки из сообщения обмена . Для отключения некоторых проверок в этом режиме в обработчике можно анализировать дополнительное свойство объекта

ДополнительныеСвойства . ОтложенноеПроведение .

## Проверки , выполняемые в и вне транзакции записи объекта

- 2 . 1 . Проверки в обработчике ОбработкаПроверкиЗаполнения выполняются вне транзакции записи объекта . Поскольку в случае некорректного заполнения объекта выполнение операции будет прервано еще до записи объекта в базу данных , то размещение проверок в этом обработчике является наиболее эффективным .

При выполнении внетранзакционных проверок в обработчике ОбработкаПроверкиЗаполнения необходимо учитывать тот факт , что новое состояние объекта еще не записано . Если требуется выполнить запрос к тем или иным данным системы , например , прочитать признак ВидНоменклатуры для товаров , выбранных в табличной части документа , " отталкиваясь " от данных документа , то такую поверку можно выполнить , применяя сохранение необходимых для запроса данных во временные таблицы .

- 2 . 2 . В то же время , в обработчике ОбработкаПроверкиЗаполнения не следует размещать проверки , которые должны гарантировать целостное состояние объекта или зависящих от него данных (например , движений) на которые рассчитывает система . Поэтому для реквизитов , некорректные значения которых могут привести к рассогласованности данных в информационной базе , проверку корректности следует выполнять в обработчиках событий , возникающих в транзакции записи ­ ПередЗаписью , ПриЗаписи , ОбработкаПроведения (для документов) .

Для транзакционных проверок , в свою очередь , выделяются два случая:

- 1 . Проверка состояния движений , формируемых документами оперативного учета . Такие проверки довольно часто встречаются в приложениях с оперативным учетом .
- 2 . Проверка состояния других объектов информационной базы , ссылки на которых содержатся в текущем объекте . Такие проверки следует применять очень редко . Не следует злоупотреблять количеством проверок в транзакции записи объекта . Следует помнить , что внутри транзакции записи имеет смысл выполнять только проверки таких ресурсов или таких правил соответствия объектов друг другу , которые не изменяются без проверок всеми участниками процесса .

В первом случае , проверку остатков некоторого ресурса имеет смысл выполнять в транзакции записи только в том случае , если все документы выполняют такую же проверку в транзакции записи . Если хоть один из документов , изменяющих ресурс , делает это без проверок , выполнение проверок другими участниками процесса бессмысленно и такие проверки необходимо выполнять вне транзакции . Исключением может быть только случай , когда документ , который выполняет изменение контролируемого ресурса без проверок , вводится крайне редко . Например , не смотря на то , что документ " Инвентаризация товаров " изменяет остатки товаров без проверок , эта ситуация допустима в виду того , что он вводится крайне редко . Каждое такое исключение из правила должно быть оправданным .

Во втором случае , если при записи Подразделения в транзакции записи выполняется проверка , что сотрудник , выбранный в качестве руководителя подразделения , имеет должность " Руководитель " , то при записи Сотрудника также должна выполняться и " встречная " проверка этого же правила: нельзя записать Сотрудника с должностью отличной от " Руководитель " , если он указан руководителем того или иного подразделения . Поскольку правило , что " Сотрудник " , выбранный руководителем подразделения , должен иметь должность " Руководитель " , может быть нарушено как при записи подразделения , так и при записи сотрудника , то и проверка должна выполняться или в транзакции записи обоих объектов , или вне транзакции записи обоих объектов (а может и не выполняться вообще) .

## Обработчик события ОбработкаЗаполнения

- 1 . В случае если в силу каких ­ либо условий необходимо ограничивать ввод на основании по команде " Создать на основании " , то такую проверку следует выполнять в обработчике модуля объекта ОбработкаЗаполнения . Например , это могут быть проверки вида:
- Для команды " Создать на основании " не различимы группы и элементы справочников и планов видов характеристик: команда одинаково доступна в форме списка как для групп , так и для элементов . Требуется запретить ввод на основании групп .
- Требуется запретить ввод на основании непроведенных документов .

Для оповещения пользователя о причинах отказа , в обработчике ОбработкаЗаполнения следует использовать исключения:

```
Процедура ОбработкаЗаполнения(ДанныеЗаполнения , СтандартнаяОбработка) Если ТипЗнч(ДанныеЗаполнения) = Тип( " СправочникСсылка . Сотрудники " ) Тогда Если ПолучитьЗначениеРеквизита(ДанныеЗаполнения , " ЭтоГруппа " ) = Истина Тогда ВызватьИсключение " Ввод приказа о приеме на основании группы сотрудников невозможен! |Выберите сотрудника . Для раскрытия группы используйте клавиши Ctrl и стрелку вниз " ; Иначе // обработка заполнения объекта по данным заполнения КонецЕсли; КонецЕсли; КонецПроцедуры
```

При этом не рекомендуются какие ­ либо иные решения для подобных проверок . В частности , не следует создавать дополнительные команды для ввода на основании и размещать проверки в обработчиках этих команд .

Методическая рекомендация (полезный совет)

- 2 . Рекомендуется придерживаться следующей логической структуры обработчика ОбработкаЗаполнения (отдельные шаги могут быть пропущены):
- 2 . 1 . Выполнение специального заполнения в зависимости от типа параметра ДанныеЗаполнения .

## Например:

```
ТипДанныхЗаполнения = ТипЗнч(ДанныеЗаполнения); Если ТипДанныхЗаполнения = Тип( " Структура " ) Тогда ЗаполнитьДокументПоОтбору(ДанныеЗаполнения); ИначеЕсли ТипДанныхЗаполнения =
```

<!-- image -->

## Обработчики событий ОбработкаПолученияПредставления и ОбработкаПолученияПолейПредставления

- 1 . С помощью данных обработчиков модуля менеджера объекта можно переопределить представление объекта информационной базы , которое выводится в полях форм и в списках . Пример реализации:
- 2 . Обработчики вызываются при любой необходимости получения представления какого ­ либо объекта информационной базы . Поэтому избыточные данные или неправильный выбор данных для формирования представления могут привести к существенному замедлению работы системы .

```
Процедура ОбработкаПолученияПолейПредставления(Поля , СтандартнаяОбработка) Поля . Добавить( " Наименование " ); Поля . Добавить( " Дата " ); СтандартнаяОбработка = Ложь; КонецПроцедуры Процедура ОбработкаПолученияПредставления(Данные , Представление , СтандартнаяОбработка) Наименование = ?(ПустаяСтрока(Данные . Наименование) , НСтр( " ru = ' Без описания ' " ) , Данные . Наименование); Дата = Формат(Данные . Дата , ? (ПолучитьФункциональнуюОпцию( " ИспользоватьДатуИВремяВСрокахЗадач " ) , " ДЛФ=DT " , " ДЛФ=D " )); Представление = СтроковыеФункцииКлиентСервер . ПодставитьПараметрыВСтроку(НСтр( " ru = ' %1 от %2 ' " ) , Наименование , Дата); СтандартнаяОбработка = Ложь; КонецПроцедуры
```

Также не следует выполнять в этих обработчиках запросы или получение объектов информационной базы (в том числе , запрещены обращения к реквизитам объектов ссылочных типов через точку , что приводит к чтению всего объекта целиком из базы данных) . Также нежелательно использовать получение представления и реквизитов ссылок .

- 3 . Обработчики могут быть также вызваны , в том числе , при записи и удалении объекта в режиме обмена данными . Представление объекта при этом запрашивается для формирования записи в журнал регистрации . Поэтому к ним предъявляются те же требования , что и к логике регистрации объектов ­ см . п . 1 . 2 Разработка планов обмена с отборами .

Эти требования также справедливы при разработке планов обмена для синхронизации с другими программами (не РИБ , по правилам конвертации) с помощью подсистемы «Обмен данными» Библиотеки стандартных подсистем . Например , недопустимо обращаться к предопределенным элементам , которые еще могли быть не загружены в базу или , наоборот , уже удалены в ходе обмена данными:

```
Процедура ОбработкаПолученияПредставления(Данные , Представление , СтандартнаяОбработка) СтандартнаяОбработка = Ложь; Если Данные . ВидОбразования = Справочники . ВидыОбразованияФизическихЛиц . ПослевузовскоеОбразование Тогда Представление = НСтр( " ru = ' Послевузовское образование ' " ); Иначе . . .
```

- 4 . При реализации обработчиков следует также учитывать требования о поддержке толстого клиента , управляемое приложение , клиент­сервер .

## См . также

- Получение представлений для ссылочных значений в табличном документе
- Пользовательские представления объектов

## Общие требования к регламентным заданиям

- 1 . В общем случае , регламентные задания следует использовать , когда необходимо выполнить определенные периодические или однократные действия в соответствии с расписанием .
- 2 . При этом если регламентные задания не требуется добавлять или удалять в зависимости от действий пользователя или логики конфигурации , следует использовать предопределенные регламентные задания . Такие задания автоматически создаются в информационной базе с тем расписанием и состоянием , которое было задано разработчиком в Конфигураторе . Примеры предопределенных регламентных заданий:
- загрузка курсов валют;
- извлечение текста для полнотекстового индексирования;
- обновление агрегатов .

3 . 1 . Если выполнение регламентного задания зависит от включенных одной или нескольких функциональных опций (ФО) , то необходимо программно управлять признаком предопределенного регламентного задания Использование в зависимости от установленных ФО . Иначе регламентное задание будет приводить к запуску сеанса , занимая вычислительные ресурсы сервера 1С:Предприятие .

Например , имеем регламентное задание ПолучениеИОтправкаЭлектронныхПисем (с установленным флажком Использование) , которое должно выполняться только в том случае , если установлена ФО ИспользоватьПочтовыйКлиент .

Неправильно: создавать предопределенное регламентное задание , зависящее от ФО , с установленным флажком Использование .

Правильно: снять флажок Использование и управлять использованием регламентного задания в зависимости от включения/выключения функциональной опции . Если в конфигурации используется подсистема «Регламентные задания» Библиотеки стандартых подсистем (БСП) , то для такой настройки следует использовать процедуру ПриОпределенииНастроекРегламентныхЗаданий общего модуля РегламентныеЗаданияПереопределяемый . Например:

```
Настройка = Настройки . Добавить(); Настройка . РегламентноеЗадание = Метаданные . РегламентныеЗадания . ОбновлениеСтатусовДоставкиSMS; Настройка . ФункциональнаяОпция = Метаданные . ФункциональныеОпции . ИспользоватьПочтовыйКлиент; Настройка . ДоступноВМоделиСервиса = Ложь;
```

После чего в состав определяемого типа МестоХраненияФункциональныхОпций необходимо добавить константы , соответствующие функциональным опциям , используемым для управления регламентными заданиями .

Для конфигураций без БСП следует управлять использованием регламентного задания , разместив , например , в модуле менеджера значения константы ИспользоватьПочтовыйКлиент следующий код:

Процедура

ПриЗаписи(Отказ)

Задание

=

РегламентныеЗадания

.

НайтиПредопределенное(Метаданные

Если

Задание

.

Использование

Задание

.

Значение

Использование

Задание

.

&lt;&gt;

Значение;

Записать();

КонецЕсли;

КонецПроцедуры

- 3 . 2 . Дополнительно следует обезопасить выполнение регламентного задания , включенного через консоль или другим способом , минуя включение ФО , вставив в начало процедуры обработки регламентного задания следующий код:

```
ОбщегоНазначения . ПриНачалеВыполненияРегламентногоЗадания(); Если НЕ ПолучитьФункциональнуюОпцию( " ИспользоватьПочтовыйКлиент " ) Тогда ВызватьИсключение НСтр( " ru = ' Регламентное задание недоступно по функциональным опциям . ' " ); КонецЕсли;
```

Если в конфигурации используется подсистема «Регламентные задания» БСП и настроены зависимости регламентных заданий от ФО (как указано в п . 3 . 1) , то вместо этого достаточно вставить вызов:

```
ОбщегоНазначения . ПриНачалеВыполненияРегламентногоЗадания();
```

- 4 . 1 . Если выполнение регламентного задания зависит от данных информационной базы , то флажок

Предопределенное у регламентного задания следует отключать .

Например:

- обмен данными с другими информационными базами должен проводиться с каждой базой по индивидуальному расписанию;
- запуск каждой дополнительной обработки в базе требуется выполнять по отдельному расписанию .

=

Тогда

.

РегламентныеЗадания

.

ПолучениеИОтправкаЭлектронныхПисем);

В этих случаях требуется создавать экземпляры регламентных заданий и параметризовать их объектами ИБ (например , узлами ИБ , элементами справочника Дополнительные обработки и т . п . ) из кода на встроенном языке с помощью метода РегламентныеЗадания . СоздатьРегламентноеЗадание . При этом в свойстве Наименование необходимо указывать представление объекта , на основании которого создается регламентное задание . Например , есть рассылка отчетов (элемент справочника) , расписание , которое было настроено в карточке рассылки и ее автор , тогда добавление на основании нее регламентного задания будет выглядеть так:

```
// Снимаем ограничение , что только администратор может создавать регламентные задания . УстановитьПривилегированныйРежим(Истина); Задание = РегламентныеЗадания . СоздатьРегламентноеЗадание(Метаданные . РегламентныеЗадания . РассылкаОтчетов); ПараметрыЗадания = Новый Массив; ПараметрыЗадания . Добавить(РассылкаОтчетов); Задание . Параметры = ПараметрыЗадания; Задание . ИмяПользователя = АвторРассылки; Задание . Использование = Истина; Задание . Наименование = СтроковыеФункцииКлиентСервер . ПодставитьПараметрыВСтроку(НСтр( " ru = ' Рассылка отчетов: %1 ' " ) , СокрЛП(РассылкаОтчетов); Задание . Расписание = РасписаниеРассылки; Задание . Записать();
```

- 4 . 2 . Если в конфигурации используется подсистема «Регламентные задания» БСП , то необходимо также запрещать интерактивное создание и запуск параметризованных регламентных заданий из формы Регламентные и фоновые задания . Для этого необходимо указать такое задание в процедуре ПриОпределенииНастроекРегламентныхЗаданий общего модуля РегламентныеЗаданияПереопределяемый . Например:
- 5 . Во избежание различных конфликтных ситуаций рекомендуется в копиях информационной базы автоматически блокировать все регламентные задания , обращающиеся к внешним ресурсам (рассылка почты , синхронизация данных с другими программами и т . п . ) . Например , если копия информационной базы была развернута для тестирования или передана в службу технической поддержки .

```
Настройка = Настройки . Добавить(); Настройка . РегламентноеЗадание = Метаданные . РегламентныеЗадания . РассылкаОтчетов; Настройка . Параметризуется = Истина;
```

Если в конфигурации используется подсистема «Регламентные задания» БСП , то для этого необходимо перечислить такие задания

в процедуре ПриОпределенииНастроекРегламентныхЗаданий общего модуля РегламентныеЗаданияПереопределяемый . Например:

```
Настройка = Настройки . Добавить(); Настройка . РегламентноеЗадание = Метаданные . РегламентныеЗадания . РассылкаОтчетов; Настройка . РаботаетСВнешнимиРесурсами = Истина;
```

В этом случае при перемещении информационной базы администратору будет задан вопрос об отключении таких заданий .

## См . также

- Настройка расписания регламентных заданий
- Запуск регламентных заданий
- Регламентные задания: требования по локализации

## Настройка расписания регламентных заданий

При разработке регламентных заданий необходимо выбирать время и интервал запуска , исходя из прикладного назначения регламентных заданий , а также руководствуясь соображением , что частое выполнение регламентных заданий может негативно влиять на производительность сервера приложений 1С:Предприятие:

- регламентное задание не должно выполняться чаще , чем это нужно с прикладной точки зрения;
- с точки зрения оптимальной загрузки сервера приложений для большинства регламентных заданий нормальным является интервал выполнения заданий в 1 день;
- исключения могут составлять случаи , когда критичным является частое выполнение заданий с прикладной точки зрения , например , для поддержания актуальности данных за короткий период;
- ни в каких случаях не следует задавать периодичность выполнения регламентных заданий меньше одной минуты;
- периодичность выполнения частых (с периодичностью менее одного дня) регламентных заданий должна быть сбалансирована со временем выполнения задания: например , если типичное время выполнения 20 секунд , то периодичность раз в минуту , скорее всего , избыточна;
- выполнение ресурсоемких регламентных операций необходимо по возможности переносить на время минимальной загрузки сервера приложений 1С:Предприятие . Например , в нерабочее время или на выходные дни;
- несколько различных ресурсоемких регламентных заданий лучше " разносить " по времени , исходя из ожидаемого времени их выполнения .

## См . также

- Предопределенные регламентные задания
- Запуск регламентных заданий

## Запуск регламентных заданий

Методическая рекомендация (полезный совет)

- 1 . Рекомендуется предоставлять пользователям альтернативную возможность по выполнению регламентных заданий вручную . Например , предлагать «по кнопке» выполнить обработку данных , обычно выполняемую регламентным заданием в фоне . Это вызвано тем соображением , что работа системы не должна зависеть от автоматического выполнения регламентных заданий . В частности:
- выполнение регламентных заданий может быть осознанно выключено на кластере серверов 1С:Предприятия;
- в отличие от клиент­серверного режима работы 1С:Предприятия версии 8 . 2 и ранее , в котором регламентные и фоновые задания выполняются на сервере , в файловом режиме отсутствовала возможность по их автоматическому выполнению .

В зависимости от специфики регламентных заданий , различается способ их запуска .

- 1 . 1 . В случае если регламентное задание изменяет в системе

некоторые данные , которые необходимы определенному бизнес­процессу или выводятся в конкретном «рабочем месте» (форме) , то в таких «рабочих местах» дополнительно рекомендуется размещать команду для выполнения этого действия . Например:

- в форме для поиска в данных рекомендуется вывести дату актуальности индекса , если он не актуален , и команду «Обновить»;
- в списке входящих писем указано , когда они последний раз принимались , и имеется команда «Получить почту»;
- в рабочем месте ответственного за партионный учет указано , на какой момент времени проводилось последний раз распределение по партиям , и команда «Выполнить» для распределения по партиям .

Такие рабочие места должны информировать пользователя о дате актуальности представленных данных и команду для их обновления или обработки (которая выполняет то же действие , что и регламентное задание) . Команда должна быть доступна только пользователям с необходимыми для ее выполнения правами .

- 1 . 2 . Если работа регламентного задания оказывает влияние на данные , отображаемые в заранее неизвестном количестве рабочих мест , или влияет на информационную базу в целом , то не представляется возможным выделить какое ­ то одно рабочее место для размещения команды запуска всех таких заданий . Примеры регламентных заданий , не «привязанных» к конкретным рабочим местам:
- обновление и перестроение агрегатов;
- установка периода рассчитанных итогов .

Результат работы таких регламентных заданий оказывает влияние сразу на множество внутренних и внешних отчетов системы , которые опираются на итоги и агрегаты .

В этом случае рекомендуется заводить отдельное рабочее место для выполнения таких регламентных заданий . При использовании в конфигурации Библиотеки стандартных подсистем такое рабочее место уже входит в состав подсистемы «Регламентные задания» (форма «Регламентные и фоновые задания») .

1 . 3 . В тех же случаях когда регламентное задание не изменяет данные в системе , а формирует различные отчеты или рассылки из нее , также рекомендуется предусматривать отдельное рабочее место для выполнения таких регламентных заданий .

Примеры регламентных заданий , которые не меняют данные в базе:

- рассылка по почтовым адресатам информации об ошибках в журнале регистрации;
- рассылка информации о новых/просроченных задачах;
- периодический запуск внешних обработок для рассылки отчетов .

При использовании в конфигурации Библиотеки стандартных подсистем такое рабочее место уже входит в состав подсистемы «Регламентные задания» (форма «Регламентные и фоновые задания») .

- 2 . Для администраторов информационных баз действует рекомендация: на период выполнения обновления ИБ блокировать работу регламентных заданий . Однако если обновление выполняет неподготовленный пользователь , в особенности , в файловом режиме работы , то рекомендуется дополнительно предусмотреть следующие меры:
- в файловом режиме работы , при неудачной попытке установки монопольного режима для обновления данных ИБ предлагать автоматически блокировать работу регламентных заданий (перезапуск программы с ключом командной строки /AllowExecuteScheduledJobs ­ Off);
- в начале кода обработчиков регламентных заданий проверять режим работы и прерывать работу регламентного задания с помощью вызова исключения , если обновление ИБ еще не завершено .

При использовании в конфигурации Библиотеки стандартных подсистем первая рекомендация реализована в подсистеме «Обновление версии ИБ» , а для выполнения второй предусмотрена процедура

ПриНачалеВыполненияРегламентногоЗадания общего модуля ОбщегоНазначения , вызов которой необходимо размещать в начале кода обработчиков регламентных заданий .

## См . также

<!-- image -->

## Ограничения на регламентные задания при работе в режиме сервиса

- 1 . В прикладных решениях , ориентированных на работу в режиме сервиса по Технологии 1cFresh , не должно быть определено регламентных заданий , которые включены в состав любого из разделителей . Это ограничение обусловлено тем , что при большом количестве областей данных в одной информационной базе разделенные регламентные задания могут вызвать перегрузку рабочих процессов , обслуживающих данную информационную базу , и серьезно затруднить работу пользователей сервиса .
- 2 . Если требуется обеспечить регулярное выполнение определенного программного кода в каждой области данных разделенной информационной базы , необходимо использовать подсистему БСП «Очередь заданий» , либо разработать аналогичный механизм очереди заданий самостоятельно .

Например , требуется добавить в конфигурацию регламентное задание ПроверкаЦен , которое должно по расписанию выполнять в каждой области проверку прайс­листов , сопоставлять цены с динамикой валютных курсов , и при необходимости формировать некие сообщения для пользователей .

## Неправильно:

Добавить в конфигурацию регламентное заданий ПроверкаЦен и включить его в состав общего реквизита ОбластьДанныхОсновныеДанные .

## Правильно:

- Реализовать прикладную функциональность проверки . Предположим , это будет процедура ПроверитьЦены модуля УправлениеЦенами .
- Добавить в конфигурацию предопределенное неразделенное регламентное задание ПроверкаЦен . Установить в качестве обработчика процедуру УправлениеЦенами . ПроверитьЦены .
- Добавить в общий модуль ОчередьЗаданийПереопределяемый следующий программный код:

```
Процедура ПриПолученииСпискаШаблонов(Шаблоны) Экспорт Шаблоны . Добавить(Метаданные . РегламентныеЗадания . ПроверкаЦен . Имя); КонецПроцедуры
```

Процедура ПриОпределенииПсевдонимовОбработчиков(СоответствиеИменПсевдонимам) Экспорт

СоответствиеИменПсевдонимам . Вставить(Метаданные . РегламентныеЗадания . ПроверкаЦен . ИмяМетода); КонецПроцедуры

- 3 . Единственным исключением является ситуация , когда регламентное задание обязательно должно выполняться от имени определенного пользователя . Например , может потребоваться , чтобы при выполнении задания учитывались установленные для пользователя ограничения доступа к данным . В этом случае разделение регламентного задания допускается , но такое задание обязательно должно быть включено в состав всех разделителей , определенных в конфигурации .
- 4 . В прикладных решениях , ориентированных на работу в режиме сервиса по Технологии 1cFresh , не должно быть участков , где из программного кода напрямую выполняется управление регламентными заданиями . Для управления регламентными заданиями необходимо использовать программный интерфейс БСП , реализованный в модуле РегламентныеЗаданияСервер .

## Неправильно:

```
// Ищем задание по наименованию . Отбор = Новый Структура(); Отбор . Вставить( " Метаданные " , " ПроверкаЦен " ); Задания = РегламентныеЗадания . ПолучитьРегламентныеЗадания(Отбор); // Проверяем , что задание найдено . Если Задания . Количество() <> 1 Тогда // Запись в журнал ошибки опущена . Возврат; КонецЕсли;
```

```
// Включаем найденное задание . НашеЗадание = Задания[0]; НашеЗадание . Использование = Истина; НашеЗадание . Записать(); Правильно: // Ищем задание по наименованию . Отбор = Новый Структура(); Отбор . Вставить( " Метаданные " , " ПроверкаЦен " ); Задания = РегламентныеЗаданияСервер . НайтиЗадания(Отбор); // Проверяем , что задание найдено . Если Задания . Количество() <> 1 Тогда // Запись в журнал ошибки опущена . Возврат; КонецЕсли; // Включаем найденное задание . НашеЗадание = Задания[0]; Параметры = Новый Структура(); Параметры . Вставить( " Использование " , Истина); РегламентныеЗаданияСервер . ИзменитьЗадание(НашеЗадание . УникальныйИдентификатор , Параметры);
```

- 5 . Следует учитывать , что подсистема «Очередь заданий» не гарантирует выполнение регламентного задания в точном соответствии с указанным расписанием . Точность соблюдения расписания зависит от общего количества запланированных заданий , длительности их выполнения и количества исполняющих потоков (регулируется константой «Максимальное количество исполняющихся фоновых заданий») . Рекомендуется в общем случае при работе в режиме сервиса не предоставлять пользователям возможность настройки расписания регламентных заданий .

## Стандартные роли

- 1 . 1 . Если в конфигурации есть разграничение прав доступа пользователей к данным информационной базы , то настройку доступа следует выполнять с помощью ролей . Роли должны создаваться разработчиком конфигурации исходя из задачи ограничения доступа пользователей к данным .
- 1 . 2 . В простейшем случае , роли в конфигурации могут непосредственно соответствовать должностным обязанностям пользователей (Директор , Бухгалтер , Кладовщик и т . п . ) .

Для возможности более тонкой настройки прав доступа администратором , роли могут соответствовать более «мелким» отдельным функциям , совокупность которых образует набор прав для конкретной категории пользователей . В этом случае пользователям назначается комбинация ролей (например , ЧтениеПроизводственныхДокументов ,

ДобавлениеИзменениеСкладскихДокументов , ЧтениеНСИ и т . п . ) . Для упрощения администрирования рекомендуется поставлять в составе конфигурации типовые комбинации таких ролей (например , готовый профиль для директора , бухгалтера , кладовщика и т . п . ) При использовании в конфигурации Библиотеки стандартных подсистем для этого можно воспользоваться средствами подсистемы «Управление доступом» .

- 2 . В конфигурации должны быть определены три обязательные роли , которые предназначены для «прикладного» и системного администрирования информационной базы , а также для интерактивного открытия внешних отчетов и обработок:
- ПолныеПрава (синоним «Полные права») , АдминистраторСистемы (синоним «Администратор системы») и

ИнтерактивноеОткрытиеВнешнихОтчетовИОбработок (синоним «Интерактивное открытие внешних отчетов и обработок») .

- 2 . 1 . ПолныеПрава ­ обязательная роль , которая предоставляет неограниченный доступ ко всем «прикладным» данным информационной базы , но не дает прав доступа для администрирования информационной базы в целом (обновление конфигурации , работа в конфигураторе и т . п . ) . Эта роль должна:
- позволять самостоятельное использование (может быть назначена пользователям);
- предоставлять неограниченный доступ ко всем данным области (к разделенным данным) , кроме права интерактивного удаления (см . также п . 5);
- позволять выполнять все административные действия с областью данных (администрирование пользователей , настройка программы , удаление помеченных объектов и т . п . );
- включать в себя перечисленные права:
- Администрирование данных
- Активные пользователи
- Журнал регистрации
- Монопольный режим
- Тонкий клиент
- Веб­клиент
- Сохранение данных пользователя
- Вывод

В случае если конфигурация рассчитана на работу в модели сервиса , то роль ПолныеПрава назначается администраторам абонентов (администраторам областей данных) .

При работе конфигурации в локальном режиме роль ПолныеПрава назначается пользователям совместно с ролью АдминистраторСистемы , так как в этом режиме функции системного и «прикладного» администрирования информационной базы , как правило , совмещены .

2 . 2 . АдминистраторСистемы – обязательная роль , предоставляющая дополнительные права на администрирование информационной базы в целом (обновление конфигурации , работа в конфигураторе и т . п . ) . Эта роль должна:

- назначаться пользователям только совместно с ролью ПолныеПрава;
- предоставлять неограниченный доступ ко всем неразделенным данным информационной базы;
- содержать все права доступа к объектам (кроме права интерактивного удаления ­ см . ниже п . 5);
- включать в себя все права к корню конфигурации (в частности , права Администрирование и Администрирование данных) , кроме прав Интерактивное открытие внешних отчетов и Интерактивное открытие внешних обработок .

2 . 3 . ИнтерактивноеОткрытиеВнешнихОтчетовИОбработок . обязательная роль , предоставляющая дополнительные права на открытие внешних отчетов и обработок через меню «Файл – Открыть» . Эта роль должна:

- включать в себя права к корню конфигурации Интерактивное открытие внешних отчетов и Интерактивное открытие внешних обработок .

При работе конфигурации в локальном режиме роль

ИнтерактивноеОткрытиеВнешнихОтчетовИОбработок назначается администраторам , но в целях повышения безопасности информационной базы администратор может запретить использование данной роли .

При работе в модели сервиса роли АдминистраторСистемы , ПолныеПрава и ИнтерактивноеОткрытиеВнешнихОтчетовИОбработок назначаются администраторам сервиса .

## 2 . 4 . Роли ПолныеПрава , АдминистраторСистемы и ИнтерактивноеОткрытиеВнешнихОтчетовИОбработок должны

Методическая рекомендация (полезный совет)

- 2 . 5 . При необходимости дать возможность удаления объектов «неполноправным» пользователям , рекомендуется добавить отдельную роль УдалениеПомеченныхОбъектов с правами удаления объектов . Такая роль не предназначена для самостоятельного использования , ее следует назначать пользователям совместно с остальными ролями конфигурации .
- 3 . Роли для настройки общих прав на информационную базу . В случае если в конфигурации для пользователей необходимо настраивать общие права работы с информационной базой (такие как «Тонкий клиент» , «Толстый клиент» , «Интерактивное открытие внешних обработок» и т . д . ) , то в конфигурации должны быть определены отдельные роли для предоставления этих прав . Такие роли не предназначены для самостоятельного использования , их следует назначать пользователям совместно с остальными ролями конфигурации .

Конфигурация должна быть одинаково рассчитана на работу как при наличии этих ролей , так и в условиях отсутствия любой из этих ролей у пользователя .

- 3 . 1 . Администрирование ­ предоставляет право «Административные функции» и «Активные пользователи» .
- 3 . 2 . ВыводНаПринтерФайлБуферОбмена ­ предоставляет право «Вывод» .
- 3 . 3 . ЗапускAutomation ­ предоставляет право «Automation» .
- 3 . 4 . ЗапускВебКлиента ­ предоставляет право «Веб­клиент» .
- 3 . 5 . ЗапускВнешнегоСоединения ­ предоставляет право «Внешнее соединение»
- 3 . 6 . ЗапускТолстогоКлиента ­ предоставляет право «Толстый клиент» .
- 3 . 7 . ЗапускТонкогоКлиента ­ предоставляет право «Тонкий клиент» .
- 3 . 8 . ИнтерактивноеОткрытиеВнешнихОтчетовИОбработок ­ предоставляет права «Интерактивное открытие внешних обработок» и «Интерактивное открытие внешних отчетов» .
- 3 . 9 . ОбновлениеКонфигурацииБазыДанных ­ предоставляет право «Обновление конфигурации базы данных» .
- 3 . 10 . ПросмотрЖурналаРегистрации ­ предоставляет право «Журнал регистрации» .
- 3 . 11 . РежимВсеФункции ­ предоставляет право «Режим " Все функции " » . Этот режим предназначен только для разработчиков/внедренцев и для разбора нештатных ситуаций , поэтому конфигурация должна обеспечивать работу пользователей без использования этого режима . Например , все стандартные обработки (удаление помеченных , управление итогами и агрегатами и т . п . ) должны быть доступны соответствующим пользователям в разделах интерфейса программы .
- 3 . 12 . СохранениеДанныхПользователя ­ предоставляет право «Сохранение данных пользователя» . Рекомендуется предоставлять эту роль всем категориям пользователей , за редким исключением , когда требуется явно запретить настройку пользовательского интерфейса и любые другие персональные настройки таким образом , чтобы работа пользователя не оставляла никаких «следов» в информационной базе . Как правило , такой режим работы требуется для внешних или временных пользователей (респонденты , аудиторы и пр . ) или для пользователей , работающих по тем или иным причинам под одной учетной записью .

Конфигурация должна быть рассчитана на работу пользователей без роли (права) СохранениеДанныхПользователя . В случае если конфигурация обращается из кода

- к пользовательским настройкам (сохранение и загрузка из различных хранилищ настроек: ХранилищеОбщихНастроек ,
- ХранилищеВариантовОтчетов , ХранилищеНастроекДанныхФорм , ХранилищеПользовательскихНастроекОтчетов , ХранилищеСистемныхНастроек)
- к истории работы пользователя (ИсторияРаботыПользователя) и избранному (ИзбранноеРаботыПользователя)
- к пользовательским настройкам отчетов (метод
- УстановитьТекущиеПользовательскиеНастройки расширения управляемой формы для отчета)

то при отсутствии у пользователя права СохранениеДанныхПользователя , этот код должен быть пропущен таким образом , чтобы это не оказывало влияния на основные сценарии работы пользователя . Кроме того , если в конфигурации предусмотрены пользовательские интерфейсы или отдельные элементы форм для работы с пользовательскими настройками (история вводимых значений , флажки «Запомнить мой выбор» и пр . ) , то они не должны быть доступны пользователям без права СохранениеДанныхПользователя .

При использовании в конфигурации Библиотеки стандартных подсистем можно также воспользоваться функциями

ХранилищеОбщихНастроекЗагрузить и

ХранилищеОбщихНастроекСохранить общего модуля

ОбщегоНазначения .

См .

также: Работа с пользовательскими настройками

- 4 . 1 . В тех случаях когда определенным пользователям требуется временный или постоянный доступ на просмотр всех данных информационной базы без ограничений , рекомендуется поставлять в составе конфигурации отдельные роли . Например , это может быть временный доступ для аудитора , постоянный – для собственника или директора организации .
- 4 . 2 . В простейшем случае , когда роли в конфигурации соответствуют должностным обязанностям пользователей (Директор , Бухгалтер , Кладовщик и т . п . ) , должна быть добавлена отдельная роль ТолькоПросмотр .

Роль ТолькоПросмотр должна включать права Чтение , Использование , Просмотр , Ввод по строке (если применимо) для большинства объектов метаданных (за исключением тех данных , которые никогда не выводятся пользователю , а используются в конфигурации только в технологических целях , и поэтому доступ к ним осуществляется всегда в привилегированном режиме) .

- 4 . 3 . В конфигурациях , в которых роли соответствуют более «мелким» отдельным функциям (совокупность которых образует набор прав для конкретной категории пользователей) , рекомендуется назначать пользователям комбинацию ролей , которые предоставляют доступ только на чтение (например , ЧтениеПроизводственныхДокументов , ЧтениеСкладскихДокументов , ЧтениеКассовыхДокументов и т . п . ) . Рекомендуется поставлять в составе конфигурации типовые комбинации таких ролей (например , готовый профиль для аудитора , собственника , директора и т . п . )

При этом для неограниченного доступа на просмотр всех данных информационной базы для таких пользователей нужно отключать (не задавать) условия ограничения доступа на уровне записей (RLS) .

- 5 . Ни в одной роли , включая ПолныеПрава и АдминистраторСистемы , не должно быть установлено (кроме отдельных обоснованных случаев) следующих прав:
- Право интерактивного удаления
- Интерактивное удаление предопределенных данных
- Интерактивная пометка удаления предопределенных данных
- Интерактивное снятие пометки удаления предопределенных данных
- Интерактивное удаление помеченных предопределенных данных

Право удаления рекомендуется оставить только в ролях ПолныеПрава и АдминистраторСистемы .

## См . также

- Ограничения на использование логического ИЛИ в условиях запросов

## Установка прав для новых объектов и полей объектов

При разработке ролей конфигурации следует придерживаться такой методики установки прав на объекты метаданных , которая не допускает появления в конфигурации ролей , дающих доступ к полям объекта , но не к самому объекту; и как следствие , позволяет избежать потенциальные проблемы настройки прав доступа на внедрении , когда пользователь может ошибочно получить доступ ко всем реквизитам объекта метаданных при назначении ему подобной роли .

- 1 . Флажок «Устанавливать права для новых объектов» должен быть установлен только у роли ПолныеПрава
- 2 . При добавлении новой роли , флажок «Устанавливать права для реквизитов и табличных частей по умолчанию» должен быть установлен , а флажок «Независимые права подчиненных объектов» должен быть снят .
- 3 . При необходимости установить в роли права только на поля какого­либо объекта метаданных (права просмотр , редактирование на реквизиты , табличные части , измерения , команды и т . п . без этих прав на сам объект) , предварительно требуется следующее . В роли установить флажок «Независимые права подчиненных объектов» , а флажок «Устанавливать права для реквизитов и табличных частей по умолчанию» снять с очисткой прав на все реквизиты и табличные части .
- 4 . При добавлении в конфигурацию новых объектов или новых полей существующих объектов следует настроить права на эти объекты или поля в соответствующих ролях .

Пример настройки прав в роли ДобавлениеИзменениеВидовКонтактнойИнформации:

<!-- image -->

## Проверка прав доступа

- 1 . В случае большого количества ролей в конфигурации (от нескольких десятков) не рекомендуется использовать ролевую настройку видимости в элементах форм (просмотр и редактирование реквизитов по ролям , пользовательскую видимость полей формы по ролям , использование команд по ролям) . Вместо этого следует придерживаться следующих подходов:
- при сильных различиях внешнего вида и функциональности формы в зависимости от наличия тех или иных ролей у пользователя – разрабатывать отдельные формы , специализированные под конкретный набор прав пользователя;
- при незначительных отличиях – выполнять проверку прав в коде . При этом следует иметь в виду , что программное управление видимостью может снизить скорость открытия формы , что нужно учитывать при выборе между предлагаемыми подходами .

## Эти меры позволяют:

- существенно упростить работу из кода с элементами управления , которые пропадают из коллекции Элементы (код
- Элементы . ИмяЭлемента . ИмяСвойства становится нерабочим);
- повысить устойчивость кода к пересмотру состава ролей в конфигурации;
- организовать контроль использования ролей в конфигурации (в противном случае , выполнять анализ прав доступа по флажкам , назначенных для ролей в различных элементах произвольных форм конфигурации , крайне затруднительно) .
- 2 . Не рекомендуется использовать ролевую настройку видимости в командном интерфейсе конфигурации , командном интерфейсе основного раздела , а также рабочей области начальной страницы . Вместо этого следует использовать настройку прав на разделы командного интерфейса , общие формы и объекты , включенные в командный интерфейс или в рабочую область . Это позволяет повысить предсказуемость поведения управляемого интерфейса для пользователя , а также упростить расследование ошибок .
- 3 . Для проверки прав доступа в коде следует использовать метод ПравоДоступа .

## Например , неправильно:

```
Если РольДоступна( " ДобавлениеИзменениеСтранМира " ) Тогда . . . Если РольДоступна( " ПросмотрОтчетаПопулярныеСтраны " ) Тогда . . . правильно: Если ПравоДоступа( " Редактирование " , Метаданные . Справочники . СтраныМира) Тогда . . .
```

Если ПравоДоступа( " Просмотр " , Метаданные . Отчеты . ПопулярныеСтраны) Тогда . . .

Такой подход позволяет повысить устойчивость кода к пересмотру состава .

ролей в конфигурации

- 4 . В тех случаях , где роль не дает никаких прав на объекты метаданных , а служит только для определения того или иного дополнительного права , допустимо использовать метод РольДоступна .

## См . также

- Стандартные роли
- Разработка ролей в библиотеках

## Использование привилегированного режима

- 1 . 1 . Привилегированный режим позволяет
- выполнить операции с данными от лица пользователей , которым данные недоступны;
- ускорить работу , так как в привилегированном режиме не накладываются ограничения на доступ к данным .
- 1 . 2 . Привилегированный режим следует использовать
- когда требуется с логической точки зрения отключить проверку прав;
- когда допустимо отключить проверку прав , чтобы ускорить работу и при этом работа с данными от лица пользователя логически не нарушает установленные для него права доступа .
- 2 . Далее приведем некоторые типовые сценарии использования привилегированного режима .
- 2 . 1 . Если подчиненные регистры (движения документов) требуются пользователю для получения отчетов , то такие регистры следует оставлять доступными только для чтения , а запись в такие регистры следует выполнять переходом в привилегированный режим . При таком подходе , проверка прав на запись выполняется только для регистратора .

Например , в конфигурации имеются объекты метаданных:

- Документ . ОприходованиеТоваров
- РегистрНакопления . ОстаткиНаСкладах
- Отчет . ОстаткиНаСкладах .

Документ ОприходованиеТоваров делает движения по регистру накопления ОстаткиНаСкладах при проведении в привилегированном режиме . Пользователю не требуется напрямую изменять регистр , но требуется формировать отчет ОстаткиНаСкладах , который читает данные регистра . Поэтому пользователю достаточно дать только право чтения регистра .

- 2 . 2 . Если регистры не требуются пользователю ни для получения отчетов , ни в командном интерфейсе , то следует не давать пользователю права на их чтение . Чтение или запись данных в такие регистры выполняется переходом в привилегированный режим .

Например , в конфигурации имеется регистр сведений ВерсииПодсистем , данные которого не выводятся в отчетах , а доступ к нему осуществляется только через специальные функции общего модуля . В этом случае следует не давать пользователям какие ­ либо права доступа к регистру .

- 2 . 3 . Если для выполнения разрешенной пользователю операции требуются заранее недоступные данные , тогда следует их получать переходом в

привилегированный режим , но с гарантией предотвращения передачи этих данных на клиентскую сторону и с гарантией их использования на сервере только для выполнения запланированной операции .

Например , в случае если в конфигурации есть объекты метаданных

- Документ . РеализацияТоваровИУслуг
- РегистрНакопления . Продажи
- РегистрНакопления . Взаиморасчеты

и необходимо , чтобы

- проведение документа от лица кладовщика изменяло регистр продаж , но кладовщику регистр продаж оставался недоступным .
- при проведении документа от лица кладовщика проверялось состояние взаиморасчетов , но кладовщику регистр взаиморасчетов оставался недоступным .
- 2 . 4 . Привилегированный режим также следует использовать с целью повышения производительности в тех случаях , когда это не приводит к выполнению действий или получению данных , не разрешенных пользователю .

Пример 1 . Выполняется запрос , у которого значения параметров отбора уже прошли проверку ограничения прав на уровне записей . Тогда сам запрос допустимо выполнить в привилегированном режиме для повышения его производительности . Переход в привилегированный режим , например , при получении данных для отчета , следует тщательно рассчитывать , чтобы предотвратить получение данных , не разрешенных пользователю .

- Пример 2 . Параметр сеанса " Текущий пользователь " не доступен ни в одной роли . Для получения значения используется функция:
- 3 . В то же время , неоправданное использование привилегированного режима может привести к проблемам безопасности пользовательских данных .
- 3 . 1 . Потенциально опасны любые экспортные процедуры и функции , которые выполняют на сервере какие ­ либо действия с предварительной безусловной установкой привилегированного режима , так как это отключает проверку прав доступа текущего пользователя . Особого внимания требуют экспортные процедуры и функции клиентского прикладного программного интерфейса сервера 1С:Предприятия .

```
Функция ТекущийПользователь() Экспорт УстановитьПривилегированныйРежим(Истина); Возврат ПараметрыСеанса . ТекущийПользователь; КонецФункции
```

Например , неправильно:

Процедура ИзменитьИлиУдалитьДанные( . . . ) Экспорт

```
УстановитьПривилегированныйРежим(Истина); // Отключаем проверку прав доступа // Изменяем данные в привилегированном режиме . . . КонецПроцедуры
```

## Правильно:

```
Процедура ИзменитьИлиУдалитьДанные( . . . ) Экспорт // Изменяем данные // (при этом если у пользователя недостаточно прав для выполнения операции над данными, то будет вызвано исключение) . . . КонецПроцедуры
```

Исключение составляют случаи , когда действие , выполняемое процедурой , должно быть разрешено (или возвращаемое значение функции должно быть доступно) абсолютно всем категориям пользователей .

- 3 . 2 . В случаях , когда к экспортной процедуре или функции выполняется обращение в сеансе с недостаточным уровнем прав доступа , должно вызываться исключение стандартного вида (см . метод платформы ВыполнитьПроверкуПравДоступа) .

Как правило , для этого не требуется предусматривать в коде каких­либо проверок , так как при наличии в конфигурации ролей и ограничений доступа к данным на уровне записей (RLS) при попытке обращения к недоступным данным возникнет исключение:

- при выполнении запроса без ключевого слова РАЗРЕШЕННЫЕ;
- при вызове метода ПолучитьОбъект «от» недоступной ссылки на объект;
- при вызове недоступного метода глобального контекста;
- и в других аналогичных случаях .

При необходимости выполнить проверку прав доступа вручную , следует использовать метод ВыполнитьПроверкуПравДоступа . Пример предварительной проверки перед выполнением действий в привилегированном режиме:

```
Процедура ИзменитьИлиУдалитьДанные( . . . ) Экспорт ВыполнитьПроверкуПравДоступа( . . . ); // Если у пользователя недостаточно прав, то будет вызвано исключение УстановитьПривилегированныйРежим(Истина); // Отключаем проверку прав доступа
```

//

Изменяем

.

.

.

## КонецПроцедуры

См .

также: Перехват исключений в коде

- 4 . Для перехода в привилегированный режим следует использовать следующие возможности платформы 1С:Предприятие:
- 1 . При реализации логики проведения и отмены проведения документов в обработчиках модуля документа ОбработкаПроведения и ОбработкаУдаленияПроведения:
- с помощью установки свойств документа " Привилегированный режим при проведении " и " Привилегированный режим при отмене проведения " (эти свойства переводят выполнение обработчиков в привилегированный режим);
- если логика проведения работает с некоторой выборкой данных , состав которой должен ограничиваться для пользователя , то следует снимать эти свойства и использовать процедуру глобального контекста УстановитьПривилегированныйРежим;
- 2 . Устанавливать свойство бизнес ­ процесса " Привилегированный режим " для создания задач в привилегированном режиме .
- 3 . Устанавливать свойство бизнес ­ процесса " Привилегированный режим при получении " для функциональных опций .
- 4 . В произвольном месте любого модуля с помощью процедуры глобального контекста УстановитьПривилегированныйРежим:
- 4 . С помощью размещения процедур и функций в общем модуле с установленным свойством Привилегированный .

```
УстановитьПривилегированныйРежим(Истина) // фрагмент кода в привилегированном режиме // … УстановитьПривилегированныйРежим(Ложь)
```

данные

в

привилегированном

режиме

## Ограничения на использование ключевого слова " РАЗРЕШЕННЫЕ " в запросах

Использование ключевого слова РАЗРЕШЕННЫЕ во всех запросах с целью нормальной работы пользователя без возникновения ситуаций с нарушением прав доступа , может привести к искажению данных , полученных в результате выполнения запроса . Необходимо иметь в виду , что для корректной работы бизнес ­ логики , заложенной в конфигурацию , различным подсистемам конфигурации необходимо предоставить доступ не к ограниченной , а ко всей требуемой информации .

Например , если использовать ключевое слово РАЗРЕШЕННЫЕ в запросах механизмов определения списания себестоимости товаров при их отгрузке со склада , то себестоимость списания одного пользователя может отличаться от себестоимости другого . В данном случае необходимо поддерживать целостность информации и либо разрешать пользователю чтение информации для корректного отражения хозяйственной операции , либо конфигурация должна прекращать выполнение операции с сообщением о нарушении прав доступа .

Другой пример: если у пользователя отсутствует доступ к контактной информации контактных лиц контрагентов , то пользователь ее не увидит . Данная информация не задействована в бизнес­процессах заложенных в конфигурацию . Ограничение доступа к ней не повлияет на работу конфигурации в целом .

## Влияние изменения значений параметров сеанса и функциональных опций на производительность механизма ограничения доступа к данным

В процессе работы система формирует специальный кеш запросов ограничений доступа к данным , создаваемый для того , чтобы повысить производительность запросов получения данных при использовании ограничений . Ограничения доступа к данным могут использовать параметры сеанса и функциональные опции . В кеш попадают запросы ограничения доступа с установленными значениями параметров сеанса и функциональных опций .

Однако , при изменении значений параметров сеанса или функциональных опций , которые используются в запросах ограничения доступа к данным , происходит очистка накопленного кэша запросов , что приводит к существенному снижению производительности запросов к данным .

Поэтому рекомендуется выполнять установку значений параметров сеанса " по требованию " , в обработчике УстановкаПараметровСеанса модуля сеанса . Также не рекомендуется часто выполнять изменение значений функциональных опций в процессе работы системы .

## См . также

- Использование функциональных опций
- Установка параметров сеанса " по требованию "

## Влияние изменения значений параметров сеанса и функциональных опций на производительность механизма ограничения доступа к данным

В процессе работы система формирует специальный кеш запросов ограничений доступа к данным , создаваемый для того , чтобы повысить производительность запросов получения данных при использовании ограничений . Ограничения доступа к данным могут использовать параметры сеанса и функциональные опции . В кеш попадают запросы ограничения доступа с установленными значениями параметров сеанса и функциональных опций .

Однако , при изменении значений параметров сеанса или функциональных опций , которые используются в запросах ограничения доступа к данным , происходит очистка накопленного кэша запросов , что приводит к существенному снижению производительности запросов к данным .

Поэтому рекомендуется выполнять установку значений параметров сеанса " по требованию " , в обработчике УстановкаПараметровСеанса модуля сеанса . Также не рекомендуется часто выполнять изменение значений функциональных опций в процессе работы системы .

## См . также

- Использование функциональных опций
- Установка параметров сеанса " по требованию "

## Оформление текстов запросов

- 1 . Все ключевые слова языка запросов пишутся заглавными буквами .

## Методическая рекомендация (полезный совет)

- 2 . Рекомендуется указывать и необязательные конструкции запроса , прежде всего ­ явно назначать псевдонимы полям , в целях повышения наглядности текста запроса и " устойчивости " использующего его кода . Например , если в алгоритме используется запрос с полем , объявленным как

## Касса . Валюта

при изменении имени реквизита нужно будет также изменить и код , осуществляющий обращение по имени свойства Валюта к выборке из результата запроса . Если же поле будет объявлено как

## Касса . Валюта КАК Валюта

то изменение имени реквизита приведет только к изменению текста запроса .

- 2а . Особенно внимательно следует относиться к автоматически присваиваемым псевдонимам для полей – реквизитов других полей , типа " . . .

Касса . Валюта . Наименование . . . " . В приведенном выше примере поле получит автоматический псевдоним ВалютаНаименование , а не Наименование .

- 2б . Следует обязательно указывать ключевое слово КАК перед псевдонимом поля источника .
- 3 . Текст запроса должен быть структурирован , не следует писать запрос в одну строку , даже короткий . Текст запроса должен быть нагляден , поскольку это существенно улучшает его понимание другими разработчиками .
- 4 . В запросы , сложные для понимания , в которых используются вложенные запросы , объединения или соединения рекомендуется вставлять комментарии . Комментарии , например , могут объяснять для получения каких данных используется та или иная таблица в соединении или объединении .

При этом необходимо иметь в виду , что при использовании конструктора запросов , все комментарии в запросе удаляются автоматически без предупреждения .

- 5 . При создании объекта Запрос рекомендуется указывать комментарии , для получения какой информации или каких иных целей будет использован данный запрос .
- 6 . 1 При программной " сборке " текста запроса рекомендуется комментировать все этапы его сборки .
- 6 . 2 . Нужно стараться , чтобы каждая часть формируемого запроса могла быть открыта с помощью конструктора запросов
- это позволяет осуществить экспресс ­ проверку корректности синтаксиса запроса
- это упрощает разработку и сопровождение кода конфигурации , в том числе сторонними разработчиками

Типичные случаи программной модификации текста запроса

## Изменение имени поля выборки или таблицы

## Неправильно

```
ТекстЗапроса = " ВЫБРАТЬ | Номенклатура . Наименование КАК Наименование , | Номенклатура . " + ИмяПоляКод + " КАК КодАртикул |ИЗ | Справочник . Номенклатура КАК Номенклатура " ;
```

## Правильно

```
ТекстЗапроса = " ВЫБРАТЬ | Номенклатура . Наименование КАК Наименование , | &ИмяПоляКод КАК КодАртикул |ИЗ | Справочник . Номенклатура КАК Номенклатура ; ТекстЗапроса = СтрЗаменить(ТекстЗапроса , " &ИмяПоляКод " , " СпрНоменклатура . " + ИмяПоляКод);
```

```
или аналогично для имени таблицы ТекстЗапроса =
```

```
" ВЫБРАТЬ | ТаблицаСправочника . Наименование КАК Наименование , | ТаблицаСправочника . Код КАК Код |ИЗ | &ТаблицаСправочника КАК ТаблицаСправочника " ; ТекстЗапроса = СтрЗаменить(ТекстЗапроса , " &ТаблицаСправочника " " Справочник . " + ИмяСправочника); или еще один вариант для имени таблицы ТекстЗапроса = " ВЫБРАТЬ | Номенклатура . Наименование КАК НаименованиеТовара , | ЕСТЬNULL(ТаблицаОстатков . ВНаличииОстаток , 0) КАК ОстатокТовара |ИЗ | Справочник . Номенклатура КАК Номенклатура | ЛЕВОЕ СОЕДИНЕНИЕ #ТаблицаОстатков КАК ТаблицаОстатков | ПО Номенклатура . Ссылка= ТаблицаОстатков . Номенклатура " ; Если ИспользуетсяАдресноеХранение Тогда ТекстЗапроса = СтрЗаменить(ТекстЗапроса , " #ТаблицаОстатков " , " РегистрНакопления . ТоварыВЯчейках . Остатки " ); Иначе ТекстЗапроса = СтрЗаменить(ТекстЗапроса , " #ТаблицаОстатков " , " РегистрНакопления . ТоварыНаСкладах . Остатки " ); КонецЕсли; Конкатенация нескольких текстов запросов в пакет Неправильно ТекстЗапроса = " " ; Если ИспользоватьУпаковки Тогда ТекстЗапроса = " ВЫБРАТЬ | Упаковки . Ссылка КАК Ссылка |ИЗ | Справочник . Упаковки КАК Упаковки; |///////////////////////////////////////////////////////////// | " ; КонецЕсли; ТекстЗапроса = ТекстЗапроса + " ВЫБРАТЬ | Номенклатура . Ссылка КАК Ссылка
```

```
,
```

```
|ИЗ | Справочник . Номенклатура КАК Номенклатура " ; Правильно ТекстЗапроса = " " ; Если ИспользоватьУпаковки Тогда ТекстЗапроса = " ВЫБРАТЬ | Упаковки . Ссылка КАК Ссылка |ИЗ | Справочник . Упаковки КАК Упаковки " ; ТекстЗапроса = ТекстЗапроса + " |; |///////////////////////////////////////////////////////////// | " ; КонецЕсли; ТекстЗапроса = ТекстЗапроса + " ВЫБРАТЬ | Номенклатура . Ссылка КАК Ссылка |ИЗ | Справочник . Номенклатура КАК Номенклатура " ; Или Разделитель = " |; |///////////////////////////////////////////////////////////// | " ; ТекстыЗапросовПакета = Новый Массив; ТекстЗапроса = " ВЫБРАТЬ | Упаковки . Ссылка КАК Ссылка |ИЗ | Справочник . Упаковки КАК Упаковки " ; ТекстыЗапросовПакета . Добавить(ТекстЗапроса); ТекстЗапроса = " ВЫБРАТЬ | Номенклатура . Ссылка КАК Ссылка
```

<!-- image -->

## См . также

- Запросы , динамические списки и отчеты на СКД: требования по локализации

## Многократное выполнение однотипных запросов

Рекомендуется получать все необходимые однотипные данные одним запросом , вместо выполнения серии запросов .

## Правильно:

```
// БанкиДляОбработки ­ содержит массив банков , счета в которых необходимо обработать ОбщийЗапрос = Новый Запрос( " |ВЫБРАТЬ | БанковскиеСчета . Ссылка КАК Счет |ИЗ | Справочник . БанковскиеСчета КАК БанковскиеСчета |ГДЕ | БанковскиеСчета . Банк В(&БанкиДляОбработки) " ); ОбщийЗапрос . УстановитьПараметр( " БанкиДляОбработки " , БанкиДляОбработки); ВыборкаСчетов = ОбщийЗапрос . Выполнить() . Выбрать(); Пока ВыборкаСчетов . Следующий() Цикл ОбработатьСчетаВБанке(ВыборкаСчетов . Счет); КонецЦикла; Неправильно: // БанкиДляОбработки ­ содержит массив банков , счета в которых необходимо обработать ЧастныйЗапрос = Новый Запрос( " |ВЫБРАТЬ | БанковскиеСчета . Ссылка КАК Счет |ИЗ | Справочник . БанковскиеСчета КАК БанковскиеСчета |ГДЕ | БанковскиеСчета . Банк = &Банк " ); Для каждого Банк Из БанкиДляОбработки Цикл ЧастныйЗапрос . УстановитьПараметр( " Банк " , Банк); ВыборкаСчетов = ЧастныйЗапрос . Выполнить() . Выбрать(); Пока ВыборкаСчетов . Следующий() Цикл ОбработатьСчетаВБанке(ВыборкаСчетов . Счет); КонецЦикла; КонецЦикла;
```

## Проверка на пустой результат выполнения запроса

- 1 . Проверку того , что результат выполнения запроса не содержит строк следует выполнять с помощью метода Пустой . Поскольку на получение выборки из результата запроса (выгрузка его в таблицу значений) будет затрачиваться дополнительное время .

## Неправильно:

```
Выборка = Запрос . Выполнить() . Выбрать(); Если Выборка . Следующий() Тогда Возврат Истина; Иначе Возврат Ложь; КонецЕсли;
```

## Правильно:

```
Возврат НЕ Запрос . Выполнить() . Пустой()
```

Методическая рекомендация (полезный совет)

- 2 . В то же время если требуется выбрать (или выгрузить) результат запроса , то предварительный вызов метода Пустой не требуется .

## Например , вместо:

```
РезультатЗапроса = Запрос . Выполнить(); Если НЕ РезультатЗапроса . Пустой() Тогда // избыточный вызов Выборка = РезультатЗапроса . Выбрать(); Пока Выборка . Следующий() Цикл . . .
```

## правильно:

```
Выборка = Запрос . Выполнить() . Выбрать(); Пока Выборка . Следующий() Цикл . . .
```

## Ограничение на использование конструкции " ПОЛНОЕ ВНЕШНЕЕ СОЕДИНЕНИЕ " в запросах

Методическая рекомендация (полезный совет)

- 1 . 1 . При разработке текстов запросов следует иметь в виду , что при работе в клиент­серверном варианте , когда в качестве СУБД используется PostgreSQL , производительность выполнения запросов с конструкцией ПОЛНОЕ ВНЕШНЕЕ СОЕДИНЕНИЕ значительно снижается . В особенности это касается случаев , когда в запросе встречаются две и более таких конструкций .

Поэтому в общем случае не рекомендуется использовать конструкцию ПОЛНОЕ ВНЕШНЕЕ СОЕДИНЕНИЕ в запросах . И в тех случаях , где это возможно , рекомендуется переписать текст исходного запроса без использования этой конструкции .

Например , следующий запрос:

```
ВЫБРАТЬ ЕСТЬNULL(ПланПродаж . Номенклатура , ФактическиеПродажи . Номенклатура) КАК Номенклатура , ЕСТЬNULL(ПланПродаж . Сумма , 0) КАК СуммаПлан , ЕСТЬNULL(ФактическиеПродажи . Сумма , 0) КАК СуммаФакт ИЗ ПланПродаж КАК ПланПродаж ПОЛНОЕ СОЕДИНЕНИЕ ФактическиеПродажи КАК ФактическиеПродажи ПО ПланПродаж . Номенклатура = ФактическиеПродажи . Номенклатура
```

может быть реализован без конструкции ПОЛНОЕ [ВНЕШНЕЕ] СОЕДИНЕНИЕ следующим образом:

```
ВЫБРАТЬ ПланФактПродаж . Номенклатура КАК Номенклатура , СУММА(ПланФактПродаж . СуммаПлан) КАК СуммаПлан , СУММА(ПланФактПродаж . СуммаФакт) КАК СуммаФакт ИЗ (ВЫБРАТЬ ПланПродаж . Номенклатура КАК Номенклатура , ПланПродаж . Сумма КАК СуммаПлан , 0 КАК СуммаФакт
```

ИЗ

ПланПродаж

ОБЪЕДИНИТЬ

## ВЫБРАТЬ

ФактическиеПродажи . Номенклатура ,

0

,

ФактическиеПродажи . Сумма

ИЗ

ФактическиеПродажи КАК ФактическиеПродажи) КАК ПланФактПродаж

## СГРУППИРОВАТЬ ПО

ПланФактПродаж . Номенклатура

- 1 . 2 . Исключение составляют случаи , когда текст исходного запроса не может быть переписан без использования конструкции ПОЛНОЕ ВНЕШНЕЕ СОЕДИНЕНИЕ по объективным причинам . Следует иметь в виду , что при выполнении данной конструкции на СУБД PostgreSQL она автоматически заменяется платформой 1С:Предприятие на эквивалентную , которая может быть исполнена в СУБД PostgreSQL . При этом сохраняются все атрибуты запроса , такие как модификаторы ПЕРВЫЕ , РАЗЛИЧНЫЕ , а также УПОРЯДОЧИТЬ ПО . В таких случаях не следует " механически " заменять конструкцию ПОЛНОЕ ВНЕШНЕЕ СОЕДИНЕНИЕ только с той целью , чтобы от нее избавиться в тексте запроса .
- 2 . Не допускается одновременно использовать конструкцию ПОЛНОЕ СОЕДИНЕНИЕ и обращение к табличным частям из раздела ВЫБРАТЬ .

Данное требование продиктовано особенностью выполнения подобных запросов на СУБД PostgreSQL и необходимостью переносимости прикладных решений на эту СУБД .

## См . также

- Общие требования к конфигурации

КАК

ВСЕ

ПланПродаж

<!-- image -->

## Упорядочивание результатов запроса

- 1 . 1 . Если алгоритм обработки результатов запроса зависит от порядка записей в запросе или если результат обработки запроса в той или иной форме представляется пользователю , то в тексте запроса следует использовать предложение УПОРЯДОЧИТЬ ПО . В отсутствие выражения УПОРЯДОЧИТЬ ПО невозможно сделать никаких предположений о том , в каком порядке будут представлены записи в результатах запроса .

Типичные примеры проблем , которые могут возникать:

- разная последовательность строк табличной части при заполнении по результатам запроса;
- разный порядок вывода данных (строк , колонок) в отчетах;
- разное заполнение движений документа по результатам запроса ( * ) .

Вероятность возникновения разных результатов при выполнении одинаковых действий повышается

- при переносе информационной базы на другую СУБД
- при смене версии СУБД
- при изменении параметров СУБД
* Примечание: упорядочивание результатов запросов , по которым формируются движения , оправдано только в том случае , если упорядочивание является частью алгоритма формирования движений (например , списание остатков партий товаров по FIFO) . В остальных случаях упорядочивать записи не следует , так как дополнительное упорядочивание будет создавать избыточную нагрузку на СУБД .
- 1 . 2 . Если результаты запроса должны тем или иным образом отображаться пользователю , то
- упорядочивать результаты таких запросов необходимо по полям примитивных типов;
- упорядочивание по полям ссылочных типов нужно заменять на упорядочивание по строковым представлениям этих полей .

В противном случае порядок следования строк будет выглядеть для пользователя случайным (необъяснимым) .

См .

также: Сортировка строк таблиц значений

- 1 . 3 . Отсутствие предложения УПОРЯДОЧИТЬ ПО оправдано только в тех случаях , когда
- алгоритм обработки результатов запроса не рассчитывает на определенный порядок записей
- результат обработки выполненного запроса не показывается пользователю
- результат запроса ­ заведомо одна запись

В таких случаях рекомендуется не добавлять предложение УПОРЯДОЧИТЬ ПО в текст запроса , так как это приводит к дополнительным затратам времени при выполнении запроса .

## Совместное использование с конструкцией РАЗЛИЧНЫЕ

- 2 . Если в запросе используется конструкция РАЗЛИЧНЫЕ , упорядочивание следует выполнять только по полям , включенным в выборку (в секции ВЫБРАТЬ) .

Данное требование связано со следующей особенностью выполнения запросов: в поля выборки неявно включаются поля упорядочивания , что в свою очередь может привести к появлению в результате запроса нескольких строк с одинаковыми значениями полей выборки .

## Ограничения на использование конструкции АВТОУПОРЯДОЧИВАНИЕ

- 3 . Использование конструкции ПЕРВЫЕ совместно с конструкцией АВТОУПОРЯДОЧИВАНИЕ запрещено .

В остальных случаях конструкцию АВТОУПОРЯДОЧИВАНИЕ также не рекомендуется использовать , так как разработчик не контролирует , какие именно поля будут использованы для упорядочивания . Применение такой конструкции оправдано только в тех случаях , когда получаемый порядок записей не важен , но при этом он должен быть одинаковым в не зависимости от применяемой СУБД .

Причины использования конструкции АВТОУПОРЯДОЧИВАНИЕ следует указывать в комментарии , размещенном непосредственно перед текстом запроса .

## Округление результатов арифметических операций в запросах

Методическая рекомендация (полезный совет)

- 1 . Если в операции деления заранее известны порядки числителя и знаменателя , то следует по возможности избегать выполнения деления числа заведомого маленького порядка на число заведомо большого порядка . Например , вместо:

0

.

02

/

28346

## правильно:

0

*

.

02

9287492

9287492

/

28346

- 2 . При выполнении арифметических операций в запросах к базе данных платформа 1С:Предприятия поддерживает точность вычислений до 8 разрядов дробной части . Однако , из­за особенностей работы различных СУБД в некоторых ситуациях точность результатов может отличаться от 8 . Более подробно о вычислении разрядности результатов можно почитать в статье ИТС Разрядность результатов выражений и агрегатных функций в языке запросов .

Если точность результата выполнения запроса к базе данных , содержащего

- арифметические операции деления ,
- агрегатные функции СРЕДНЕЕ ,
- арифметические операции умножения , если каждый из множителей может иметь дробную часть ,

различается на различных СУБД , то рекомендуется к операндам и/ или результатам этих операций применять оператор явного приведения разрядности и точности числовых данных:

```
ВЫРАЗИТЬ( . . . КАК Число(m , n))
```

Оператор ВЫРАЗИТЬ следует применять к операндам , если на какой ­ нибудь СУБД точность получаемого результата недостаточна . Например , требуется 10 разрядов после запятой , а получается 6 .

При этом указанная общая разрядность операндов должна быть минимальной , но не меньше той , которая достаточна для представления значений каждого из операндов . Неоправданное

*

завышение разрядности может привести к потере точности последующих вычислений и несколько снизить скорость выполнения запроса .

Важно иметь в виду , что на разных СУБД имеются различные ограничения на максимальную разрядность десятичных чисел . Самое жесткое ограничение ­ это 31 разряд в целой и дробной частях . Чем меньшее значение разрядности будет указано для операндов , тем выше сможет быть точность результата . Например , если в результате требуется не менее 10 разрядов дробной части , первый операнд заведомо помещается в 15 разрядов целой части , а второй операнд заведомо помещается в 5 знаков целой части , то выражение может быть записано так:

ВЫБРАТЬ ВЫРАЗИТЬ(Таблица . Множитель * Таблица . Числитель КАК Число(25 , 10)) / ВЫРАЗИТЬ(Таблица . Знаменатель КАК Число(15 , 10)) КАК Результат ИЗ Таблица КАК Таблица

Оператор ВЫРАЗИТЬ следует применять к результату , если точность вычислений на всех СУБД достаточна , но на некоторых она больше , а на других меньше . При этом указанная общая разрядность результата должна быть минимальной , но не меньше той , которая достаточна для представления значений результата . Если в приведенном примере известно , что Знаменатель не может быть меньше 0 . 00001 , то для представления результата достаточно 20 разрядов целой части . В этом случае выражение может быть записано так:

ВЫБРАТЬ ВЫРАЗИТЬ(Таблица . Множитель * Таблица . Числитель / Таблица . Знаменатель КАК Число(30 , 10)) КАК Результат ИЗ Таблица КАК Таблица

Иногда может быть целесообразно выполнить приведения к требуемой точности как операндов , так и результата . Например:

ВЫБРАТЬ ВЫРАЗИТЬ(ВЫРАЗИТЬ(Таблица . Множитель * Таблица . Числитель КАК Число(25 , 10)) / ВЫРАЗИТЬ(Таблица . Знаменатель КАК Число(15 , 10)) КАК Число(30 , 10)) КАК Результат ИЗ Таблица КАК Таблица

## Особенности использования в запросах оператора ПОДОБНО

- 1 . При использовании в тексте запроса оператора ПОДОБНО допустимо использовать только константные строковые литералы или параметры запроса . Запрещается формировать строку шаблона при помощи вычислений , использовать конкатенацию строк средствами языка запросов . Например:

## Допустимо:

```
Реквизит ПОДОБНО " 123% " Недопустимо: Реквизит ПОДОБНО " 123 " + " % " Реквизит ПОДОБНО Таблица . Шаблон
```

- 2 . Запросы , в которых управляющие символы шаблона оператора ПОДОБНО находятся в полях запроса или в вычисляемых выражениях , по­разному интерпретируются на различных СУБД . Запрос , успешно выполняющийся , например , при работе с файловой базой , может возвращать неверные результаты при работе в режиме клиент­сервера . Подобные выражения необходимо переформулировать .

## Например , вместо:

```
Запрос = Новый Запрос( " |ВЫБРАТЬ | Товары . Ссылка |ИЗ | Справочник . Товары КАК Товары |ГДЕ | Товары . СтранаПроисхождения . Наименование ПОДОБНО &ШаблонНазванияСтраны + " _ " | " );
```

## Запрос . УстановитьПараметр( " ШаблонНазванияСтраны " , " ЧА " ); Необходимо использовать: Запрос = Новый Запрос( " |ВЫБРАТЬ | Товары . Ссылка |ИЗ | Справочник . Товары КАК Товары |ГДЕ | Товары . СтранаПроисхождения . Наименование ПОДОБНО &amp;ШаблонНазванияСтраны | " ); Запрос . УстановитьПараметр( " ШаблонНазванияСтраны " , " ЧА \_ " );

Данное требование продиктовано необходимостью переносимости прикладных решений на различные СУБД .

## См . также

- Общие требования к конфигурации
- Оформление текстов запросов

## Псевдонимы источников данных в запросах

- 1 . Псевдоним источника данных должен быть осмысленным , чтобы было понятным его назначение . Требования к псевдонимам источников схожи с требованиями к именам переменных в коде .
- псевдонимы следует образовывать от терминов предметной области таким образом , чтобы было понятно , как источник данных будет использоваться в запросе;
- псевдонимы следует образовывать путем удаления пробелов между словами . При этом каждое слово в имени пишется с прописной буквы . Предлоги и местоимения из одной буквы также пишутся прописными буквами;
- псевдонимы запрещается начинать с подчеркивания;
- псевдонимы не должны состоять из одного символа .

## Неправильно:

```
ВЫБРАТЬ Таблица1 . Ссылка КАК Товар , ЕстьNULL(Таблица2 . КоличествоОстаток , 0) КАК Остаток ИЗ Справочник . Номенклатура КАК Таблица1 ЛЕВОЕ СОЕДИНЕНИЕ РегистрНакопления . ТоварыНаСкладах . Остатки КАК Таблица2 ПО Таблица1 . Ссылка = Таблица2 . Номенклатура
```

## Правильно:

```
ВЫБРАТЬ ВсяНоменклатура . Ссылка КАК Товар , ЕстьNULL(ОстаткиНаСкладах . КоличествоОстаток , 0) КАК Остаток ИЗ Справочник . Номенклатура КАК ВсяНоменклатура ЛЕВОЕ СОЕДИНЕНИЕ РегистрНакопления . ТоварыНаСкладах . Остатки КАК ОстаткиНаСкладах ПО ВсяНоменклатура . Ссылка = ОстаткиНаСкладах . Номенклатура
```

В частности не рекомендуется использовать имена классов объектов метаданных ( " Справочник " , " Документ " и т . д . ) , т . к . обычно такой псевдоним не будет описывать назначение источника в конкретном запросе . Кроме того , соблюдение данной рекомендации уменьшит количество ложных срабатываний при автоматизированном контроле конфигурации на наличие обращений к несуществующим в конфигурации метаданным .

- 2 . В ряде случаев при написании универсальных запросов , когда вместо источника данных при исполнении кода подставляется имя таблицы , допустимо использование универсальных псевдонимов .

## Пример:

```
" ВЫБРАТЬ Таблица . Наименование КАК Наименование Таблица . Код КАК Код ИЗ &Таблица КАК Таблица " ; ТекстЗапроса = СтрЗаменить(ТекстЗапроса , " &Таблица " , " Справочник . " + ИмяСправочника);
```

## Общие требования по разработке оптимальных запросов

Методическая рекомендация (полезный совет)

Прежде чем перейти к более продвинутым методам оптимизации запросов , необходимо убедиться , что сам запрос – адекватен решаемой задаче .

- 1 . 1 . Следует минимизировать объем выборки таким образом , чтобы выбирать ровно те данные , которые требуются для решения задачи . Например , если нужно получить значения конкретных полей , не следует выбирать все поля «на всякий случай» с помощью конструкции ВЫБРАТЬ * ИЗ

…

Вместо выборки большого объема данных для их последующей обработки (свертка , сортировка , проведение вычислений и пр . ) на сервере 1С:Предприятие , следует , в первую очередь , ответить на вопрос: «А есть ли возможность переложить эту работу на базу данных , чтобы получить уже готовый результат?»

- 1 . 2 . Также в большинстве случаев , следует минимизировать и общее количество запросов к СУБД .

См . также: Многократное выполнение однотипных запросов .

- 2 . С другой стороны , не следует пытаться любой ценой перенести выполнение задачи в СУБД . СУБД обычно оптимизирует и выполняет простые запросы более эффективно , чем сложные .
- 2 . 1 . Следует рассмотреть альтернативные меры:
- по подготовке различных (более простых , частных) текстов запроса в зависимости от предусловий и значений параметров запроса – вместо отправки в СУБД одного большого универсального запроса;
- по более эффективной постобработке данных , выбранных запросом из СУБД , на стороне сервера 1С:Предприятия средствами встроенного языка .
- 2 . 2 . При разработке запросов нужно быть уверенным , что они использует эффективные планы выполнения запросов . Для сложных запросов СУБД с высокой вероятностью выберет неправильный план выполнения запроса , что особенно актуально для СУБД DB2 , PostgreSQL и Oracle .

Поэтому не следует неоправданно усложнять запрос , в первую очередь:

- Не следует добавлять вложенные запросы только для повышения читаемости .
- Избегать сложных условий соединения и в предложении ГДЕ , в особенности содержащие подзапросы и конструкции ВЫБОР .
- Использовать в запросе минимально необходимое число таблиц . В зависимости от структуры таблиц , много может быть уже и 5­7 таблиц в

одном запросе (время , затрачиваемое оптимизатором СУБД на анализ запроса , растет нелинейно , в итоге получается плохой план выполнения) .

Для того чтобы узнать , какой план выполнения запроса выбран оптимизатором СУБД , можно воспользоваться консолью запросов , технологическим журналом или средствами СУБД . Как правило , запрос – сложный и будет плохо выполняться , если в скомпилированном плане выполнения запроса есть timeout warning , который означает , что оптимизатору СУБД не хватило времени на поиск наилучшего плана запроса .

См .

также: Запросы

в динамических списках

## Несоответствие индексов и условий запроса

Методическая рекомендация (полезный совет)

- 1 . 1 Необходимо убедиться в том , что для всех условий , использованных в запросе , имеются подходящие индексы .

Условия используются в следующих секциях запроса:

- ВЫБРАТЬ … ИЗ … ГДЕ &lt;условие&gt;
- СОЕДИНЕНИЕ … ПО &lt;условие&gt;
- ВЫБРАТЬ … ИЗ &lt;ВиртуальнаяТаблица&gt;( , &lt;условие&gt;)
- ИМЕЮЩИЕ &lt;условие&gt;

Для каждого условия должен существовать подходящий индекс . Подходящим является индекс , удовлетворяющий следующим требованиям:

- 1 . Индекс содержит все поля перечисленные в условии;
- 2 . Эти поля находятся в самом начале индекса;
- 3 . Эти поля идут подряд , то есть между ними не «вклиниваются» поля , не участвующие в условии запроса
- 1 . 2 Если в структуре базы данных отсутствует индекс , удовлетворяющий всем перечисленным условиям , то для получения результата СУБД будет вынуждена сканировать таблицу или один из ее индексов . Это приведет к увеличению времени выполнения запроса , а также к возможному снижению параллельности системы , поскольку возрастет количество установленных блокировок .

Требования к индексу связаны с физической структурой индекса в СУБД . Эта структура представляет собой дерево значений проиндексированных полей . На первом уровне дерева находятся значения первого поля индекса , на втором ­ второго и так далее . Такая структура позволяет достичь высокой эффективности при поиске по индексу . Кроме того , она гарантирует отсутствие деградации производительности индекса с ростом количества данных .

Однако , индекс такой структуры , очевидно , может быть использован только строго определенным образом . Сначала необходимо провести поиск по значению первого поля индекса , затем ­ второго и так далее . Если , например , условие по первому полю индекса не указано , то индекс уже не сможет обеспечить быстрый поиск . Если указано условие по нескольким первым полям индекса , а затем одно или несколько полей индекса не задано , то индекс может быть использован только частично .

- 2 . При создании объекта метаданных 1С:Предприятие автоматически создает индексы , которые должны подходить для работы большинства запросов .

## Основные индексы , создаваемые 1С:Предприятием:

- индекс по уникальному идентификатору (ссылке) для всех объектных сущностей (справочники , документы и т . д . );
- индекс по регистратору (ссылке на документ) для таблиц движений регистров , подчиненных регистратору;
- индекс по периоду и значениям всех измерений для итоговых таблиц регистров накопления;
- индекс по периоду , счету и значениям всех измерений для итоговых таблиц регистров бухгалтерии .
- 3 . В тех случаях , когда автоматически созданных индексов недостаточно , можно дополнительно проиндексировать реквизиты объекта метаданных .

При этом реквизиты справочников и документов рекомендуется индексировать с дополнительным упорядочиванием . Такой индекс будет учитывать упорядочивание по основному представлению объекта , тем самым он будет эффективно использоваться , например , когда в списке установлен отбор по данному реквизиту , а сам список упорядочен по полям основного представления объекта .

Следует иметь в виду , что создание индекса ускоряет процесс поиска информации , но может несколько замедлить процесс ее изменения (добавления , редактирования и удаления) . Поэтому индексы следует создавать осознанно и только в том случае , если точно известен запрос , для которого такой индекс необходим . Не следует создавать индексы " на всякий случай " или заведомо избыточные индексы . В частности:

- не следует дополнительно индексировать первое измерение регистра , поскольку для поиска по значению первого измерения подходит основной индекс таблицы итогов , который автоматически создаст платформа;
- не следует создавать индексы по низкоселектевным полям . Например , индексировать реквизит типа Булево имеет смысл , только если незначительная часть записей всегда будет иметь одно значение , и в запросах всегда выбираются записи по этому значению .

## Примеры

В конфигурации описан регистр накопления ТоварыНаСкладах:

<!-- image -->

Платформа 1С:Предприятие автоматически создаст для таблицы остатков данного регистра индекс по периоду и всем измерениям в том порядке , в котором они перечислены в конфигураторе .

Рассмотрим несколько примеров запросов и проанализируем , смогут ли они оптимально выполняться при такой структуре данных .

## Запрос 1

```
Запрос . Текст = " ВЫБРАТЬ | ТоварыНаСкладахОстатки . Склад , | ТоварыНаСкладахОстатки . Номенклатура , | ТоварыНаСкладахОстатки . Качество |ИЗ | РегистрНакопления . ТоварыНаСкладах . Остатки( , Номенклатура = &Номенклатура) КАК ТоварыНаСкладахОстатки " ;
```

В данном случае нарушено требование 2 раздела 1 . 1 . В условии отсутствует отбор по первому полю индекса (Склад) . Такой запрос не сможет выполниться оптимально . Для его выполнения серверу СУБД придется перебирать все записи таблицы . Время выполнения этой операции напрямую зависит от количества записей в таблице остатков регистра и может быть очень большим (и будет увеличиваться с ростом количества данных) .

## Варианты оптимизации:

- Проиндексировать измерение Номенклатура
- Поставить измерение Номенклатура первым в списке измерений . Следует осторожно использовать этот метод . В конфигурации могут присутствовать другие запросы , которые могут замедлиться в результате этой перестановки .

## Запрос 2

```
Запрос . Текст = " ВЫБРАТЬ | ТоварыНаСкладахОстатки . Склад , | ТоварыНаСкладахОстатки . Номенклатура , | ТоварыНаСкладахОстатки . Качество |ИЗ | РегистрНакопления . ТоварыНаСкладах . Остатки( | , | Качество = &Качество | И Склад = &Склад) КАК ТоварыНаСкладахОстатки " ;
```

В данном случае нарушено требование 3 раздела 1 . 1 . Между измерениями Склад и Качество в структуре регистра находится измерение Номенклатура , которое не задано в условии запроса . Этот запрос так же не сможет выполняться оптимально . При его выполнении СУБД выполнит поиск по первому полю индекса , но затем вынужденно просканирует некоторую его часть . Сканирование приведет к увеличению времени выполнения запроса и к блокировке избыточных записей в таблице , то есть к снижению общей пропускной способности системы .

## Варианты оптимизации:

- Добавить в запрос условие по измерению Номенклатура
- Убрать из запроса условие по измерению Качество
- Перенести Номенклатуру из измерений в реквизиты
- Поменять местами измерения Номенклатура и Качество

## Запрос 3

```
Запрос . Текст = " ВЫБРАТЬ | ТоварыНаСкладахОстатки . Склад , | ТоварыНаСкладахОстатки . Номенклатура , | ТоварыНаСкладахОстатки . Качество , | ТоварыНаСкладахОстатки . КоличествоОстаток |ИЗ | РегистрНакопления . ТоварыНаСкладах . Остатки( | , | Номенклатура = &Номенклатура | И Склад = &Склад) КАК ТоварыНаСкладахОстатки " ;
```

В этом случае требования соответствия индекса и запроса не нарушены . Данный запрос будет выполнен СУБД оптимальным способом . Следует

обратить внимание на то , что порядок следования условий в запросе не обязан совпадать с порядком следования полей в индексе . Это не является проблемой и будет нормально обработано СУБД .

## См . также

- Индексы таблиц базы данных , которые создаются автоматически системой 1С:Предприятие в базе знаний «Технологические вопросы крупных внедрений»

## Разыменование ссылочных полей составного типа в языке запросов

1 . 1 В языке запросов возможно обращаться не только к полям исходных таблиц запроса , перечисленных в предложении ИЗ , но и к полям таблицы , на которую ссылается поле исходной таблицы запроса , если это поле имеет ссылочный тип . Имена полей при этом пишутся " через точку " . Применение такой конструкции приводит к неявному соединению с дополнительными таблицами для получения значений полей " через точку " .

## Например , в запросе

ВЫБРАТЬ

ТоварныеЗапасы

ТоварныеЗапасы

ТоварныеЗапасы

ИЗ

РегистрНакопления . ТоварныеЗапасы КАК ТоварныеЗапасы

.

.

.

кроме явно указанной в предложении ИЗ таблицы

РегистрНакопления . ТоварныеЗапасы неявно участвует таблица Справочник . Товары для получения значения поля Артикул . А в случае использования ограничений доступа на уровне записей (RLS) , к запросу добавляются ещё и таблицы , участвующие в RLS к таблице Справочник . Товары .

- 1 . 2 Большое число исходных таблиц запроса приводит к его усложнению и может значительно увеличивать время его выполнения . Особенно это важно помнить в тех случаях , когда поле таблицы ссылочного типа имеет составной тип и может содержать ссылки на несколько таблиц . В таком случае , получение полей других таблиц " через точку " от такого поля составного типа приведет к соединениию со всеми таблицами , ссылки на которые могут оказаться в данном поле и в RLS к этим таблицам .

Например , в приведенном ниже запросе получение даты регистратора приведет к неявному соединению с таблицами всех документов ­ регистраторов регистра ТоварныеЗапасы

```
ВЫБРАТЬ . . . ТоварныеЗапасы . Регистратор . Дата , . . . ИЗ РегистрНакопления . ТоварныеЗапасы КАК ТоварныеЗапасы . . .
```

.

.

.

Товар

КАК

Количество

Товар

КАК

Товар

.

Артикул

,

Количество

КАК

Артикул

,

Подобное получение данных " через точку " от ссылочных полей составного типа крайне нежелательно . Каждое исключение из этого правила должно тщательно анализироваться .

- 2 . 1 Следует избегать избыточности при создании полей составных ссылочных типов . Необходимо указывать ровно столько возможных типов для данного поля , сколько необходимо . Не следует без необходимости использовать типы " любая ссылка " или " ссылка на любой документ " и т . п .

Вместо этого следует более тщательно проанализировать прикладную логику и назначить для поля ровно те возможные типы ссылок , которые необходимы для решения задачи .

- 2 . 2 Для того чтобы избежать запросов с использованием большого числа исходных таблиц следует жертвовать компактностью хранения данных ради производительности и помещать соответствующие данные в исходную таблицу запроса .

Например , в регистре ТоварныеЗапасы можно завести реквизит ДатаРегистратора , заполнять его при проведении документов и использовать затем в запросах:

ВЫБРАТЬ

.

.

.

ТоварныеЗапасы . ДатаРегистратора ,

.

.

ИЗ

РегистрНакопления . ТоварныеЗапасы КАК ТоварныеЗапасы

.

.

.

Это приведет к дублированию информации и некоторому (незначительному) увеличению ее объема , но может существенно повысить производительность и стабильность работы запроса .

- 2 . 3 При необходимости следует жертвовать компактностью и универсальностью кода ради производительности:
- Как правило , для выполнения конкретного запроса в данных условиях не нужны все возможные типы данной ссылки . В этом случае , следует ограничить количество возможных типов при помощи функции ВЫРАЗИТЬ .
- Если данный запрос является универсальным и используется в нескольких разных ситуациях (где типы ссылки могут быть разными) , то можно формировать запрос динамически , подставляя в функцию ВЫРАЗИТЬ тот тип , который необходим при данных условиях .

Это увеличит объем исходного кода и , возможно , сделает его менее универсальным , но может существенно повысить производительность и стабильность работы запроса .

Например , неправильно:

.

```
Запрос . Текст = " ВЫБРАТЬ | Продажи . Регистратор . Номер , | Продажи . Регистратор . Дата , | Продажи . Контрагент , | Продажи . Количество , | Продажи . Стоимость |ИЗ | РегистрНакопления . Продажи КАК Продажи |ГДЕ . . .
```

В данном запросе используется обращение к реквизитам регистратора . Регистратор является полем составного типа , которое может принимать значения ссылки на один из 56 видов документов . SQL­текст этого запроса будет включать 56 левых соединений с таблицами документов . Это может привести к серьезным проблемам производительности при выполнении запроса .

## Правильно:

Для решения данной конкретной задачи нет необходимости соединяться со всеми 56 видами документов . Условия запроса таковы , что при его

выполнении будут выбраны только движения документов

РеализацияТоваровУслуг и ЗаказыПокупателя . В этом случае можно значительно ускорить работу запроса , ограничив количество соединений при помощи функции ВЫРАЗИТЬ() .

```
Запрос . Текст = " ВЫБРАТЬ | ВЫБОР | КОГДА Продажи . Регистратор ССЫЛКА Документ . РеализацияТоваровУслуг | ТОГДА ВЫРАЗИТЬ(Продажи . Регистратор КАК Документ . РеализацияТоваровУслуг) . Номер | КОГДА Продажи . Регистратор ССЫЛКА Документ . ЗаказПокупателя | ТОГДА ВЫРАЗИТЬ(Продажи . Регистратор КАК Документ . ЗаказПокупателя) . Номер | КОНЕЦ ВЫБОРА КАК Номер , | ВЫБОР | КОГДА Продажи . Регистратор ССЫЛКА Документ . РеализацияТоваровУслуг | ТОГДА ВЫРАЗИТЬ(Продажи . Регистратор КАК Документ . РеализацияТоваровУслуг) . Дата | КОГДА Продажи . Регистратор ССЫЛКА Документ . ЗаказПокупателя | ТОГДА ВЫРАЗИТЬ(Продажи . Регистратор КАК Документ . ЗаказПокупателя) . Дата | КОНЕЦ ВЫБОРА КАК Дата , | Продажи . Контрагент , | Продажи . Количество , | Продажи . Стоимость |ИЗ | РегистрНакопления . Продажи КАК Продажи |ГДЕ
```

|

|

Продажи

ИЛИ

.

Регистратор

Продажи

.

ССЫЛКА Документ

Регистратор

.

РеализацияТоваровУслуг

ССЫЛКА Документ

.

ЗаказыПокупателя

;

Этот запрос является более громоздким и , возможно , менее универсальным (он не будет правильно работать для других ситуаций ­ когда возможны другие значения типов регистратора) . Однако , при его выполнении будет сформирован SQL запрос , который будет содержать всего два соединения с таблицами документов . Такой запрос будет работать значительно быстрее и стабильнее , чем запрос в его первоначальном виде .

## См . также

- Самодостаточность регистров
- Ограничения на использование реквизитов составного типа

"

## Запросы , выполняющие соединение с вложенными запросами или виртуальными таблицами

1 . 1 При написании запросов не следует использовать соединения с вложенными запросами . Следует соединять друг с другом только объекты метаданных или временные таблицы . Если запрос использует соединения с вложенными запросами , то его следует переписать с использованием временных таблиц (не важно с какой стороны соединения находится вложенный запрос) .

Если запрос содержит соединения с вложенными запросами , то это может привести к следующим негативным последствиям:

- Крайне медленное выполнение запроса при слабой загрузке серверного оборудования . Замедление запроса может быть очень значительным (до нескольких порядков) .
- Нестабильная работа запроса . При некоторых условиях запрос может работать достаточно быстро , при других ­ очень медленно .
- Значительная разница по времени выполнения запроса на разных СУБД .
- Повышенная чувствительность запроса к актуальности и полноте статистик . Сразу после полного обновления статистик запрос может работать быстро , но через некоторое время опять замедлиться .

Пример потенциально опасного запроса , использующего соединение с вложенным запросом:

```
ВЫБРАТЬ . . . ИЗ Документ . РеализацияТоваровУслуг ЛЕВОЕ СОЕДИНЕНИЕ ( ВЫБРАТЬ ИЗ РегистрСведений . Лимиты ГДЕ . . . СГРУППИРОВАТЬ ПО . . . ) ПО . . .
```

Оптимизатор сервера СУБД (независимо от того , какую СУБД вы используете) не всегда может правильно оптимизировать подобный запрос . В данном случае , проблемой для оптимизатора является выбор правильного способа соединения . Существуют несколько алгоритмов соединения двух выборок . Выбор того или иного алгоритма зависит от того , сколько записей будет содержаться в одной и в другой выборке . В том случае , если вы соединяете две физические таблицы , СУБД может легко определить объем обоих выборок на основании имеющейся статистики . Если же одна из соединямых выборок представляет собой вложенный запрос , то понять , какое количество записей она вернет , становится очень сложно . В этом случае СУБД может ошибиться с выбором плана , что приведет к катастрофическому падению производительности запроса .

- 1 . 2 При этом необходимо проиндексировать созданную временную таблицу . В качестве индексных полей следует указать все поля , которые используются в условии соединения .

Для вышеприведенного примера получится следующий пакетный запрос:

```
// Создать менеджер временных таблиц МенеджерВТ = Новый МенеджерВременныхТаблиц; Запрос = Новый Запрос; Запрос . МенеджерВременныхТаблиц = МенеджерВТ; // Текст пакетного запроса Запрос . Текст = " // Заполняем временную таблицу . Запрос к регистру лимитов . | ВЫБРАТЬ . . . | ПОМЕСТИТЬ Лимиты | ИЗ РегистрСведений . Лимиты | ГДЕ . . . | СГРУППИРОВАТЬ ПО . . . | ИНДЕКСИРОВАТЬ ПО . . . ; // Выполняем основной запрос с использованием временной таблицы ВЫБРАТЬ . . . ИЗ Документ . РеализацияТоваровУслуг ЛЕВОЕ СОЕДИНЕНИЕ Лимиты ПО . . . ; "
```

Переписывание запроса по приведенной выше методике имеет своей целью упростить работу оптимизатору СУБД . В переписанном запросе все выборки , участвующие в соединениях будут представлять собой физические таблицы , и СУБД сможет легко определить размер каждой выборки . Это позволит СУБД гарантированно выбрать самый быстрый из всех возможных планов . Причем , СУБД будет делать правильный выбор независимо ни от каких условий . Переписанный подобным образом запрос будет работать одинаково хорошо на любых СУБД , что особенно важно при разработке тиражных решений . Кроме того , переписанный подобным образом запрос лучше читается , проще для понимания и отладки .

- 2 . Если в запросе используется соединение с виртуальной таблицей языка запросов 1С:Предприятия (например ,
- РегистрНакопления . Товары . Остатки()) и запрос работает с неудовлетворительной производительностью , то рекомендуется вынести обращение к виртуальной таблице в отдельный запрос с сохранением результатов во временной таблице (см . пункт 1 . 1) .
- 3 . 1 Исключением из этого правила является случай , когда при левом соединении выборка по ведущей таблице дает мало записей , а вложенный запрос много . Тогда использование соединения с вложенным запросом (виртуальной таблицей) более оптимально , чем использование временных таблиц .

Однако , риск неоптимальности запроса с временными таблицами в описанном случае заведомо меньше вероятности ошибки СУБД при построении неправильного плана для сложного запроса . Поэтому следует применять соединение с вложенными запросами и виртуальными таблицами только в том случае , если есть уверенность в их оптимальности . При отсутствии такой уверенности следует применять соединение с временными таблицами .

- 3 . 2 Также исключением из этого правила являются запросы в динамических списках , поскольку в них нет возможности создания временных таблиц .

## См . также

- Использование вложенных запросов в условии соединения

## Использование вложенных запросов в условии соединения

Не следует использовать вложенные запросы в условии соединения . Это может привести к значительному замедлению запроса и (в отдельных случаях) к его полной неработоспособности на некоторых СУБД . Пример запроса с использованием вложенного запроса в условии соединения:

```
Запрос . Текст = " ВЫБРАТЬ | ОстаткиТоваров . Номенклатура КАК Номенклатура , | Цены . Цена КАК ЦенаПрошлогоМесяца |ИЗ | РегистрНакопления . ТоварыНаСкладах . Остатки( . . . ) КАК ОстаткиТоваров | ЛЕВОЕ СОЕДИНЕНИЕ РегистрСведений . Цена КАК Цены | ПО Цены . Номенклатура = ОстаткиТоваров . Номенклатура И | Цены . Период В ( | ВЫБРАТЬ МАКСИМУМ(ЦеныПрошлогоМесяца . Период) | ИЗ РегистрСведений . Цена КАК ЦеныПрошлогоМесяца | ГДЕ ЦеныПрошлогоМесяца . Период < НАЧАЛОПЕРИОДА(ОстаткиТоваров . Период , МЕСЯЦ) | И ЦеныПрошлогоМесяца . Номенклатура = ОстаткиТоваров . Номенклатура | ) | ГДЕ ОстаткиТоваров . Склад = &Склад " ;
```

В данном случае вложенный запрос в условии соединения используется для получения как бы " среза последних " на конец предыдущего периода . Причем , для каждой номенклатуры период может быть разным . Подобный запрос рекомендуется переписать с использованием временных таблиц . Например , это можно сделать следующим образом:

```
Запрос . Текст = " // Максимальные даты установки цен в прошлом периоде для данных номенклатур |ВЫБРАТЬ | ОстаткиТоваров . Номенклатура КАК Номенклатура , | МАКСИМУМ(Цены . Период) КАК Период |ПОМЕСТИТЬ ДатыПоНоменклатурам |ИЗ | РегистрНакопления . ТоварыНаСкладах . Остатки( . . . ) КАК ОстаткиТоваров | ЛЕВОЕ СОЕДИНЕНИЕ РегистрСведений . Цена КАК Цены | ПО Цены . Номенклатура = ОстаткиТоваров . Номенклатура И | Цены . Период < НАЧАЛОПЕРИОДА(ОстаткиТоваров . Период , МЕСЯЦ) | СГРУППИРОВАТЬ ПО ОстаткиТоваров . Номенклатура | ГДЕ ОстаткиТоваров . Склад = &Склад;
```

<!-- image -->

## См . также

- Запросы , выполняющие соединения с вложенными запросами или виртуальными таблицами

## Обращения к виртуальным таблицам

- 1 . При использовании виртуальных таблиц в запросах , следует передавать в параметры таблиц все условия , относящиеся к данной виртуальной таблице . Не рекомендуется обращаться к виртуальным таблицам при помощи условий в секции ГДЕ и т . п .

Такой запрос будет возвращать правильный (с точки зрения функциональности) результат , но СУБД будет намного сложнее выбрать оптимальный план для его выполнения . В некоторых случаях это может привести к ошибкам оптимизатора СУБД и значительному замедлению работы запроса .

Например , следующий запрос использует секцию ГДЕ запроса для выборки из виртуальной таблицы:

```
Запрос . Текст = " ВЫБРАТЬ | Номенклатура |ИЗ | РегистрНакопления . ТоварыНаСкладах . Остатки() |ГДЕ | Склад = &Склад " ;
```

Возможно , что в результате выполнения этого запроса сначала будут выбраны все записи виртуальной таблицы , а затем из них будет отобрана часть , соответствующая заданному условию .

Рекомендуется ограничивать количество выбираемых записей на самом раннем этапе обработки запроса . Для этого следует передать условия в параметры виртуальной таблицы .

```
Запрос . Текст = " ВЫБРАТЬ | Номенклатура |ИЗ | РегистрНакопления . ТоварыНаСкладах . Остатки( , Склад = &Склад) " ;
```

- 2 . 1 . При обращении к виртуальной таблице следует передавать в условия наиболее простые конструкции , например , " Измерение = Значение " . Не рекомендуется использовать подзапросы и соединения( * ) в параметрах виртуальной таблицы , так как это приводит к медленной работе запроса .
* Примечание: как явные соединения в подзапросах, х, так и неявные – при обращении к полям «через точку» от ссылки и соединения , добавляемые из ограничений доступа к данным (RLS) , предусмотренных в ролях конфигурации .
- 2 . 2 . При необходимости использовать подзапросы рекомендуется соблюдать следующие условия:
- в подзапросе только одна таблица , нет соединений с другими таблицами;
- если в подзапросе таблица табличной части (например , Документ . Накладная . СписокТоваров) , то не должно быть обращения к реквизитам таблицы­шапки (Накладная . Проведен);
- если в подзапросе таблица , у которой могут быть табличные части (например , Документ . Накладная) , то не должно быть обращений к табличным частям (например , ГДЕ

Документ . Накладная . СписокТоваров . Номенклатура = " 1 " );

- если в подзапросе временная таблица , то не должно быть условий (раздела ГДЕ);
- если в подзапросе постоянная таблица , то условие (раздел ГДЕ) допустимо , только если условие выполняется для 80% (или более) случаев; отсутствие условия означает выполнение для 100% случаев .
- если в подзапросе постоянная таблица , то в ограничениях доступа к данным (RLS) не должно содержатся подзапросов и соединений (допускаются только простые условия вида ГДЕ Реквизит = Значение , " ГДЕ Истина " ) . Например , при использовании стандартных шаблонов RLS , входящих в состав подсистемы «Управление доступом» Библиотеки стандартных подсистем к запросу неявно добавляется конструкция Exists с несколькими подзапросами и соединениями . В таких случаях следует переписать исходный запрос с использованием временной таблицы или привилегированного режима .

## Например , неправильно:

```
. . . ИЗ РегистрНакопления . ТоварыКОтгрузке . Остатки( &ДатаОтгрузки , &ОтображениеРаспоряжений И ДокументОтгрузки . Склад = &Склад ­ ­ неявное соединение «через точку» ИЛИ ДокументОтгрузки В (ВЫБРАТЬ ­ ­ подзапрос с соединением Распоряжения . Распоряжение КАК ДокументОтгрузки ИЗ Документ . ЗаданиеНаПеревозку . Распоряжения КАК Распоряжения – ­ доступ к этому документу ограничен по сложному RLS , который неявно добавляет еще пару соединений ВНУТРЕННЕЕ СОЕДИНЕНИЕ Документ . ЗаданиеНаПеревозку . СкладыПогрузки КАК СкладыПогрузки ПО Распоряжения . Ссылка = СкладыПогрузки . Ссылка И СкладыПогрузки . Склад = &Склад И Распоряжения . Ссылка . Проведен – ­ здесь и ниже обращения к реквизитам шапки И Распоряжения . Ссылка . Статус В ( . . . )))
```

правильно:

```
. . . ИЗ РегистрНакопления . ТоварыКОтгрузке . Остатки( &ДатаОтгрузки , Склад = &Склад ­ ­ теперь это реквизит регистра ИЛИ ДокументОтгрузки В (ВЫБРАТЬ ЗаданияНаПеревозку . Распоряжение ИЗ ВременнаяТаблицаЗаданийНаПеревозку КАК ЗаданияНаПеревозку)) ­ ­ выборка из временной таблицы без условий
```

- 2 . 3 . В случае , если нужно использовать несколько условий с подзапросами , следует выбрать одно , удовлетворяющее условиям выше и отфильтровывающее максимальное количество записей . Остальные условия следует накладывать на внешний запрос .

Кроме того , в ряде случаев можно обойтись и без перемещения условий на внешний запрос , если применять временные таблицы . Например , вместо условия (неправильно):

```
Номенклатура В ( . . . ) И Характеристика В ( . . . ) И Серия В( . . . )
```

## правильно:

(Номенклатура , Характеристика , Серия) В (ВЫБРАТЬ Номенклатура , Характеристика , Серия ИЗ ВременнаяТаблицаТоваров)

## См . также

- Разыменование ссылочных полей составного типа в языке запросов
- Использование параметра Условие при обращении к виртуальной таблице (статья на ИТС)
- Эффективное обращение к виртуальной таблице «Остатки»

## Использование логического ИЛИ в условиях запросов

- 1 . Не следует использовать ИЛИ в секции ГДЕ запроса . Это может привести к тому , что СУБД не сможет использовать индексы таблиц и будет выполнять сканирование , что увеличит время работы запроса и вероятность возникновения блокировок . Вместо этого следует разбить один запрос на несколько и объединить результаты .

## Например , запрос

```
ВЫБРАТЬ Товар . Наименование ИЗ Справочник . Товары КАК Товар ГДЕ Артикул = " 001 " ИЛИ Артикул = " 002 " следует заменить на запрос: ВЫБРАТЬ Товар . Наименование ИЗ Справочник . Товары КАК Товар ГДЕ Артикул = " 001 " |ОБЪЕДИНИТЬ ВСЕ |ВЫБРАТЬ Товар . Наименование ИЗ Справочник . Товары КАК Товар ГДЕ Артикул = " 002 "
```

Эта рекомендация не рапространяется на случаи , когда поле технически не может быть включено в состав индекса . Например , это поля вложенных запросов , поля виртуальных таблиц регистров и пр .

В таких случаях , см . Запросы , выполняющие соединение с вложенными запросами или виртуальными таблицами , Эффективное обращение к виртуальной таблице «Остатки» , Использование вложенных запросов в условии соединения .

- 2 . Не рекомендуется использовать логическое ИЛИ в условиях соединения , то есть в секции ПО запроса . Это так же может привести к выбору неоптимального плана и медленной работе запроса . Простого универсального способа переписать такой запрос без использования ИЛИ не существует . Следует проанализировать решаемую задачу и попытаться найти другой алгоритм ее решения .

## Например , неправильно:

```
ВЫБРАТЬ СправочникНоменклатура . Ссылка КАК НоменклатураСсылка , ЗагружаемыйПрайсПоставщика . Цена КАК Цена ИЗ ЗагружаемыйПрайсПоставщика КАК ЗагружаемыйПрайсПоставщика ВНУТРЕННЕЕ СОЕДИНЕНИЕ СправочникНоменклатура КАК СправочникНоменклатура ПО (ЗагружаемыйПрайсПоставщика . НаименованиеТовара = СправочникНоменклатура . Наименование
```

<!-- image -->

| ИЛИ  ЗагружаемыйПрайсПоставщика . АртикулТовара  = СправочникНоменклатура . Артикул)   |
|----------------------------------------------------------------------------------------|
| Правильно:                                                                             |
| ВЫБРАТЬ                                                                                |
| СправочникНоменклатура . Ссылка  КАК  НоменклатураСсылка ,                             |
| ЗагружаемыйПрайсПоставщика . Цена  КАК  Цена                                           |
| ИЗ ЗагружаемыйПрайсПоставщика  КАК                                                     |
| ЗагружаемыйПрайсПоставщика ВНУТРЕННЕЕ  СОЕДИНЕНИЕ  СправочникНоменклатура  КАК         |
| СправочникНоменклатура                                                                 |
| ПО  ЗагружаемыйПрайсПоставщика . НаименованиеТовара  =                                 |
| ОБЪЕДИНИТЬ                                                                             |
| ВЫБРАТЬ                                                                                |
| СправочникНоменклатура . Ссылка ,                                                      |
| ЗагружаемыйПрайсПоставщика . Цена                                                      |
| ИЗ                                                                                     |
| ЗагружаемыйПрайсПоставщика  КАК                                                        |
| ЗагружаемыйПрайсПоставщика ВНУТРЕННЕЕ  СОЕДИНЕНИЕ  СправочникНоменклатура  КАК         |
| СправочникНоменклатура ПО  ЗагружаемыйПрайсПоставщика . АртикулТовара  =               |
| СправочникНоменклатура . Артикул                                                       |

- 3 . Если в конфигурации описано несколько ролей с разным ограничением доступа на уровне записей (RLS) , то не следует назначать одному пользователю более одной такой роли . Если один пользователь будет включен , например , в две роли с RLS ­ бухгалтер и кадровик , то при выполнении всех его запросов к их условиям будут добавляться условия обоих RLS с использованием логического ИЛИ . Таким образом , даже если в исходном запросе нет условия ИЛИ , оно появится там после добавления условий RLS . Такой запрос так же может выполняться неоптимально ­ медленно и с избыточными блокировками .

## Вместо этого следует:

- Пересмотреть состав ролей таким образом , чтобы к одному объекту метаданных давала доступ только одна роль (на чтение , запись и т . п . );
- При необходимости разработки нескольких ролей , предоставляющих доступ к одному объекту метаданных , задавать в них одинаковые условия RLS . В этом случае к тексту запроса будет добавлено только одно условие , без объединения по ИЛИ;
- Либо если это допустимо с точки зрения прикладной области , создать " смешанную " роль ­ " бухгалтер­кадровик " и прописать ее RLS таким образом , чтобы избежать использования ИЛИ в условии , а пользователя включить в эту одну роль .

## См . также

•

Стандартные роли

## Разрешение итогов для периодических регистров сведений

Методическая рекомендация (полезный совет)

1 . 1 . Для периодических регистров сведений рекомендуется разрешить итоги , если выполнены все следующие условия:

- в регистре ожидается большой объем данных (например , оправданно для регистра с ценами номенклатуры; но не имеет смысла для регистра с курсами валют);
- в конфигурации предусмотрены частотные запросы к срезам последних на текущий момент времени и/или к срезам первых для получения актуальных данных (т . е . когда не задан период в параметрах виртуальных таблиц СрезПервых и СрезПоследних);
- при этом остальные условия для виртуальных таблиц СрезПервых и СрезПоследних задаются только на значения измерений (и разделителей , находящихся в режиме Независимо и совместно);
- в ограничениях доступа к данным регистра используются только измерения (и разделители , находящиеся в режиме Независимо и совместно) .

Полный список всех условий, й, когда в запросах задействуются итоги регистра сведений, й, см . в документации к платформе 1С:Предприятие .

Например , если в конфигурации предусмотрены часто выполняющиеся запросы к регистру ЦеныНоменклатуры для получения текущих цен номенклатуры:

## ВЫБРАТЬ

Номенклатура

.

Артикул

ЦеныНоменклатуры

.

.

.

ИЗ

Справочник

.

Номенклатура

ЛЕВОЕ

СОЕДИНЕНИЕ

ВидЦены

КАК

.

Цена

КАК

Артикул

Цена

,

,

КАК

Номенклатура

РегистрСведений

=

&amp;ВидЦены)

ПО

.

ЦеныНоменклатуры

КАК

ЦеныНоменклатуры

ЦеныНоменклатуры

.

.

.

то при соблюдении всех остальных условий , перечисленных выше , установка свойства Разрешить итоги: срез последних существенно ускорит выполнение таких запросов , засчет того , что выборка будет выполняться напрямую из дополнительных таблиц , в которых хранятся только последние значения (для среза последних) и первые значения (для среза первых) .

Номенклатура

=

Номенклатура

.

.

.

СрезПоследних(

Ссылка

,

- 1 . 2 . Кроме того , следует рассмотреть альтернативные варианты по пересмотру запросов к регистру таким образом , чтобы эти условия выполнялись .

Например , если в некоторых случаях данные в регистр ЦеныНоменклатуры записываются будущей датой , а при подборе товаров к этому регистру выполняется запрос всегда на текущую дату (дата явно задана в параметре виртуальной таблицы СрезПоследних) , то итоги не будут ускорять выполнение таких запросов . Поскольку итоги строятся только для первых и последних записей регистра .

Однако если при открытии формы подбора товаров анализировать , есть ли регистраторы с будущей датой , и если их нет – выполнять другой запрос к срезу последних без установки даты , то такой запрос будет работать быстрее .

- 2 . Во всех остальных случаях , не следует разрешать итоги для периодических регистров сведений . Прежде всего , если
- чаще всего (всегда) к виртуальным таблицам среза первых/последних периодического регистра сведений выполняются запросы на конкретный период (например , на дату документа) .
- в условиях для виртуальных таблиц СрезПервых и СрезПоследних чаще всего (всегда) используются подзапросы и соединения (обращения «через точку» к полям связанных таблиц) . Например , в этом случае:

ВЫБРАТЬ . . . ИЗ

РегистрСведений . КурсыВалют . СрезПоследних( , Валюта . Код = &amp;КодВалютыСклада) КАК КурсыВалют

- 3 . Не требуется предусматривать в конфигурации отдельного механизма пересчета итогов , так как актуализация таблиц итогов выполняется автоматически при каждой записи набора записей в регистр .

Исключение составляют отдельные случаи , когда актуализация итогов при записи отключалась принудительно с помощью вызова метода

РегистрСведенийМенеджер . УстановитьИспользованиеИтогов(Ложь) .

## Эффективное обращение к виртуальной таблице «Остатки»

Эффективность обращения к виртуальным таблицам во многом зависит от того , как построено обращение к этой таблице . Стандарт Обращения к виртуальным таблицам описывает общие требования и рекомендации по работе с виртуальными таблицами . В этом стандарте изложены дополнительные рекомендации по повышению эффективности обращения к виртуальной таблице Остатки регистров накопления и бухгалтерии .

При обращении к любой виртуальной таблице платформа 1С:Предприятие генерирует запрос к СУБД , содержащий вложенный запрос . Самым эффективным вложенным запросом для чтения остатков будет чтение хранимой таблицы текущих остатков без применения группировки по измерениям . Платформа 1С:Предприятие сгенерирует такой запрос , если будут соблюдены все перечисленные ниже условия:

- получение остатков ведется без указания даты;
- не используется разделение итогов (необходимо учитывать при использовании такого режима может снижаться параллельность записи в регистр . См . также Режим разделения итогов для регистров накопления , Режим разделения итогов для регистров бухгалтерии);
- внешний по отношению к виртуальной таблице запрос использует все измерения (в предложении ВЫБРАТЬ или в условиях соединения) .

## Пример .

Регистр накопления ОстаткиТовара содержит два измерения: Склад и Номенклатура , а также ресурс Количество . Необходимо запросом получить список всей номенклатуры , с указанием количества товаров на конкретном складе .

## НЕПРАВИЛЬНО

```
ВЫБРАТЬ СпрНоменклатура . Ссылка КАК Товар , ЕСТЬNULL(ОстаткиТоваров . Остаток , 0 ) КАК Остаток ИЗ Справочник . Номенклатура КАК СпрНоменклатура ЛЕВОЕ СОЕДИНИЕНИЕ РегистрНакопления . ОстаткиТоваров . Остатки(&СегодняшняяДата , Склад = &Склад) КАК ОстаткиТоваров ПО ОстаткиТоваров . Номенклатура = СпрНоменклатура . Ссылка
```

## В этом запросе:

- в условия виртуальной таблицы передана дата , поэтому будет использована не только хранимые таблицы остатков , но и таблица движений . Т . к . необходимо получить текущие остатки , то дату в запрос передавать не нужно;
- измерение Склад не используется во внешнем по отношению к виртуальной таблице запросе , поэтому вложенный запрос остатков будет содержать группировку этому измерению .

## ПРАВИЛЬНО

```
ВЫБРАТЬ СпрНоменклатура . Ссылка КАК Товар , ЕСТЬNULL(ОстаткиТоваров . Остаток , 0 ) КАК Остаток ИЗ Справочник . Номенклатура КАК СпрНоменклатура ЛЕВОЕ СОЕДИНИЕНИЕ РегистрНакопления . ОстаткиТоваров . Остатки( , Склад = &Склад) КАК ОстаткиТоваров ПО ОстаткиТоваров . Номенклатура = СпрНоменклатура . Ссылка И ОстаткиТоваров . Склад = &Склад
```

## Использование управляемого режима блокировки

В конфигурациях следует использовать " Управляемый " режим блокировок (свойство Режим управления блокировкой данных конфигурации устанавливается в значение Управляемый) и учитывать особенности работы в этом режиме , в частности:

- Чтение данных другими транзакциями будет невозможно только в том случае , если в текущей и других транзакциях устанавливаются несовместимые управляемые блокировки .
- Явная управляемая блокировка должна устанавливаться перед чтением данных:
- если считываются данные , которые в дальнейшем должны быть изменены;
- необходимо обеспечить неизменность считываемых данных до конца транзакции .
- При установке управляемой блокировки необходимо стремиться , чтобы блокировка была установлена только на те записи , которые будут обработаны системой в результате отработки программного кода .
- Не следует применять в запросах конструкцию ДЛЯ ИЗМЕНЕНИЯ , как не имеющую смысла в этом режиме .

При работе в автоматическом режиме управления блокировкой 1С:Предприятие устанавливает высокую степень изоляции данных в транзакции на уровне СУБД . Это позволяет полностью исключить возможность получения нецелостных или некорректных данных без каких­либо специальных усилий со стороны прикладных разработчиков .

Но , при этом могут возникать избыточные блокировки на уровне СУБД . Эти блокировки связанны как с особенностями реализации механизмов блокировок в самой СУБД , так и с тем , что СУБД не может учитывать (и не учитывает) физический смысл и структуру объектов метаданных 1С:Предприятия .

## См . такке

- Использование транзакций при чтении данных
- Общие сведения об избыточных блокировках
- методика перевода приложений в управляемый режим блокировки содержится в статье «Блокировки данных в 1С:Предприятии 8»

## Блокировка данных объекта для редактирования из кода

- 1 . 1 . Прежде чем изменять существующий объект информационной базы из кода на встроенном языке , следует предварительно его заблокировать (установить «блокировку данных для редактирования» или «объектную блокировку») , тем самым , во­первых , убедиться , не заблокирован ли он другими объектами , во­вторых , попытаться предотвратить его изменение другими пользовательскими сеансами (или другими экземплярами объекта в этом же сеансе) .

В противном случае , если при изменении и записи из встроенного языка не устанавливать блокировку объекта на время редактирования , то может возникнуть , например , ситуация , когда пользователь не сможет сохранить свои изменения , если эти же самые данные были конкурентно изменены в другом сеансе .

При этом блокировка данных для редактирования не запрещает запись заблокированных данных в других пользовательских сеансах (или в других экземплярах объекта в этом же сеансе) , а лишь не позволяет нескольким объектам одновременно установить блокировку одних и тех же данных . В отличие от транзакционных блокировок данных , пессимистическая блокировка данных для редактирования предназначена для обеспечения конкурентной работы пользователей с объектами информационной базы 1С:Предприятия (элементами справочников , документами и т . д . ) Подробнее о блокировке данных для редактирования см . документацию по платформе 1С:Предприятие 8 .

- 1 . 2 . Для блокировки данных для редактирования из встроенного языка следует вызывать метод объектов Заблокировать или метод глобального контекста ЗаблокироватьДанныеДляРедактирования .
- Пример № 1 . Требуется заблокировать объект и , если это удалось , модифицировать данные . В противном случае – проинформировать пользователя об отказе в выполнении операции с помощью сообщения вида:

«Не удалось заблокировать запись . Действие (изменение , удаление или блокировка записи) не выполнено . Ошибка блокировки объекта . Объект уже заблокирован: компьютер: &lt;имя компьютера&gt; , пользователь: &lt;имя пользователя&gt; , сеанс: &lt;номер сеанса&gt; , начат: &lt;дата и время&gt; , приложение: &lt;тип клиентского приложения&gt;» .

```
ФайлОбъект = ДанныеФайла . Ссылка . ПолучитьОбъект(); // Выполнить блокировку объекта от изменения другими режимами // или пользователями; в случае блокировки ­ // вывести пользователю сообщение об исключении . ФайлОбъект . Заблокировать(); // Затем изменить и записать объект
```

- ФайлОбъект . Редактирует = Справочники . Пользователи . ПустаяСсылка(); ФайлОбъект . Записать(); Аналогичным образом , можно воспользоваться методом глобального контекста ЗаблокироватьДанныеДляРедактирования: ФайлОбъект = ДанныеФайла . Ссылка . ПолучитьОбъект(); // Выполнить блокировку объекта от изменения другими режимами // или пользователями; в случае блокировки ­ // вывести пользователю сообщение об исключении . ЗаблокироватьДанныеДляРедактирования(ДанныеФайла . Ссылка); // Затем изменить и записать объект ФайлОбъект . Редактирует = Справочники . Пользователи . ПустаяСсылка(); ФайлОбъект . Записать(); Пример № 2 . Требуется пропустить обработку объекта , если он заблокирован для редактирования . При очередном вызове процедуры (например , из фонового или регламентного задания) будет предпринята повторная попытка изменения объекта . Объект = ТекущаяВерсия . ПолучитьОбъект(); // Выполнить блокировку объекта от изменения другими режимами // или пользователями УстановитьПолноеНаименование = Истина; Попытка ФайлОбъект . Заблокировать(); Исключение // в случае блокировки ­ не выполнять изменение объекта УстановитьПолноеНаименование = Ложь; // записать предупреждение в журнал регистрации ЗаписьЖурналаРегистрации(НСтр( " ru = ' Фоновое обновление имен файлов ' " , Метаданные . ОсновнойЯзык . КодЯзыка) , УровеньЖурналаРегистрации . Предупреждение , , ФайлОбъект , ОписаниеОшибки()); КонецПопытки; // Пропустить обработку объекта , если он заблокирован . Если УстановитьПолноеНаименование Тогда Объект . ПолноеНаименование = ПолноеНаименование; Объект . Записать(); КонецЕсли; 1 . 3 . При редактировании данных в формах , платформа 1С:Предприятие автоматически устанавливает блокировку объекта , указанного в качестве основного реквизита формы .
- 2 . Не следует проверять блокировку объектов для редактирования в следующих случаях:
- при выполнении отдельных операций , имеющих по логике работы больший приоритет по сравнению с интерактивными действиями пользователя . Например , загрузка данных при обмене;
- при действиях , которые гарантированно выполняются в монопольном режиме . Например , в процедурах обновления и первоначального заполнения данных информационной базы .

## Использование транзакций при чтении данных

- 1 . Общие рекомендации по использованию транзакций .
- 2 . Выбор: исключительная или разделяемая блокировка .
- 3 . Избегать длинных транзакций .
- 1 . Общие рекомендации по использованию транзакций .

Область применения (уточнение): управляемое приложение , обычное приложение .

- 1 . 1 . Если чтение данных из информационной базы должно быть ответственным , следует производить такое чтение в транзакции с предварительной установкой управляемых блокировок . В общем случае , ответственным следует считать любое чтение , на основе результатов которого производятся какие ­ либо изменения в информационной базе или принимаются решения .

Например , ответственное чтение данных требуется в следующих случаях:

- Чтение данных при проведении , для последующего формирования движений;
- Чтение данных для последующей целостной передачи в другую систему , например в программы типа «Клиент банк»;
- Выполнение групповой обработки объектов , при реструктуризации данных в обработчиках отложенного и оперативного обновления ИБ ( * )
* Примечание: перед модификацией ссылочных объектов , обычно , следует устанавливать на них пессимистичные объектные блокировки .

## Неправильно:

```
// 1 . Прочитать регистр сведений Запрос = Новый Запрос( " ВЫБРАТЬ РАЗРЕШЕННЫЕ | ЗаметкиПоПредмету . КоличествоЗаметок КАК КоличествоЗаметок |ИЗ | РегистрСведений . ЗаметкиПоПредмету КАК ЗаметкиПоПредмету |ГДЕ | ЗаметкиПоПредмету . Предмет = &Предмет " ); Запрос . УстановитьПараметр( " Предмет " , ПредметЗаметок); Выборка = Запрос . Выполнить() . Выбрать(); КоличествоЗаметок = 0; Если Выборка . Следующий() Тогда КоличествоЗаметок = Выборка . КоличествоЗаметок; КонецЕсли;
```

```
// 2 . Записать в регистр сведений НаборЗаписей = РегистрыСведений . ЗаметкиПоПредмету . СоздатьНаборЗаписей(); НаборЗаписей . Отбор . Предмет . Установить(ПредметЗаметок); НоваяЗапись = НаборЗаписей . Добавить(); НоваяЗапись . Предмет = ПредметЗаметок; НоваяЗапись . КоличествоЗаметок = КоличествоЗаметок + 1; НаборЗаписей . Записать(); Правильно: // 1 . Начать транзакцию для пакета из двух операций чтения и записи регистра НачатьТранзакцию(); Попытка // 2 . Установить исключительную блокировку на интересующий диапазон записей регистра , // для того чтобы гарантировать , что в момент записи количество заметок не изменилось с момента чтения в каком ­ либо другом сеансе . БлокировкаДанных = Новый БлокировкаДанных; ЭлементБлокировкиДанных = БлокировкаДанных . Добавить( " РегистрСведений . ЗаметкиПоПредмету " ); ЭлементБлокировкиДанных . УстановитьЗначение( " Предмет " , ПредметЗаметок); ЭлементБлокировкиДанных . Режим = РежимБлокировкиДанных . Исключительный; БлокировкаДанных . Заблокировать(); // 3 . Прочитать регистр сведений Запрос = Новый Запрос( " ВЫБРАТЬ РАЗРЕШЕННЫЕ | ЗаметкиПоПредмету . КоличествоЗаметок КАК КоличествоЗаметок |ИЗ | РегистрСведений . ЗаметкиПоПредмету КАК ЗаметкиПоПредмету |ГДЕ | ЗаметкиПоПредмету . Предмет = &Предмет " ); Запрос . УстановитьПараметр( " Предмет " , ПредметЗаметок); Выборка = Запрос . Выполнить() . Выбрать(); КоличествоЗаметок = 0; Если Выборка . Следующий() Тогда КоличествоЗаметок = Выборка . КоличествоЗаметок; КонецЕсли; // 4 . Записать в регистр сведений НаборЗаписей =
```

```
РегистрыСведений . ЗаметкиПоПредмету . СоздатьНаборЗаписей(); НаборЗаписей . Отбор . Предмет . Установить(ПредметЗаметок); НоваяЗапись = НаборЗаписей . Добавить(); НоваяЗапись . Предмет = ПредметЗаметок; НоваяЗапись . КоличествоЗаметок = КоличествоЗаметок + 1; НаборЗаписей . Записать(); ЗафиксироватьТранзакцию(); Исключение // 5 . Если при установке блокировки возникла исключительная ситуация из ­ за того , что регистр уже заблокирован в другом сеансе (или по другим причинам) , // отменить транзакцию и записать сведения об ошибке в журнал регистрации . ОтменитьТранзакцию(); ЗаписьЖурналаРегистрации(НСтр( " ru = ' Заметки ' " ) , УровеньЖурналаРегистрации . Ошибка , , , ПодробноеПредставлениеОшибки(ИнформацияОбОшибке())); ВызватьИсключение; КонецПопытки;
```

В некоторых случаях , ответственное чтение не требуется в силу решаемой прикладной задачи , например:

- Получение данных динамическими списками;
- Поиск данных;
- Формирование большинства отчетов .

В некоторых случаях , ответственное чтение не требуется , так как конкурентная работа с данными маловероятна или полностью исключена , например:

- Обращение к условно постоянной информации . Например , чтение константы ВалютаРегламентированногоУчета или обращение к учетной политике;
- Действия , которые гарантированно выполняются в монопольном режиме . Например , в процедурах обновления и первоначального заполнения данных информационной базы;
- Действия над данными , доступ к которым имеет только один пользователь , поэтому конкурентная работа с ними маловероятна или полностью исключена . Например , персональные данные , хранящиеся в «разрезе» пользователей;
- Мобильное приложение , где конкурентная работа с данными маловероятна или полностью исключена .
- 1 . 2 . В большинстве случаев , при выполнении чтения в обработчиках событий связанных с модификацией данных , весь код обработчика выполняется в рамках системной транзакции , которая открыта платформой , и явно открывать новую транзакцию не требуется .

Например , в системной транзакции выполняются обработчики модулей объектов и соответствующие им подписки на события:

- ПередЗаписью;
- ПриЗаписи;
- ПередУдалением .

Подробнее – см . документацию к платформе 1С:Предприятие .

Область применения (уточнение): управляемое приложение , обычное приложение .

- 2 . Выбор: исключительная или разделяемая блокировка .
- 2 . 1 . Если в транзакции производится ответственное чтение данных с их последующим изменением , необходимо установить исключительную управляемую блокировку (до выполнения чтения) . В противном случае возможно возникновение взаимоблокировки .

Пример установки исключительной блокировки (без открытия транзакции – в предположении , что ранее уже была открыта системная транзакция):

```
// 1 . Установить исключительную блокировку для ответственного чтения объекта с целью его дальнейшего изменения Блокировка = Новый БлокировкаДанных; ЭлементБлокировки = Блокировка . Добавить( " Справочник . Приказы " ); ЭлементБлокировки . УстановитьЗначение( " Ссылка " , ПриказСсылка); ЭлементБлокировки . Режим = РежимБлокировкиДанных . Исключительный; // Можно не указывать , т . к . по умолчанию Исключительный Блокировка . Заблокировать(); // 2 . Получить объект для его дальнейшей модификации Объект = ПриказСсылка . ПолучитьОбъект(); // Выполнить блокировку объекта от изменения другими режимами или пользователями Объект . Заблокировать(); Объект . Реквизит = . . . // 3 . Записать измененный объект Объект . Записать();
```

- 2 . 2 . Если в транзакции производится ответственное чтение данных без их последующего изменения (например , для формирования движений) , необходимо установить разделяемую блокировку на читаемые данные и исключительную блокировку на изменяемые данные .

Пример установки разделяемой блокировки (без открытия транзакции – в предположении , что ранее уже была открыта системная транзакция):

```
// 1 . Установить разделяемую блокировку для ответственного чтения нескольких связанных объектов
```

```
Блокировка = Новый БлокировкаДанных; ЭлементБлокировки = Блокировка . Добавить( " Справочник . Приказы " ); ЭлементБлокировки . УстановитьЗначение( " Ссылка " , ПриказСсылка); ЭлементБлокировки . Режим = РежимБлокировкиДанных . Разделяемый; Блокировка . Заблокировать(); // 2 . Прочитать первый объект ­ приказ ПриказОбъект = ПриказСсылка . ПолучитьОбъект(); // 3 . Прочитать второй объект – пользователя (автора приказа) АвторПриказа = ПриказОбъект . Автор . ПолучитьОбъект();
```

## 3 . Избегать длинных транзакций .

- 3 . 1 . Следует избегать длительных транзакций , которые выполняются длительное время . Чем дольше выполняется транзакция , тем большее время будут заняты ресурсы сервера 1С:Предприятия и СУБД , которые всегда ограничены и не могут эффективно использоваться для выполнения других задач .

Как правило , длинные транзакции отнимают на себя следующие ресурсы:

- В ходе выполнения транзакции все изменения в базе данных записываются в журнал транзакций , что необходимо для возможности откатить транзакцию .
- Блокировки , установленные в транзакции , остаются до конца транзакции (кроме разделяемых блокировок при чтении в блокировочных СУБД) .
- На блокировочных СУБД , а также на сервере 1С:Предприятия блокировки занимают оперативную память;
- И другие ресурсы , необходимые самой бизнес­логике , которая выполняется в транзакции .
- 3 . 2 . Длинные транзакции можно сократить за счет методов оптимизации запросов (см . статьи раздела «Оптимизация запросов») .

В отдельных случаях также рекомендуется разделять длинные транзакции на более мелкие порции , в пределах которых обеспечивается приемлемая целостность данных .

## См . также

- Общие сведения об избыточных блокировках
- Обработка исключений при использовании транзакций
- Блокирующее чтение остатков в начале транзакции

## Чтение отдельных реквизитов объекта из базы данных

При чтении отдельных реквизитов объекта из базы данных следует иметь в виду , что вызов метода ПолучитьОбъект или обращение к реквизитам объекта через точку от ссылки приводит к загрузке объекта из базы целиком , вместе с его табличными частями .

Поэтому для чтения значений отдельных реквизитов из базы данных следует использовать запрос . Например , неправильно:

```
Процедура ЗаполнитьКодИНаименованиеСтраны() СтранаСсылка = … // получаем ссылку на элемент справочника КодСтраны = СтранаСсылка . Код; // первое обращение загружает объект целиком НаименованиеСтраны = СтранаСсылка . Наименование; КонецПроцедуры правильно:
```

```
Процедура ЗаполнитьКодИНаименованиеСтраны() Запрос = Новый Запрос( " ВЫБРАТЬ | СтраныМира . Код , | СтраныМира . Наименование |ИЗ | Справочник . СтраныМира КАК СтраныМира |ГДЕ | СтраныМира . Ссылка = &Ссылка " ); Запрос . УстановитьПараметр( " Ссылка " , Ссылка); Выборка = Запрос . Выполнить() . Выбрать(); Выборка . Следующий(); КодСтраны = Выборка . Код; НаименованиеСтраны = Выборка . Наименование;
```

## КонецПроцедуры

Для упрощения синтаксиса рекомендуется также использовать специальные функции ЗначенияРеквизитовОбъекта или ЗначениеРеквизитаОбъекта (входят в состав Библиотеки стандартных подсистем) . В этом случае исходный пример будет выглядеть так:

```
Процедура ЗаполнитьКодИНаименованиеСтраны()
```

<!-- image -->

## Запись событий в историю работы пользователя

В историю работы автоматически попадают события интерактивного добавления или изменения объектов информационной базы (документов , элементов справочника и пр . ) Дополнительно рекомендуется записывать в историю работы пользователя и другие события , которые приводят к записи объектов в результате действий пользователя . Например: команда «Поместить файл» для элемента справочника Файлы .

Для добавления событий в историю работы пользователя предназначен объект ИсторияРаботыПользователя типа МенеджерИсторииРаботыПользователя . Пример:

```
&НаКлиенте Процедура ПоместитьФайл(Команда) // Поместить файл в базу // … // И добавить событие в историю работы пользователя
```

```
ИсторияРаботыПользователя . Добавить(ПолучитьНавигационнуюСсылку(Объект . Ссылка)); КонецПроцедуры
```

## Общие сведения об избыточных блокировках

Методическая рекомендация (полезный совет)

- 1 . Проектные ошибки при выборе и проектировании структуры того или иного объекта метаданных для реализации прикладной функциональности , могут привести к большому количеству избыточных блокировок и как следствие к серьезному падению общей производительности системы .

Ожидание на блокировке данных происходит в том случае , если две различные сессии 1С:Предприятия пытаются захватить один и тот же ресурс . При работе с разными ресурсами ожидание на блокировке не происходит . В данном контексте термин «ресурс» используется в качестве обозначения неделимой совокупности данных , которая блокируется (или не блокируется) только вся целиком .

Таким образом , вопрос сводится к тому , какие именно ресурсы захватываются при выполнении того или иного действия с данными . Или , иначе говоря , насколько «мелко нарезаны» данные 1С:Предприятия .

При анализе структуры метаданных следует обратить внимание на следующие объекты:

- Константы
- Последовательность
- Регистры бухгалтерии
- Регистры накопления

См . также Блокирующее чтение остатков в начале транзакции, и, Использование управляемого режима блокировки

- 2 . Неоптимальная работа запроса может влиять как на скорость работы данного запроса , так и на производительность работы других пользователей . Это связано с тем , что при неоптимальной работе запроса блокируются избыточные данные , в результате чего другие пользователи не могут выполнять свои запросы к этим данным из ­ за ожиданий на блокировках .

Эта причина возникновения избыточных блокировок в многопользовательской системе является наиболее часто встречающейся . Поэтому , первое , что следует сделать –

проанализировать запросы , которые выполняются в проблемной строке кода и при необходимости оптимизировать их .

## См . также

Несоответствие индексов

и условий запроса

Разыменование ссылочных полей составного типа

запросов

Запросы

,

выполняющие соединение с вложенными

запросами

или

виртуальными таблицами

Использование вложенных запросов

Фильтрация

параметров

- Ограничение на использование логического ИЛИ в условиях запросов

в условии соединения

виртуальных таблиц без использования

в языке

## Сдвиг границы последовательности документов

Не рекомендуется двигать границу последовательности при проведении документов . Это может привести к возникновению ожиданий на блокировках и снижению общей производительности системы . Операцию движения границы последовательности следует вынести из оперативных операций в регламентные , например выполнять регламентной обработкой с заданной частотой .

Граница последовательности по одному набору значений измерений является одним ресурсом . Это означает , что при движении границы последовательности по одному набору значений измерений разные пользователи будут пытаться захватить один и тот же ресурс , то есть будут блокировать друг друга .

## Пример

В системе , построенной на базе УПП версий 1 . х , используется учетная политика , предполагающая вычисление себестоимости списываемых товаров в оперативном режиме (непосредственно в момент списания) .

<!-- image -->

Алгоритмы партионного учета в УПП используют последовательность «Партионный учет» , имеющую одно измерение: Организация .

Для вычисления себестоимости списываемых товаров при проведении расходного документа необходимо переместить границу последовательности для данной организации на момент времени проводимого документа .

Если два пользователя будут одновременно проводить расходные документы по одной организации (что весьма вероятно) , то они будут блокировать друг друга . Такое поведение системы не является особенностью реализации последовательностей в 1С:Предприятии , но продиктовано требованиями самого алгоритма – необходимо знать точную последовательность расположения документов . То есть все конкурирующие по времени (одновременно проводящиеся) документы должны выстроиться друг за другом .

Движение границы последовательности при оперативном проведении документов способно значительно снизить общую производительности системы . В данном случае правильным решением было бы выключение этого флажка , то есть отказ от оперативного расчета себестоимости при проведении документов . Вместо этого следует использовать регламентную обработку , входящую в состав УПП , которая будет вычислять себестоимость с некоторой заданной частотой .

## См . также

- «Общие сведения об избыточных блокировках»

## Режим разделения итогов для регистров бухгалтерии

1 . Если в системе осуществляется оперативная запись движений по бухгалтерскому регистру в многопользовательском режиме , то рекомендуется включить для данного регистра режим разделения итогов . При включенном режиме разделения итогов пользователи смогут параллельно обновлять таблицу остатков даже в том случае , если у них совпадает период , счет и значения измерений .

В противном случае таблица остатков регистра бухгалтерии может стать узким местом при конкурентной работе большого количества пользователей .

См . также Блокирующее чтение остатков в начале транзакции

## Пример 1

В конфигурации определен регистр Хозрасчетный с измерениями Организация и Валюта .

<!-- image -->

При этом запрещено разделение итогов регистра:

<!-- image -->

Предположим , что два пользователя одновременно проводят документы , которые осуществляют движение по данному регистру . Пользователи будут блокировать друг друга в том случае , если движения:

- относятся к одному и тому же периоду;
- относятся к одному и тому же счету;
- имеют одинаковые значения измерений , то есть организацию и валюту .

В реальной жизни одновременное выполнение перечисленных условий является весьма вероятным , поскольку большинство пользователей будет работать в одном периоде , с одним счетом и с одинаковыми значениями измерений (организация и валюта) . Это может привести к возникновению ожиданий на блокировках и снижению общей производительности системы .

Для решения этой проблемы следует включить режим разделения итогов (см . следующий пример) .

## Пример 2

Если для этого же регистра разрешить и включить режим разделения итогов , изменится .

то ситуация

Разрешим режим разделения итогов (в режиме конфигурирования):

<!-- image -->

Включим режим разделения итогов (в режиме 1С:Предприятия):

<!-- image -->

После этого конкурирующие пользователи смогут параллельно записывать движения по регистру даже в том случае , если совпадают период , номер счета и значения всех измерений . Однако , если при этом осуществляется контроль остатков по данному регистру , то эффекта от включения режима разделения не будет .

## См . также

- Устройство и использование режима разделения итогов регистров (статья на ИТС)
- Эффективное обращение к виртуальной таблице «Остатки»

## Режим разделения итогов для регистров накопления

- 1 . При проектировании регистра накопления следует помнить , что остатки по одному набору измерений хранятся в одном ресурсе регистра . То есть , степень параллельности при работе с регистром фактически зависит от состава его измерений . Состав измерений необходимо подбирать в соответствии с тем , насколько мелко должны быть «нарезаны» остатки , исходя из прикладной функциональности системы .
- 2 . В том случае , если состав измерений не позволяет обеспечить необходимую параллельность при работе с регистром , рекомендуется использовать режим разделения итогов аналогично регистрам бухгалтерии . Следует учитывать , что режим разделения итогов не обеспечит параллельность при контроле остатков по регистру . Если контроль остатков необходим , то следует перенести его как можно ближе к концу транзакции .

Рассмотрим в качестве примера регистр накопления ТоварыНаСкладах со следующим составом измерений:

<!-- image -->

## Пример 1

Предположим два пользователя одновременно проводят документы , которые записывают движения в данный регистр накопления . При этом первый

пользователь пишет следующий набор записей:

<!-- image -->

|    | № Склад        | Номенклатура                  |
|----|----------------|-------------------------------|
|  1 | Основной склад | Кресло ­ качалка              |
|  2 | Основной склад | Кухонный гарнитур " Тинга­2 " |
|  3 | Склад №2       | Мебельный гарнитур " Торэ "   |

Второй пользователь пишет в этот же регистр следующий набор записей:

<!-- image -->

|    | № Склад        | Номенклатура                |
|----|----------------|-----------------------------|
|  1 | Основной склад | Мебельный гарнитур " Торэ " |
|  2 | Склад №2       | Кресло­качалка              |

Эти наборы записей не содержат строк , совпадающих по значениям всех измерений , поэтому ожидание на блокировке в данном случае не возникнет .

## Пример 2

Предположим , что второй пользователь записывает следующий набор записей

<!-- image -->

|    | № Склад        | Номенклатура                  |
|----|----------------|-------------------------------|
|  1 | Основной склад | Кухонный гарнитур " Тинга­2 " |
|  2 | Склад №2       | Кресло­качалка                |
|  3 | Оптовый склад  | Спальный гарнитур " Инга­М "  |

Этот набор записей содержит строку (№1) , совпадающую по значениям всех измерений со строкой набора записей первого пользователя (№2) .

В этом случае возникнет ожидание на блокировке и один из пользователей будет дожидаться окончания операции другого пользователя , то есть общая производительность системы снизится .

Регистр накопления также поддерживает режим разделения итогов , который позволит в данной ситуации избежать блокировки (см . Пример 3) .

## Пример 3

Если для данного регистра накопления включен режим разделения итогов , то будет возможна параллельная запись двух наборов , даже в том случае если

они содержат одинаковые (по значениям

измерений) строки

.

Однако , если при этом используется контроль остатков , то режим разделения итогов не даст положительного эффекта . Иначе говоря , режим разделения итогов для регистра накопления работает аналогично регистру бухгалтерии . Для снижения влияния этой блокировки на общую производительность системы нужно перенести контроль остатков как можно ближе к концу транзакции .

## См . также

- Устройство и использование режима разделения итогов регистров (статья на ИТС)
- Эффективное обращение к виртуальной таблице «Остатки»

## Блокирующее чтение остатков в начале транзакции

1 . 1 В ряде случаев необходимо выполнять блокирующее чтение итогов . Примером такой задачи является контроль остатков при проведении документа . Если в результате проведения документа остатки станут отрицательными , то транзакция должна быть отменена (проводить такой документ нельзя) .

- 1 . 2 Операция чтения остатков должна быть блокирующей , то есть необходимо запретить двум пользователям одновременно читать один и тот же остаток за период , счет и значение измерения .

Если чтение будет неблокирующим , то возможна ситуация , при которой два пользователя одновременно прочитают один и тот же остаток (например 10 единиц) и примут решение о возможности списания части этого остатка . Если сумма списаний двух пользователей будет больше 10 , то в итоге остаток получится отрицательным .

Например , первый пользователь спишет 8 единиц (8 меньше 10 , следовательно операция разрешена) , а второй пользователь спишет 6 единиц (на таком же основании) . Результатом будет ­4 единицы остатка , что недопустимо с точки зрения прикладной логики системы .

- 2 . Обычно , для контроля остатков используется запрос в модуле набора записей регистра , который идет перед записью набора . При этом возможны следующие проблемы:
- Разработчик , как правило , не контролирует порядок записи движений в разные регистры ­ запись обычно осуществляется автоматически платформой 1С:Предприятия . Запрос контроля остатков реализуется в модуле набора записей и вызывается при записи движений регистра . Если этот регистр будет записываться в начале транзакции (например , первым) , то установленная блокировка будет мешать работе других пользователей в течение длительного периода времени (пока будут записываться все остальные регистры) , и ее влияние на производительность системы может оказаться неоправданно большим .
- В некоторых случаях , возможно , нет необходимости в контроле остатков , поскольку записываемые движения заведомо не могут привести к получению отрицательных остатков .

Для того чтобы минимизировать влияние блокирующего чтения остатков на производительность системы , необходимо:

- Проанализировать , какие именно остатки нуждаются в блокирующем чтении и при каких обстоятельствах . Например , контроль остатков не требуется при проведении приходного документа , поскольку он может только увеличить остатки . Так же не требуется контролировать остатки
- при перепроведении документа , который списывает в этот раз не больше остатков чем при первом проведении (этот контроль уже проводился) . И так далее .
- В начале транзакции (например , в обработчике ОбработкаПроведения документа) в явном виде записать движения по всем регистрам , которые в данном случае не требуют контроля остатков . Следует всегда придерживаться одинакового порядка записи регистров (например , алфавитного) . Необходимо обратить внимание на то , что у всех записываемых регистров накопления и бухгалтерии должен быть включен разделитель итогов , а у наборов записей свойство БлокироватьДляИзменения должна быть установлена в значение Ложь .
- Выполнить все остальные действия , которые должны быть выполнены в рамках этой транзакции .
- В самом конце транзакции в явном виде записать движения по тем регистрам , которые требуют контроля остатков . Для наборов записей этих регистров следует установить опцию БлокироватьДляИзменения в значение Истина . Это необходимо для предотвращения взаимоблокировки . Именно в этот момент времени будет установлена блокировка остатков регистра по данному набору значений измерений .
- Для каждого регистра выполнить запрос контроля остатков . Следует обратить внимание , что в данном случае нет необходимости использовать явную управляемую блокировку (опцию ДЛЯ ИЗМЕНЕНИЯ ­ в автоматическом режиме) , поскольку проверяемые остатки уже заблокированы их записью на предыдущем шаге . Запрос должен считывать только отрицательные остатки по заданному набору значений измерений . Если такие записи имеются , то транзакция должна быть отменена . Если запрос вернул пустой результат , то транзакция должна быть зафиксирована .

## Пример

В процедуре ПередЗаписью модуля набора записей регистра бухгалтерии Хозрасчетный выполняется следующий запрос:

```
Запрос . Текст = " ВЫБРАТЬ | СуммаОстаток , | СуммаОстатокДт , | СуммаОстатокКт |ИЗ | РегистрБухгалтерии . Хозрасчетный . Остатки(&Период , &Счет , , Организация = &Организация) " ;
```

При выполнении этого запроса будут прочитаны (и заблокированы от записи) остатки по указанному условию для всех пользовательских подключений . То есть , разные ресурсы (созданные режимом разделения итогов) будут как бы объединены в один . По этой причине параллельность останется такой же , как если бы режим разделения итогов не был включен .

Для того чтобы минимизировать влияние этой блокировки на общую производительность системы , рекомендуется перенести ее как можно ближе к концу транзакции . Например , можно вынести эту проверку в модуль документа в обработчик события ПриПроведении после записи (в явном виде) всех движений по всем регистрам .

## См . также

- Использование транзакций при чтении данных
- Регистры бухгалтерии

## Тексты модулей

- 1 . Тексты модулей должны быть написаны на русском языке . В текстах модулях не допускается использовать букву " ё " .

Исключения составляют интерфейсные тексты , выводимые пользователю в сообщениях , формах и справке , где употребление буквы «ё» в ряде случаев допустимо . Подробнее см . Тексты .

Методическая рекомендация (полезный совет)

- 2 . Программные модули не должны иметь неиспользуемых процедур и функций .
- 3 . Программные модули не должны иметь закомментированных фрагментов кода , а также фрагментов , которые каким ­ либо образом связаны с процессом разработки (отладочный код , служебные отметки) и с конкретными разработчиками этого кода . Например , недопустимо оставлять подобные фрагменты в коде после завершения отладки или рефакторинга:

```
Процедура ПередУдалением(Отказ) // Если Истина Тогда // Сообщение( " Для отладки " ); // КонецЕсли; КонецПроцедуры
```

## также неправильно:

```
Процедура ПередУдалением(Отказ) Если Истина Тогда // Иванов: доделать КонецЕсли; КонецПроцедуры
```

Правильно: после завершения отладки или рефакторинга удалить обработчик ПередУдалением из кода .

- 4 . Тексты модулей оформляются по принципу " один оператор в одной строке " . Наличие нескольких операторов допускается только для " однотипных " операторов присваивания , например:
- 5 . Текст модуля должен быть оформлен синтаксическим отступом . Для синтаксического отступа используется табуляция (а не пробелы , чтобы при смене числа знаков в табуляции выравнивание текста сохранялось) .

```
НачальныйИндекс = 0; Индекс = 0; Результат = 0;
```

Размер табуляции ­ стандартный (4 символа) .

- 5 . 1 . С крайней левой позиции должны начинаться только:
- операторы Процедура , КонецПроцедуры , Функция , КонецФункции;
- операторы предварительного объявления процедур и функций;
- заголовки (описания) процедур и функций;
- объявление переменных модуля;
- операторы " раздела основной программы " (с учетом синтаксического отступа);
- директивы компилятора &amp;НаКлиенте , &amp;НаСервере и т . д .
- инструкции препроцессора (в т . ч . #Область и #КонецОбласти)
- 5 . 2 . Процедуры НачатьТранзакцию и ЗафиксироватьТранзакцию не являются операторными скобками , поэтому текст внутри этих процедур не сдвигается .
- 6 . При длине строки более 120 символов следует использовать переносы . Строки длиннее 120 символов делать не рекомендуется , за исключением тех случаев , когда перенос невозможен (например , в коде определена длинная строковая константа , которая выводится без переносов в окно сообщений с помощью объекта СообщениеПользователю) .

См . также: Перенос выражений .

- 7 . 1 . Тексты модулей могут содержать комментарии . Комментарии должны быть достаточно понятными , чтобы пояснять работу модуля или комментируемого оператора . Тексты комментариев должны составляться по правилам русского языка , в деловом стиле , быть эмоционально сдержанными и не содержать слов , не относящихся к функциональности программы .
- 7 . 2 . Небольшие комментарии пишутся в конце строки , которую комментируют , например:

```
НайденныеОшибки . Колонки . Добавить( " Номер " ); // для совместимости
```

Большие комментарии или комментарии к фрагменту кода пишутся перед комментируемым кодом в отдельной строке .

- 7 . 3 . Большие комментарии должны начинаться с большой буквы и заканчиваться точкой . Текст выравнивается по левой границе комментируемого фрагмента . Между символами комментария " // " и текстом комментария должен быть пробел .
- 7 . 4 . Тексты больших процедур и фукнций можно разбивать на отдельные сворачиваемые области . При этом имена областей должны удовлетворять требованиям стандарта Правила образования имен переменных

```
// Инициализируем переменные для выполнения расчетов , // которые выполняются далее по тексту модуля . ТекущаяДата = ОбщегоНазначения . ПолучитьРабочуюДату(); ТекущийГод = Год(ТекущаяДата); ТекущийМесяц = Месяц(ТекущаяДата);
```

<!-- image -->

Для автоматического форматирования кода можно воспользоваться приложенной обработкой .

## См . также

- Правила создания общих модулей
- Структура модуля

## Структура модуля

1 . 1 . В программном модуле (общие модули , модули объектов , модули менеджеров объектов , модули форм , команд и т . п . ) в общем случае могут присутствовать следующие разделы в приведенной ниже последовательности:

- заголовок модуля
- раздел описания переменных
- экспортные процедуры и функции модуля , составляющие его программный интерфейс
- обработчики событий объекта (формы)
- служебные процедуры и функции модуля
- раздел инициализации

Некоторые разделы могут присутствовать только в модулях определенного вида . Например , обработчики событий элементов форм могут присутствовать только в модулях форм , а раздел описания переменных и раздел инициализации не могут быть определены в неглобальных общих модулях , модулях менеджеров объектов , наборов записей , значений констант и модуле сеанса .

Требование о разделении кода модуля на разделы призвано повысить читаемость кода и упростить внесение изменений в код разными авторами (разработчиками) как при коллективной разработке , так и при доработке прикладных решений на конкретных внедрениях .

- 1 . 2 . Объемные разделы модулей рекомендуется разбивать на подразделы по функциональному признаку .
- 1 . 3 . Разделы и подразделы оформляются в виде областей . При этом имена областей должны удовлетворять требованиям стандарта Правила образования имен переменных
- 1 . 4 . Шаблон (заготовка для копирования) разделов для общих модулей:

////////////////////////////////////////////////////////////////////////////////

//

&lt;Заголовок модуля: краткое описание и условия применения модуля . &gt;

//

////////////////////////////////////////////////////////////////////////////////

#Область

ПрограммныйИнтерфейс

//Код

процедур

функций

#КонецОбласти

#Область СлужебныеПроцедурыИФункции //Код процедур и функций #КонецОбласти

- Раздел «Программный интерфейс» содержит экспортные процедуры и функции , предназначенные для использования другими объектами конфигурации или другими программами (например , через внешнее соединение) .
- Раздел «Служебные процедуры и функции» содержит процедуры и функции , составляющие внутреннюю реализацию общего модуля . В тех случаях , когда общий модуль является частью некоторой функциональной подсистемы , включающей в себя несколько объектов метаданных , в этом разделе также могут быть размещены служебные экспортные процедуры и функции , предназначенные только для вызова из других объектов данной подсистемы .

Для объемных общих модулей рекомендуется разбивать этот раздел на подразделы , по функциональному признаку . Например:

и

<!-- image -->

- 1 . 5 . Шаблон оформления разделов для модулей объектов , менеджеров , наборов записей , обработок , отчетов и т . п . :

#Область

ПрограммныйИнтерфейс

//Код

процедур

функций

#КонецОбласти

#Область

ОбработчикиСобытий

//Код

процедур

и

функций

#КонецОбласти

#Область

СлужебныеПроцедурыИФункции

//Код

процедур

функций

#КонецОбласти

- Раздел «Программный интерфейс» содержит экспортные процедуры и функции , предназначенные для использования в других модулях конфигурации или другими программами (например , через внешнее соединение) . Не следует в этот раздел помещать экспортные функции и процедуры , которые предназначены для вызова исключительно из модулей самого объекта , его форм и команд . Например , процедуры заполнения табличной части документа , которые вызываются из обработки заполнения в модуле объекта и из формы документа в обработчике команды формы не являются программным интерфейсом модуля объекта , т . к . вызываются только в самом модуле и из форм этого же объекта . Их следует размещать в разделе «Служебные процедуры и функции» .
- Раздел «Обработчики событий» содержит обработчики событий модуля объекта (ПриЗаписи , ПриПроведении и др . )
- Раздел «Служебные процедуры и функции» имеет такое же предназначение , как и в общих модулях .
- 1 . 6 . Шаблон оформления разделов для модулей форм:
- Раздел «Обработчики событий формы» содержит процедуры­обработчики событий формы: ПриСозданииНаСервере , ПриОткрытии и т . п .

```
#Область ОбработчикиСобытийФормы //Код процедур и функций #КонецОбласти #Область ОбработчикиСобытийЭлементовШапкиФормы //Код процедур и функций #КонецОбласти #Область ОбработчикиСобытийЭлементовТаблицыФормы<ИмяТаблицыФормы> //Код процедур и функций #КонецОбласти #Область ОбработчикиКомандФормы //Код процедур и функций #КонецОбласти #Область СлужебныеПроцедурыИФункции //Код процедур и функций #КонецОбласти
```

и

и

- Раздел «Обработчики событий элементов шапки формы» содержит процедурыобработчики элементов , расположенных в основной части формы (все , что не связано с таблицами на форме) .
- В разделах «Обработчики событий элементов таблицы формы &lt;имя таблицы формы&gt;» размещаются процедуры­обработчики таблиц формы и элементов таблиц . Для процедур ­ обработчиков каждой таблицы должен быть создан свой раздел .
- Раздел «Обработчики команд формы» содержит процедуры­обработчики команд формы (имена которых задаются в свойстве Действие команд формы) .
- Раздел «Служебные процедуры и функции» имеет такое же предназначение , что и в общих модулях .

См . также: Правила создания модулей форм

- 1 . 7 . Шаблон оформления разделов для модулей команд:
- Раздел «Обработчики событий» содержит процедуру­обработчик команды ОбработкаКоманды .
- Раздел «Служебные процедуры и функции» имеет такое же предназначение , что и в общих модулях .
- 2 . Общие требования к разделам программных модулей .
- 2 . 1 . Заголовок модуля представляет собой комментарий в самом начале модуля . В заголовке модуля приводится его краткое описание и условия применения . Например:

```
#Область ОбработчикиСобытий //Код процедур и функций #КонецОбласти #Область СлужебныеПроцедурыИФункции //Код процедур и функций #КонецОбласти
```

```
//////////////////////////////////////////////////////////////////////////////// // Клиентские процедуры и функции общего назначения: // ­ для работы со списками в формах; // ­ для работы с журналом регистрации; // ­ для обработки действий пользователя в процессе редактирования // многострочного текста , например комментария в документах; // ­ прочее . // ////////////////////////////////////////////////////////////////////////////////
```

Для модулей форм в заголовке рекомендуется размещать описание параметров формы .

- 2 . 2 . Раздел описания переменных . Имена переменных назначаются согласно общим правилам образования имен переменных , а их использование описывается в статье Использование глобальных переменных в программных модулях .

Все переменные модуля должны быть снабжены комментарием , достаточным для понимания их назначения . Комментарий рекомендуется размещать в той же строке , где объявляется переменная .

## Пример:

```
#Область ОписаниеПеременных Перем ВалютаУчета; // Валюта , в которой ведется управленческий учет . Перем АдресПоддержки; // Адрес электронной почты , куда направляются сообщения
```

<!-- image -->

- 2 . 3 . Программный интерфейс . Экспортные процедуры и функции , составляющие его программный интерфейс , размещаются сразу же после описания переменных . Такие процедуры и функции предназначены для использования другими объектами конфигурации или другими программами (например , через внешнее соединение) , поэтому должны быть расположены в модуле на " видном месте " .

См . также: Описание процедур и функций

- 2 . 4 . 1 Обработчики событий формы , команд и элементов формы . Перед служебными процедурами и функциями в модуле формы располагаются обработчики событий формы , а также обработчики событий команд и элементов формы .

Методическая рекомендация (полезный совет)

Рекомендуется обработчики одного элемента формы располагать вместе , придерживаясь , при этом , порядка их следования в панели свойств редактора формы в конфигураторе .

- 2 . 4 . 2 . У каждого события должна быть назначена своя процедура­обработчик . Если одинаковые действия должны выполняться при возникновении событий в разных элементах формы следует:
- создать отдельную процедуру (функцию) , выполняющую необходимые действия
- для каждого элемента формы создать отдельный обработчик с именем , назначаемым по умолчанию
- из каждого обработчика вызвать требуемую процедуру (функцию) .

## Например , неправильно:

```
&НаКлиенте Процедура ПоИсполнителюПриИзменении(Элемент) ПараметрыОтбора = Новый Соответствие(); ПараметрыОтбора . Вставить( " ПоАвтору " , ПоАвтору); ПараметрыОтбора . Вставить( " ПоИсполнителю " , ПоИсполнителю); УстановитьОтборСписка(Список , ПараметрыОтбора); КонецПроцедуры &НаКлиенте Процедура ПоАвторуПриИзменении(Элемент) ПоИсполнителюПриИзменении(Неопределено); КонецПроцедуры правильно: &НаКлиенте Процедура ПоИсполнителюПриИзменении(Элемент) УстановитьОтбор(); КонецПроцедуры
```

```
&НаКлиенте Процедура ПоАвторуПриИзменении(Элемент) УстановитьОтбор(); КонецПроцедуры &НаСервере Процедура УстановитьОтбор() ПараметрыОтбора = Новый Соответствие(); ПараметрыОтбора . Вставить( " ПоАвтору " , ПоАвтору); ПараметрыОтбора . Вставить( " ПоИсполнителю " , ПоИсполнителю); УстановитьОтборСписка(Список , ПараметрыОтбора); КонецПроцедуры
```

Это требование обусловлено тем , что логически процедуры ­ обработчики событий не предназначены для использования в коде модуля , а вызываются непосредственно платформой . Смешение же этих двух сценариев в одной процедуре неоправданно усложняет ее логику и снижает ее устойчивость (вместо одного предусмотренного сценария вызова ­ по событию из платформы ­ код процедуры должен рассчитывать и на другие " прямые " вызовы из кода) .

- 2 . 5 . Обработчики событий модулей объекта и менеджера объекта размещаются после раздела с программным интерфейсом , но до служебных процедур и функций модуля .

Методическая рекомендация (полезный совет)

Рекомендуется располагать обработчики , придерживаясь порядка их следования в описании встроенного языка .

- 2 . 6 . Служебные процедуры и функции модуля , которые не являются обработчиками событий , а составляют внутреннюю реализацию модуля , размещаются в модуле следом за обработчиками событий .

В тех случаях когда общий модуль является частью некоторой функциональной подсистемы , включащей в себя несколько объектов метаданных , в этом разделе также могут быть размещены служебные экспортные процедуры и функции , предназначенные только для вызова из других объектов данной подсистемы .

Процедуры и функции , связанные между собой по характеру или по логике работы рекомендуется располагать вместе . Не рекомендуется явно группировать процедуры и функции модуля на серверные , клиентские и функции без контекста , так как такое «технологическое» упорядочивание затрудняет понимание логики модуля , отвлекая внимание разработчика на детали ее реализации .

- 2 . 7 . Раздел инициализации содержит операторы , инициализирующие переменные модуля или объект (форму) . Например:

```
#Область Инициализация АдресПоддержки = " v8@1c . ru " ; ВыполнитьИнициализацию(); . . . #КонецОбласти
```

Д
ляоформленияразделов кода в видеобластейвоспользуйтесьприложенной обработкой .

## Имена процедур и функций

- 1 . Правильный выбор имен процедур и функций очень важен для повышения читаемости кода . В большинстве случаев хорошо выбранное имя процедуры в сочетании с правильно подобранными именами параметров избавляют от необходимости ее как­то дополнительно описывать . В ряде случаев , сложности в выборе имени процедуры и (или) ее параметров свидетельствуют о неправильной архитектуре программного кода . И наоборот , если " самодокументирующееся " имя придумать легко , значит процедура спроектирована правильно .

См

.

также: Описание процедур и функций

- 2 . Имена процедур , функций и формальных параметров следует образовывать от терминов предметной области таким образом , чтобы из имени было понятно назначение . Следует стремиться к тому , чтобы имена были " говорящими " (документировали сами себя) .

Например

Функция

Функция

,

неправильно:

ВыполнитьПроверку(Параметр1

,

Рекв

,

ТЗ)

ПолучитьМассивыРеквизитов(ХозяйственнаяОперация

МассивВсехРеквизитов

## Правильно:

Функция

РеквизитОбъектаЗаданногоТипа(Объект

ТипЗначения)

Функция

ЗаполнитьИменаРеквизитовПоХозяйственнойОперации(ХозяйственнаяОперация

ИменаВсеРеквизиты

,

ИменаРеквизитыОперации)

- 3 . Имена следует образовывать путем удаления пробелов между словами . При этом , каждое слово в имени пишется с прописной буквы . Предлоги и местоимения из одной буквы также пишутся прописными буквами .

Методическая рекомендация (полезный совет)

Не рекомендуется

4

.

типы

в

названиях процедур и функций описывать

принимаемых параметров

и (или) возвращаемых значений

## Например , неправильно:

Функция

ПолучитьМассивРолейСПравомДобавления()

Функция

ПолучитьСтруктуруДополнительныхНастроек()

## Правильно:

Функция

ИменаРолейСПравомДобавления()

Функция

ДополнительныеНастройки()

.

,

МассивРеквизитовОперации)

,

ИмяРеквизита

,

,

,

Эта рекомендация справедлива в большинстве случаев за редким исключением , когда без описания типа возвращаемого значения не ясно назначение самой процедуры или функции .

- 5 . Имена процедур в общем случае , следует образовывать от неопределенной формы глагола , от сути выполняемого действия , например:

Неправильно:

Процедура

ЗагрузкаКонтрагента()

Правильно:

Процедура

ЗагрузитьКонтрагента()

- 6 . 1 . Имена функций в общем случае следует образовывать от описания возвращаемого значения .

Неправильно:

Функция

ПолучитьПолноеИмяПользователя()

Функция

СоздатьПараметрыЗаполненияЦенПоставщика()

Функция

ОпределитьДатуНачалаСеанса()

Правильно:

Функция

Функция

Функция

ПолноеИмяПользователя()

НовыеПараметрыЗаполненияЦенПоставщика()

ДатаНачалаСеанса()

- 6 . 2 . Если функция предназначена для создания какого­либо объекта , то рекомендуется в ее имени использовать слово " Новый " . Например , Неправильно:

Функция

Функция

ДобавитьПолеФормы()

СоздатьЭлементСправочникаФайлы()

Функция

ПолучитьТаблицуКоманд()

Правильно:

Функция

Функция

Функция

НовоеПолеФормы()

НовыйЭлементСправочникаФайлы()

НоваяТаблицаКоманд()

- 6 . 3 . Если функция выполняет проверку какого­то условия , то из ее имя рекомендуется начитать со слова " Это " или использовать причастия . Неправильно:

<!-- image -->

## Описание процедур и функций

- 1 . Описание процедур и функций рекомендуется выполнять в виде комментария к ним . Необходимость комментирования отдельных участков кода процедур и функций должна определяться разработчиком исходя из сложности и нестандартности конкретного участка кода .

При разработке на платформе 1С:Предприятие 8 . 3 текст комментария также выводится в контекстной подсказке процедур , функций и их параметров . Подробнее см . раздел «Контекстная подсказка при вводе текстов модулей» главы 27 «Инструменты разработки» в документации к платформе .

- 2 . Обязательного комментирования требуют процедуры и функции входящие в программный интерфейс модулей ­ такие процедуры и функции предназначены для использования в других функциональных подсистемах (или в других приложениях) , за которые могут отвечать другие разработчики , поэтому они должны быть хорошо документированы .

См . также: Ограничения на использование экспортных процедур и функций и Использование экспортных процедур и функций в модулях форм

Методическая рекомендация (полезный совет)

- 3 . Прочие процедуры и функции (в том числе обработчики событий модулей форм , объектов , наборов записей , менеджеров значений и т . п . ) рекомендуется комментировать , если требуется пояснить назначение процедуры (функции) или особенности её работы . Также рекомендуется описывать причины невыполнения некоторых действий , если они кажутся неочевидными для данной процедуры или функции .

Но если процедура (функция) не сложна для понимания и ее назначение и порядок работы следуют из ее названия и имен формальных параметров , комментарий допускается не писать .

- 4 . Следует избегать комментариев , не дающих дополнительных пояснений о работе не­экспортной процедуры (функции) . Например , неправильно:
- // Процедура ­ обработчик команды " Рассчитать " // &amp;НаКлиенте Процедура Рассчитать() // Процедура ­ обработчик события " ПриИзменении " элемента формы " РедактированиеТолькоВДиалоге " // &amp;НаКлиенте Процедура РедактированиеТолькоВДиалогеПриИзменении(Элемент) В этих примерах комментарии избыточны , так как из названий процедур очевидно , что это обработчики событий . А с их описанием и назначением параметров можно ознакомиться в синтакс ­ помощнике . // Функция возвращает статью движения денежных средств по данным документа Функция СтатьяДвиженияДенежныхСредств(ДанныеДокумента) Этот комментарий не дает никакой дополнительной информации о функции . 5 . Комментарий размещается перед объявлением процедуры (функции) и имеет следующий вид . 5 . 1 . Секция " Описание " содержит словесное краткое описание назначения и/или принципов работы процедуры(функции) . Может быть единственной секцией для процедур без параметров . Например: // Определяет доступность ролей ИменаРолей текущему пользователю , // а также доступность административных прав . 5 . 2 . Секция " Параметры " описывает параметры процедуры (функции) . Если их нет , секция пропускается . Предваряется строкой " Параметры: " , затем с новой строки размещаются описания всех параметров . 5 . 2 . 1 . Описание параметра начинается с новой строки , далее имя параметра , затем дефис и список типов ( * ) , далее дефис и текстовое описание параметра . Например: // Параметры: // ИменаРолей ­ Строка ­ имена ролей , доступность которых проверяется, разделенные запятыми . 5 . 2 . 2 . Для параметров типа Структура и ТаблицаЗначений также задается описание их свойств и колонок , которые начинаются с новой строки и предваряются символом * . Например:
- 5 . 2 . 3 . Также для каждого параметра можно задать одно или несколько дополнительных описаний типов параметра . Каждое дополнительное описание начинается с новой строки , затем обязательный дефис , далее список типов параметра( * ) , далее дефис и текстовое описание . Например:
- 5 . 3 . Секция " Возвращаемое значение " описывает тип и содержание возвращаемого значения функции . Для процедур эта секция отсутствует . Предваряется строкой " Возвращаемое значение: " . Затем с новой строки список типов ( * ) , далее дефис и текст . Например:

```
// Процедура ­ обработчик события " ПриОткрытии " формы // &НаКлиенте Процедура ПриОткрытии()
```

```
// Параметры: // СтатусыСерий ­ ТаблицаЗначений ­ таблица значений с колонками: // * Серия ­ СправочникСсылка . СерииНоменклатуры ­ если серия указана и она может // использоваться с новым значением номенклатуры на указанном складе, // то возвращается переданное значение; если нет ­ пустая ссылка // * СтатусУказанияСерий ­ Число ­ если серии указываются в ТЧ " Товары " , то // возвращается рассчитанный статус , если для переданной // номенклатуры/склада серии не используется ­ возвращается 0 // иначе возвращается переданный статус . // ПараметрыУказанияСерий ­ Структура ­ см . НоменклатураКлиентСервер . ПараметрыУказанияСерий
```

```
Аналогично для параметров типа Массив: // Параметры: // СведенияОбОбновлении ­ Массив ­ cодержит структуры со свойствами: // * КодАдресногоОбъекта ­ Строка ­ код адресного объекта . // * Наименование ­ Строка ­ наименование адресного объекта . // * Индекс ­ Строка ­ индекс адресного объекта . // * ОбновлениеДоступно ­ Булево ­ признак наличия обновления . // В описании массивов , структур и таблиц значений могут быть вложенные описания , при этом перед именами вложенных свойств число звездочек увеличивается: для первого уровня вложенности 2 звездочки , для второго 3 и т . д . ­
```

```
// Параметры: // СведенияОбОбновлении ­ Массив ­ cодержит структуры со свойствами: // * КодАдресногоОбъекта ­ Структура ­ код адресного объекта . // ** КодРегиона ­ Число ­ код региона (длина 2) . // ** КодНаселенногоПункта ­ Число ­ код населенного пункта (длина ­ 3) . // ** КодУлицы ­ Число ­ код улицы (длина ­ 4) . // * Наименование ­ Строка ­ наименование адресного объекта . // * ОбновлениеДоступно ­ Булево ­ признак наличия обновления . //
```

```
// Параметры: // Реквизиты ­ Строка ­ имена реквизитов, перечисленные через запятую . // Например , " Код , Наименование , Родитель " . // ­ Структура , ФиксированнаяСтруктура ­ в качестве ключа передается // псевдоним поля для возвращаемой структуры с результатом, // а в качестве значения (опционально) фактическое имя поля в таблице . // Если значение не определено , то имя поля берется из ключа . // ­ Массив , ФиксированныйМассив ­ массив имен реквизитов .
```

```
// Возвращаемое значение: // Булево ­ Истина , если хотя бы одна из переданных ролей доступна текущему пользователю, // либо у него есть административные права .
```

Для возвращаемых значений также действуют требования п . 5 . 2 . 2 и 5 . 2 . 3 .

- 5 . 4 . Секция " Пример " содержит пример использования процедуры , или функции . Предваряется строкой " Пример: " . Далее с новой строки пример использования .
- 5 . 5 . В редких случаях , когда сразу несколько параметров имеют дополнительные типы , рекомендуется добавить секцию «Варианты вызова» , в которой дать описания наиболее частых или всех возможных вариантов вызова функции с различными комбинациями типов параметров . Секция начинается фразой " Варианты вызова: " с новой строки , затем идут описания вариантов , каждое начинается с новой строки . Каждый вариант вызова представляется в виде имени функции со списком типов , перечисленных через запятую в круглых скобках , затем следует дефис и текстовое описание варианта . Например:
- 5 . 6 . Для быстрого перехода к другим объектам конфигурации , модулям , процедурам , функциям , а также к описанию в синтаксис­помощнике для типов , объектов и методов платформы , во всех секциях в комментариях рекомендуется давать гиперссылки . В частности , для перехода к функциямконструкторам структур .

```
// . . . // // Параметры: // Параметр1 ­ Тип11 , Тип12 ­ . . . // Параметр2 ­ Тип21 , Тип22 , Тип23 ­ . . . // // Варианты вызова: // УниверсальнаяПроцедура(Тип11 , Тип21) ­ описание . . . // УниверсальнаяПроцедура(Тип12 , Тип22) ­ описание . . . // УниверсальнаяПроцедура(Тип11 , Тип23) ­ описание . . . // Процедура УниверсальнаяПроцедура(Параметр1 , Параметр2) Экспорт
```

Гиперссылка предваряется строкой " см . " , " см . процедуру " , " см . функцию " , " см . модуль " , " см . объект " или " см . тип " , затем указывается имя . При этом имена могут быть простыми (в одно слово) или составными (несколько слов , разделенных точкой) .

```
Например:
```

```
// См . процедуру УправлениеДоступом . ЗаполнитьНаборыЗначенийДоступа
```

- 5 . 6 . 1 . Внутри текстового описания гиперссылки указываются в круглых скобках:
- 5 . 6 . 2 . Если в описании указана только одна эта ссылка , то без круглых скобок:
- 5 . 7 . В случаях когда возникает необходимость отметить процедуру (функцию) как устаревшую , в первой строке ее описания размещается слово " Устарела " . Например:
- 6 . Если требуется прокомментировать процедуру или функцию , которая используется с директивой компиляции , то вначале следует размещать комментарий , а затем ­

```
// Параметры: // СтатусыСерий ­ ТаблицаЗначений ­ таблица значений с колонками (см . функцию СерииКлиентСервер . СтатусыСерий) .
```

```
// Параметры: // ПараметрыУказанияСерий ­ Структура ­ см . функцию НоменклатураКлиентСервер . ПараметрыУказанияСерий
```

```
// Устарела . Следует использовать новую (см . ОбщегоНазначения . ЕстьРоль) // . . . Функция РолиДоступны(ИменаРолей) Экспорт
```

директиву компиляции . Например:

```
// Процедура ­ обработчик события " ПриСозданииНаСервере " формы . // Обрабатывает параметры формы и заполняет реквизиты формы значениями . // А также выполняет следующие действия: // . . . // &НаСервере Процедура ПриСозданииНаСервере(Отказ , СтандартнаяОбработка)
```

Такой стиль размещения комментария позволяет в первую очередь обращать внимание на определение функции и директиву компиляции , а потом ­ на комментарий , который может занимать достаточно большое количество строк .

- 7 . Код процедур и функций должен отделяться друг от друга в тексте модуля пустыми строками .
- ( * ) Примечание: под «списком типов» подразумеваются имена типов , разделенные запятыми . Имя типа может быть простым (в одно слово) или составным ­ в два слова , разделенных точкой .

Например: Строка , Структура , СправочникСсылка . Сотрудники .

## Примеры описания процедур и функций

Пример описания функции с одним параметром:

```
// Определяет доступность ролей ИменаРолей текущему пользователю , // а также доступность административных прав . // // Параметры: // ИменаРолей ­ Строка ­ имена ролей , доступность которых проверяется, разделенные запятыми . // // Возвращаемое значение: // Булево ­ Истина , если хотя бы одна из переданных ролей доступна текущему пользователю, // либо у него есть административные права . // // Пример: // Если РолиДоступны( " ИспользованиеРассылокОтчетов , ОтправкаПоПочте " ) Тогда . . . // Функция РолиДоступны(ИменаРолей) Экспорт
```

Пример описания процедуры без параметров:

```
// В обработчике события ПередЗаписью документа выполняется; // ­ очистка табличной части услуги , в случае если указан договор с комиссионером; // ­ проверка заполнения реквизита ЕдиницаИзмеренияМест табл . части Товары; // ­ синхронизация с " подчиненным " счетом ­ фактурой; // ­ заполнение склада и заказа покупателя в табличных частях Товары и ВозвратнаяТара; // ­ удаление неиспользуемых строк табличной части " Серийные номера " ; // ­ заполнение переменной модуля объекта УдалятьДвижение . // Процедура ПередЗаписью() КонецПроцедуры
```

Для автоматического упорядочивания комментариев к процедурам или функциям с директивами компиляции можно воспользоваться приложенной обработкой ФорматированиеДирективКомпиляции . epf .

## Для этого необходимо:

- 1 . Выгрузить модули конфигурации (команда меню Конфигурация ­&gt; Выгрузить файлы конфигурации . . . )
- 2 . Открыть обработку в режиме 1С:Предприятие и указать каталог , в который были выгружены модули ­ далее нажать кнопку " Форматировать "
- 3 . Загрузить модули в конфигурацию (команда меню Конфигурация ­&gt; Загрузить файлы конфигурации . . . )

## Параметры процедур и функций

- 1 . При объявлении формальных параметров процедур и функций (далее по тексту: функций) необходимо придерживаться общих правил образования имен переменных . В частности , имена параметров следует образовывать от терминов предметной области таким образом , чтобы из имени параметра было понятно его назначение .
- 2 . Не следует использовать вместо параметров функций другие средства конфигурирования (переменные модулей , реквизиты формы и т . п . )
- 3 . Параметры в функции должны идти в логической последовательности . Рекомендуется располагать параметры по принципу от общего к частному . Например , неправильно:
- 4 . Необязательные параметры (параметры со значениями по умолчанию) должны располагаться после обязательных параметров (без значений по умолчанию) . Например:
- 5 . Не рекомендуется объявлять в функциях много параметров (нужно ориентироваться на количество не более семи параметров) , при этом не должно быть много параметров со значениями по умолчанию (нужно ориентироваться на количество не более трех таких параметров) . В противном случае , читаемость вызывающего кода сильно снижается . Например , можно легко ошибиться в количестве запятых при передаче необязательных параметров .

```
Процедура ПересчитатьСуммуДокумента(ИмяПоляСумма , ДокументОбъект , СуммаВключаетНДС = Истина) Процедура ПоменятьЦветПоляФормы(Цвет , ИмяПоля , Форма) правильно сначала расположить основные параметры ДокументОбъект и Форма: Процедура ПересчитатьСуммуДокумента(ДокументОбъект , ИмяПоляСумма , СуммаВключаетНДС = Истина) Процедура ПоменятьЦветПоляФормы(Форма , ИмяПоля , Цвет)
```

```
Функция КурсВалютыНаДату(Валюта , Дата = Неопределено) Экспорт
```

При необходимости передавать в функцию большое число параметров рекомендуется:

- группировать однотипные параметры в один или несколько составных параметров типа Структура . Например , в структуры могут быть объединены параметры , описывающие состав и значения полей некоторого объекта (ДанныеЗаполнения , ПараметрыПроведения , ДанныеФайла и т . п . );
- либо полностью пересмотреть логику работы функции , например , разделив ее на несколько разных , более простых функций .

## Например , неправильно:

```
// Добавляет новое поле на форму , инициализирует его значениями по умолчанию . Функция ДобавитьПолеФормы(ИмяПоля , Заголовок = Неопределено , ОбработчикПриИзменении = "" , ОбработчикНачалоВыбора = "" , ШиринаПоля , ЦветФона = Неопределено , ЦветФонаЗаголовка = Неопределено , Родитель = Неопределено , КартинкаШапки = Неопределено , ПутьКДанным = Неопределено , ТолькоПросмотрПоля = Ложь , СвязиПараметровВыбора = Неопределено) … КонецФункции // вызывающий код НовоеПоле = ДобавитьПолеФормы( " СтараяЦена " , НСтр( " ru= ' Цена ' " ) , , , 12 , ЦветФона , ЦветЗаголовка , НоваяГруппа , , , Истина); НовоеПоле . ЦветТекста = WebЦвета . Серый; Правильно пересмотреть логику работы функций , оставив в ней только один ключевой параметр ИмяПоля: // Добавляет новое поле на форму , инициализирует его значениями по умолчанию . Функция НовоеПолеФормы(ИмяПоля)
```

```
… КонецФункции // вызывающий код НовоеПоле = НовоеПолеФормы( " СтараяЦена " ); НовоеПоле . Заголовок = НСтр( " ru= ' Цена ' " ); НовоеПоле . ЦветФона = ЦветФона; НовоеПоле . ЦветТекста = WebЦвета . Серый; НовоеПоле … . = … … Другой пример . Неправильно: // Создает элемент справочника " Номенклатура " Процедура СоздатьЭлементНоменклатуры(Наименование , ТоварУслуга , ЕдиницаИзмерения , ВесНетто , ПроверятьУникальность = Истина) … КонецПроцедуры Правильно сгруппировать параметры , описывающие значения реквизитов номенклатуры , в структуру ЗначенияРеквизитов: // Создает элемент справочника " Номенклатура " Процедура СоздатьЭлементНоменклатуры(ЗначенияРеквизитов , ПроверятьУникальность = Истина) … КонецПроцедуры 6 . При вызове функций необходимо избегать громоздких конструкций , которые приводят к снижению читаемости кода , увеличивают вероятность ошибок и затрудняют отладку . В частности: 6 . 1 . Не рекомендуется при передаче параметров в одну функцию применять вложенные вызовы других функций . Неправильно: СтруктураВложений . Вставить( ПрисоединенныйФайл . Наименование , Новый Картинка(ПолучитьИзВременногоХранилища( ПрисоединенныеФайлы . ПолучитьДанныеФайла(ПрисоединенныйФайл . Ссылка) . СсылкаНаДвоичныеДанныеФайла))); Правильно разбивать такие вызовы на отдельные операторы с помощью вспомогательных локальных переменных: АдресФайлаИзображения = ПрисоединенныеФайлы . ПолучитьДанныеФайла(ПрисоединенныйФайл . Ссылка) . СсылкаНаДвоичныеДанныеФайла; ДанныеИзображения = Новый Картинка(ПолучитьИзВременногоХранилища(АдресФайлаИзображения)); СтруктураВложений . Вставить(ПрисоединенныйФайл . Наименование , ДанныеИзображения); В то же время , если код с вложенными вызовами получается компактным (не требует переноса выражений) и легко читаемым , то вложенные вызовы допустимы . Например: Предупреждение(НСтр( " ru= ' Для выполнения операции необходимо установить расширение работы с файлами . ' " )); ПеречитатьСуммуПоКурсу(Сумма , КурсВалютыНаДату(Валюта)); 6 . 2 . Также не рекомендуется при вызове функций использовать вложенный конструктор структуры: Новый Структура( . . . ) . Вложенное объявление структуры допустимо только в тех случаях , когда количество ее свойств небольшое (нужно ориентироваться на количество свойств не более трех) . Неправильно: ЗаполнитьЦены( Объект . Товары , // Табличная часть , // Массив строк или структура отбора Новый Структура( // Параметры заполнения " Дата , Валюта , Соглашение , ПоляЗаполнения " , Объект . Дата , Объект . Валюта , Объект . Соглашение , " Цена , СтавкаНДС , ВидЦены , СрокПоставки " ) , Новый Структура( // Структура действий с измененными строками " ПересчитатьСумму , ПересчитатьСуммуСНДС , ПересчитатьСуммуНДС , ПересчитатьСуммуРучнойСкидки ,
```

```
ОчиститьАвтоматическуюСкидку , ОчиститьСуммуВзаиморасчетов " , " КоличествоУпаковок " , СтруктураПересчетаСуммы , СтруктураПересчетаСуммы , " КоличествоУпаковок " , Неопределено , Неопределено ) ); Правильно: ПараметрыЗаполнения = Новый Структура; ПараметрыЗаполнения . Вставить( " Дата " , Объект . Дата); ПараметрыЗаполнения . Вставить( " Валюта " , Объект . Валюта); ПараметрыЗаполнения . Вставить( " Соглашение " , Объект . Соглашение); ПараметрыЗаполнения . Вставить( " ПоляЗаполнения " , " Цена , СтавкаНДС , ВидЦены , СрокПоставки " ); ДействияСИзмененнымиСтроками = Новый Структура; ДействияСИзмененнымиСтроками . Вставить( " ПересчитатьСумму " , " КоличествоУпаковок " ); ДействияСИзмененнымиСтроками . Вставить( " ПересчитатьСуммуСНДС " , ПараметрыПересчетыСуммы); ДействияСИзмененнымиСтроками . Вставить( " ПересчитатьСуммуНДС " , ПараметрыПересчетыСуммы); ДействияСИзмененнымиСтроками . Вставить( " ПересчитатьСуммуРучнойСкидки " , " КоличествоУпаковок " ); ДействияСИзмененнымиСтроками . Вставить( " ОчиститьАвтоматическуюСкидку " ); ДействияСИзмененнымиСтроками . Вставить( " ОчиститьСуммуВзаиморасчетов " ); ЗаполнитьЦены(Объект . Товары , ПараметрыЗаполнения , ДействияСИзмененнымиСтроками); 7 . При вызове функций не следует пропускать обязательные параметры . В противном случае , в параметр будет передано значение Неопределено , на которое функция может быть не рассчитана . Если же значение Неопределено является допустимым , то нужно или его передавать в функцию явно , или сделать этот параметр необязательным со значением по умолчанию Неопределено . Например , для вызова процедуры Процедура ПоменятьЦветПоляФормы(Форма , ИмяПоля , Цвет) неправильно: ПоменятьЦветПоляФормы( , " РезультатПроверки " , ЦветаСтиля . ПоясняющийОшибкуТекст); // пропущен первый параметр Форма ПоменятьЦветПоляФормы( , , ); // пропущены все обязательные параметры правильно: ПоменятьЦветПоляФормы(ЭтотОбъект , " РезультатПроверки " , Цвет); // указаны все обязательные параметры См . также Передача параметров по ссылке и по значению при вызове процедур и функций (статья на ИТС) Особенности использования структур в качестве параметров процедур и функций
```

- Использование объектов типа Структура

## Особенности использования структур в качестве параметров процедур и функций

Основная статья: Параметры процедур и функций

Для процедур и функций (далее по тексту: функций) с параметрами типа Структура рекомендуется придерживаться следующего подхода к разработке .

- 1 . Помимо функции , которая собственно реализует прикладную функциональность (далее по тексту: вызываемая функция) , необходимо определить функцию­конструктор для создания новой структуры (далее по тексту функция­конструктор параметров) . При этом сама функция­конструктор не принимает параметров , а только возвращает структуру ­ заготовку со свойствами , которую вызывающий код должен проинициализировать конкретными значениями и передать в вызываемую функцию .

```
Пример вызывающего кода:
```

```
Процедура ПриИзмененииНоменклатурыСервер(ИдентификаторТекущейСтроки) // Получаем новую структуру параметров . ПараметрыЗаполненияЦен = ЦенообразованиеКлиентСервер . ПараметрыЗаполненияЦеныВСтрокеТЧ(); // Заполняем параметры . ПараметрыЗаполненияЦен . Дата = Объект . Дата; ПараметрыЗаполненияЦен . Валюта = Объект . Валюта; ТекущаяСтрока = Объект . Товары . НайтиПоИдентификатору(ИдентификаторТекущейСтроки); // Передаем структуру параметров в прикладную функцию . ЦенообразованиеСервер . ЗаполнитьЦеныВСтрокеТЧ(ТекущаяСтрока , ПараметрыЗаполненияЦен); КонецПроцедуры Пример функции­конструктора параметров в модуле ЦенообразованиеКлиентСервер: Функция ПараметрыЗаполненияЦеныВСтрокеТЧ() Экспорт ПараметрыЗаполненияЦен = Новый Структура; ПараметрыЗаполненияЦен . Вставить( " Дата " ); ПараметрыЗаполненияЦен . Вставить( " Валюта " ); ПараметрыЗаполненияЦен . Вставить( " ПересчитыватьСумму " , Истина); ПараметрыЗаполненияЦен . Вставить( " ОбязательныеПараметры " , " Дата , Валюта " ); // обязательные параметры , которые нужно заполнять Возврат ПараметрыЗаполненияЦен;
```

## КонецФункции

Имена свойств структуры соответствуют параметрам вызываемой функции . При этом параметры со значениями по умолчанию должны быть явно проинициализированы в этой структуре .

- 2 . В вызывающем коде не следует добавлять каких­либо других свойств в структуру параметров . Во избежание неоднозначности и скрытых ошибок все допустимые параметры вызываемой функции должны быть определены явно в функции­конструкторе параметров .

## См . также

- Использование объектов типа Структура

## Правила образования имен переменных

- 1 . Имена переменных следует образовывать от терминов предметной области таким образом , чтобы из имени переменной было понятно ее назначение .
- 2 . Имена следует образовывать путем удаления пробелов между словами . При этом , каждое слово в имени пишется с прописной буквы . Предлоги и местоимения из одной буквы также пишутся прописными буквами . Пример:

Перем ДиалогРаботыСКаталогом; // Диалог работы с каталогом Перем КоличествоПачекВКоробке; // Количество пачек в коробке

Примеры некорректных имен переменных:

масРеквизитов , соотвВидИмя , новСтр

- 3 . Имена переменных запрещается начинать с подчеркивания .
- 4 . Имена переменных не должны состоять из одного символа . Использование коротких имен переменных допускается только для счетчиков циклов .
- 5 . Переменные , отражающие состояние некоторого флага , следует называть так , как пишется истинное значение этого флага . Например:

Перем ЕстьОшибки; // Признак наличия ошибок в процедуре . Перем ЭтоТоварТара; // Признак , что товар относится к возвратной таре .

## См . также

- Использование глобальных переменных в программных модулях

## Работа с параметром «Отказ» в обработчиках событий

- 1 . В обработчиках событий модулей объектов , наборов записей , форм и т . п . , содержащих параметр Отказ (ПриЗаписи ,

ОбработкаПроверкиЗаполнения , ТоварыПередНачаломДобавления и т . п . ) , не следует присваивать этому параметру значение Ложь .

Это требование обусловлено тем , что , как правило , в коде обработчиков событий параметр Отказ может устанавливаться сразу в нескольких последовательных проверках (или в нескольких подписках на одно и то же событие) . В таком случае к моменту выполнения очередной проверки параметр Отказ уже может заранее содержать значение Истина , и можно ошибочно сбросить его обратно в Ложь .

Кроме того , при доработках конфигурации на внедрении число этих проверок может увеличиться .

## Неправильно:

## Процедура ОбработкаПроверкиЗаполнения(Отказ , ПроверяемыеРеквизиты) . . . Отказ = ЕстьОшибкиЗаполнения(); . . . КонецПроцедуры Правильно: Процедура ОбработкаПроверкиЗаполнения(Отказ , ПроверяемыеРеквизиты) . . . Если ЕстьОшибкиЗаполнения() Тогда Отказ = Истина; КонецЕсли; . . . КонецПроцедуры или Отказ = Отказ Или ЕстьОшибкиЗаполнения();

- 2 . Эти же требования справедливы для других аналогичных параметров обработчиков событий: СтандартнаяОбработка , Выполнение и др . Например:

```
Процедура ОбработкаПолученияДанныхВыбора(ДанныеВыбора , Параметры , СтандартнаяОбработка) Если Параметры . Свойства( . . . ) Тогда СтандартнаяОбработка = Ложь; . . .
```

КонецЕсли;

КонецПроцедуры

## Общие требования к построению конструкций встроенного языка

- 1 . В конструкциях встроенного языка ключевые слова пишутся канонически (как в документации или Синтакс­помощнике) . Правильно:

КонецЕсли

Неправильно:

```
конецЕсли , КОНЕЦЕСЛИ , конецесли , Конецесли .
```

- 2 . При следовании друг за другом нескольких операторов присваивания , допускается выравнивать их следующим образом:

```
ДиалогВыбора . ПолноеИмяФайла = ИмяФайла; ДиалогВыбора . Каталог = ИмяПути; ДиалогВыбора . Заголовок = НСтр( " ru = ' Выберите файл со списком запросов ' " ); ДиалогВыбора . Фильтр = НСтр( " ru = ' Файлы запросов ( * . sel)| * . sel|Все файлы ( * . * )| * . * ' " ); ДиалогВыбора . Расширение = " sel " ;
```

При этом не следует выравнивать операторы одинаково по всему модулю ­ рекомендуется делать выравнивание только для операторов , расположенных рядом .

- 3 . Составные логические выражения в Если … КонецЕсли переносятся согласно правилам переноса выражений .
- 4 . Логические выражения и логические значения (например , результат функции , возвращающей логическое значение , переменные типа Булево и пр . ) не следует проверять путем сравнения с логической константой . Правильно:
- 5 . В тех случаях , когда требуется сравнивать результаты каких­либо выражений , следует предварительно присваивать результаты этих выражений промежуточным переменным , и сравнивать уже сами эти переменные .

```
Если ЭтоНовый() Тогда Неправильно: Если ЭтоНовый() = Истина Тогда
```

## Правильно:

```
Ответ = Вопрос(НСтр( " ru = ' Данные еще не записаны . Записать? ' " ) , РежимДиалогаВопрос . ДаНет , , КодВозвратаДиалога . Да);
```

```
Если Ответ = КодВозвратаДиалога . Да Тогда Записать(); Иначе Возврат; КонецЕсли; Неправильно: Если Вопрос(НСтр( " ru = ' Данные еще не записаны . Записать? ' " ) , РежимДиалогаВопрос . ДаНет , , КодВозвратаДиалога . Да) = КодВозвратаДиалога . Да Тогда Записать(); Иначе Возврат; КонецЕсли;
```

- 6 . Необходимо использовать системные наборы значений везде , где возможно их применить , например , вместо Символ(10) следует использовать Символы . ПС .

## См . также

- Перенос выражений
- Тексты модулей

## Перенос выражений

- 1 . При длине строки более 120 символов следует использовать переносы . Строки длиннее 120 символов делать не рекомендуется , за исключением тех случаев , когда перенос невозможен .
- 2 . Длинные арифметические выражения переносятся следующим образом:
- в одной строке может находиться более одного операнда;
- при переносе знаки операции пишутся в начале строки (а не в конце предыдущей строки);
- операнды на новой строке предваряются стандартным отступом , либо выравниваются по началу первого операнда без учета знаков операций .

## Пример:

```
СуммаДокумента = СуммаБезСкидки + СуммаРучнойСкидки + СуммаАвтоматическойСкидки; или СуммаДокумента = СуммаБезСкидки + СуммаРучнойСкидки + СуммаАвтоматическойСкидки;
```

- 3 . 1 Длинные строковые константы рекомендуется переносить с помощью специального символа перевода на новую строку , например:

```
ТекстЗапроса = " ВЫБРАТЬ РАЗРЕШЕННЫЕ | ЗаметкиПоПредмету . КоличествоЗаметок КАК КоличествоЗаметок |ИЗ | РегистрСведений . ЗаметкиПоПредмету КАК ЗаметкиПоПредмету |ГДЕ | ЗаметкиПоПредмету . Предмет = &Предмет " );
```

## или

```
ТекстПредупреждения = СтроковыеФункцииКлиентСервер . ПодставитьПараметрыВСтроку( НСтр( " ru = ' Обновление адресного классификатора не требуется . |В программе уже загружены актуальные адресные сведения от %1 . ' " ) , Формат(ДатаПоследнегоОбновленияКЛАДР , " ДЛФ=D " )); ПоказатьПредупреждение( , ТекстПредупреждения);
```

При этом не следует переносить строки , содержащие текст сообщения пользователю (объект СообщениеПользователю) .

- 3 . 2 . В общем случае при конкатенации строк знак " + " рекомендуется писать в начале строки , так же как и при переносе арифметических выражений (см . п . 2) , например:
- 3 . 3 . При конкатенации длинных строк знак " + " можно писать в конце строки , чтобы не ломать общее форматирование текста . Например ,
- 4 . При необходимости параметры процедур , функций и методов следует переносить следующим образом:
- параметры выравниваются по началу первого параметра , либо предваряются стандартным отступом;
- закрывающая скобка и разделитель операторов " ; " пишутся в той же строке , что и последний параметр;
- также допустим и способ форматирования , который предлагает функция автоформатирования в конфигураторе (см . п . 5) .

```
ПоляОтбора = " Номенклатура , Характеристика , Склад " + ДополнительныеПоляОтбора;
```

```
ТекстЗапроса = ТекстЗапроса + " ВЫБРАТЬ | Номенклатура . Ссылка КАК Ссылка |ИЗ | Справочник . Номенклатура КАК Номенклатура " ;
```

## Пример:

```
ИменаДокументов = Новый СписокЗначений; ИменаДокументов . Добавить(Метаданные . Документы . СтрокаВыпискиРасход . Имя , Метаданные . Документы . СтрокаВыпискиРасход . Синоним); ИменаДокументов . Добавить(Метаданные . Документы . РасходныйКассовыйОрдер . Имя , Метаданные . Документы . РасходныйКассовыйОрдер . Синоним); или ИменаДокументов = Новый СписокЗначений; ИменаДокументов . Добавить(Метаданные . Документы . СтрокаВыпискиРасход . Имя , Метаданные . Документы . СтрокаВыпискиРасход . Синоним); ИменаДокументов . Добавить(Метаданные . Документы . РасходныйКассовыйОрдер . Имя , Метаданные . Документы . РасходныйКассовыйОрдер . Синоним);
```

- 5 . Сложные логические условия в Если … ИначеЕсли … КонецЕсли следует переносить следующим образом:
- каждое элементарное условие нужно начинать с новой строки , если длина строки превышает ограничение в 120 символов;
- логические операторы И , ИЛИ ставятся в начале строки , а не в конце предыдущей строки;
- все условия предваряются стандартным отступом , либо выравниваются по началу первого условия , без учета логического оператора (для выравнивания выражений относительно первой строки рекомендуется использовать пробелы . );
- ключевое слово Тогда пишется на той же строке , что и последнее условие .

Примеры:

```
Если (ВидОперации = Перечисления . ВидыОперацийПоступлениеМПЗ . ПоступлениеРозница) ИЛИ (ВидОперации = Перечисления . ВидыОперацийПоступлениеМПЗ . ПоступлениеРозницаКомиссия) Тогда Возврат Истина; КонецЕсли; Если ((СтруктураМодуля[Индекс] . Блок = Перечисления . ТипыБлоковМодулей . ЗаголовокПроцедуры) ИЛИ(СтруктураМодуля[Индекс] . Блок = Перечисления . ТипыБлоковМодулей . ЗаголовокФункции)) И(Найти(ВРЕГ(СтруктураМодуля[Индекс] . Текст) , КлючБлока)> 0) Тогда
```

- 6 . Для выполнения перечисленных выше рекомендаций , кроме автоматического форматирования текста программного модуля , в процессе ввода можно также отформатировать уже введенный текст . Для этого необходимо выделить блок текста , который требуется отформатировать , и выбрать пункт меню Текст — Блок — Форматировать . При этом текстовый редактор проанализирует текст модуля и выполнит его форматирование , при котором содержимое каждой синтаксической конструкции будет сдвинуто вправо на величину табуляции независимо от первоначального расположения строк (лидирующих пробелов) . В пустые строки устанавливаются знаки табуляции в соответствии с синтаксической конструкцией .

Для автоматической расстановки переносов строк можно воспользоваться приложенной обработкой .

## Использование дублирующего кода

1 . Дублированием кода называется способ разработки конфигурации , при котором при создании нового функционала копируются без изменений уже существующие фрагменты кода или целиком процедуры и функции и при этом копируемый функционал по логике приложения должен быть одинаковым .

Дублирование кода создает проблемы для сопровождения разрабатываемой конфигурации:

- в копию попадают все ошибки из дублируемого кода;
- при исправлении ошибок существует вероятность пропустить некоторые вхождения;
- затраты на исправление ошибок увеличиваются;
- усложняется понимание структуры программы .

Дублирование часто возникает из­за невозможности доступа к написанному прежде коду (например , если написанный прежде код размещен в модуле той или иной формы , а его использование востребовано при разработке другой формы) .

Следует осторожно относиться к дублированию кода и по возможности стараться его избегать . Основной способ избежать дублирования кода ­ переработать существующий код . Это позволит вывести процедуры и функции , алгоритмы которых могут быть использованы повторно , из модулей объектов и модулей форм в общие модули .

- 2 . Следует помнить , что дублирование кода оправданно и должно выполняться , если развитие функционала в будущем может привести к значительному расхождению двух вариантов кода .

## См . также

- Разработка конфигураций с повторным использованием общего кода и объектов метаданных

## Использование директив компиляции

```
Директивы компиляции: &НаКлиенте (&AtClient) &НаСервере (&AtServer) &НаСервереБезКонтекста (&AtServerNoContext)
```

следует применять только в коде модулей управляемых форм и в коде модулей команд . В остальных модулях рекомендуется применять инструкции препроцессору .

<!-- image -->

## Получение метаданных объектов

- 1 . В тех случаях , когда известен тип объекта метаданного (справочник , документ , и т . п . ) , то получение метаданных объекта конфигурации следует выполнять с помощью метода Метаданные этого объекта (или ссылки для объектов ссылочного типа) , а не путем обращения к свойству глобального контекста Метаданные , так как второй способ существенно более медленный .

```
Правильно: СправочникОбъект . Метаданные() Неправильно: Метаданные . Справочники[ИмяСправочника] Метаданные . НайтиПоПолномуИмени( " Справочник . " + ИмяСправочника) 2 . В тех случаях , когда тип объекта метаданного заранее неизвестен , рекомендуется воспользоваться методом НайтиПоТипу , например:
```

```
// Получить полное имя объекта метаданных вида " Справочник . Номенклатура " , " Документ . ПриходнаяНакладная " по переданной ссылке . ИмяОбъектаМетаданного = Метаданные . НайтиПоТипу(ТипЗнч(Ссылка)) . ПолноеИмя();
```

## Обработчики событий модуля формы , подключаемые из кода

Обработчикам событий модуля формы , которые устанавливаются из кода с помощью метода УстановитьДействие , рекомендуется задавать префикс Подключаемый \_ . Например:

```
Процедура Подключаемый _ РазрешитьРедактированиеРеквизитовОбъекта() … Процедура Подключаемый _ КонтактнаяИнформацияНачалоВыбора()
```

…

В случае когда подключение обработчика выполняется не в тексте модуля формы (а например , в общем модуле) , то в результатах проверки конфигурации с включенным флажком " Поиск неиспользуемых процедур и функций " окажутся ошибки вида:

```
Справочник . _ ДемоПартнеры . Форма . ФормаЭлемента . Форма Не обнаружено ссылок на процедуру: " Подключаемый _ КонтактнаяИнформацияНачалоВыбора "
```

Использование префикса позволяет легко идентифицировать такие обработчики в результатах проверки и отсеивать как исключения .

Если же подключение обработчика выполняется в тексте модуля формы , то проверка конфигурации с включенным флажком " Поиск неиспользуемых процедур и функций " ошибку не регистрирует .

## Использование переменных в программных модулях

- 1 . В большинстве случаев , вместо переменных программных модулей следует использовать более подходящие средства разработки платформы 1С:Предприятие . Поскольку область видимости (использования) таких переменных сложно контролировать , то они зачастую становятся источником трудновоспроизводимых ошибок .

Примеры некорректного использования и исключений из этого правила приведены далее . Рекомендации по оформлению переменных в коде программных модулей см . в статье Структура модуля .

- 2 . Неоправданные примеры использования переменных в модулях объектов (справочников , документов , наборов записей , обработок , отчетов и пр . ) .
- 2 . 1 . Для передачи параметров между обработчиками подписок на события и в обработчики событий модуля объекта из внешнего кода рекомендуется использовать свойство объекта ДополнительныеСвойства . Например , неправильно:
- 2 . 3 . Для кеширования долго ­ вычисляемых и часто­используемых значений в процедурах и функциях рекомендуется применять модули с повторным использованием возвращаемых значений на время вызова сервера .

```
Перем КонвертацияФайлов Экспорт; Процедура ПередЗаписью(Отказ) Если КонвертацияФайлов Тогда . . . КонецПроцедуры // вызывающий код ФайлОбъект . КонвертацияФайлов = Истина; ФайлОбъект . Записать(); Правильно: Процедура ПередЗаписью(Отказ) Если ДополнительныеСвойства . Свойство( " КонвертацияФайлов " ) Тогда . . . КонецПроцедуры // вызывающий код ФайлОбъект . ДополнительныеСвойства . Вставить( " КонвертацияФайлов " , Истина); ФайлОбъект . Записать(); В то же время , для передачи внутренних параметров между обработчиками событий модуля объекта целесообразно использовать неэкспортные переменные модуля объекта , которые недоступны из внешнего кода . Например: Перем ПредыдущееЗначениеОрганизации; // значение реквизита " Организация " до записи объекта в базу Процедура ПередЗаписью(Отказ) ПредыдущееЗначениеОрганизации = . . . ; // с помощью запроса выясняем значение
```

```
до записи объекта в базу КонецПроцедуры Процедура ПриЗаписи(Отказ) Если ПредыдущееЗначениеРеквизита <> Организация Тогда // отрабатываем изменение значения реквизита при записи . . . КонецЕсли; КонецПроцедуры 2 . 2 . Для обработки кодов возврата (ошибок) в логике программного модуля рекомендуется использовать строковые константы . Например , неправильно: Перем НетОшибок , Ошибка _ ОбработкиПроверкиЗаполнения , // возникает , если обработка проверки заполнения вернула отказ Ошибка _ ЗаписиОбъекта , // возникает , если во время записи объекта возникло исключение Ошибка _ БлокировкиОбъекта , // возникает , при попытке блокировки объекта Процедура ВыполнитьПерерасчет() . . . Результат = ОбработатьДокументы( . . . ); Если Результат = Ошибка _ ЗаписиОбъекта Тогда . . . ИначеЕсли Результат = Ошибка _ БлокировкиОбъекта Тогда . . . ИначеЕсли . . . КонецПроцедуры . . . //////////////////////////////////////////////////////////////////////////////// // ИНИЦИАЛИЗАЦИЯ МОДУЛЯ НетОшибок = 1; Ошибка _ ОбработкиПроверкиЗаполнения = 2; Ошибка _ ЗаписиОбъекта = 3; Ошибка _ БлокировкиОбъекта = 4; правильно: Процедура ВыполнитьПерерасчет() . . . Результат = ОбработатьДокументы( . . . ); Если Результат = " ОшибкаЗаписиОбъекта " Тогда . . . ИначеЕсли Результат = " ОшибкаБлокировкиОбъекта " Тогда . . . ИначеЕсли . . . КонецПроцедуры
```

Исключение из этого правила составляют случаи , когда по соображениям безопасности возвращать результат вычисления в экспортной функции недопустимо . В этом случае они размещаются в локальной переменной модуля .

- 3 . Неоправданные примеры использования переменных в модулях форм .
- 3 . 1 . Для кеширования долго ­ вычисляемых и часто­используемых значений в процедурах и функциях рекомендуется применять модули с повторным использованием возвращаемых значений .

При этом не следует кешировать статическую и легко вычисляемую информацию . В частности , не следует кешировать в клиентских переменных модуля формы значения предопределенных элементов и перечислений . Для их получения на клиенте предназначен метод ПредопределенноеЗначение .

- 3 . 2 . Для хранения и передачи промежуточных результатов вычислений между разными процедурами и функциями формы следует использовать
- Параметры процедур и функций – для передачи результатов по цепочке вызовов дочерних процедур и функций в контексте одного вызова .
- Реквизиты формы – если требуется сохранять промежуточные результаты между разными вызовами с клиента . (Следует иметь в виду , что значения серверных переменных модуля формы не сохраняются между вызовами с клиента . )

Исключение из этого правила составляют случаи использования клиентских переменных формы для хранения промежуточных результатов в обработчиках ожидания формы , в обработчиках внешних событий и в клиентских обработчиках событий элементов формы . Например:

```
&НаКлиенте Перем ПорядковыйНомерИзображения; // счетчик ­ нумератор для наименования файлов при сканирования нескольких изображений . . . &НаКлиенте Процедура ВнешнееСобытие(Источник , Событие , Данные) Если Источник = " TWAIN " И Событие = " ImageAcquired " Тогда Если ПорядковыйНомерИзображения = Неопределено Тогда ПорядковыйНомерИзображения = 1; КонецЕсли; ПорядковыйНомерИзображения = ПорядковыйНомерИзображения + 1; // Сохранение отсканированного документа в файл с номером ПорядковыйНомерИзображения // . . . КонецЕсли; КонецПроцедуры
```

- 4 . Переменные управляемого и обычного приложения следует использовать для хранения «клиентских параметров сеанса» . Подробнее см . статью Использование параметров сеанса .

## Предварительная инициализация локальных переменных

Методическая рекомендация (полезный совет)

В случаях когда фрагмент кода вычисляет значение одной или нескольких локальных переменных , рекомендуется явно выполнять предварительную инициализацию таких переменных . Это позволит избежать потенциальных ошибок времени выполнения , когда значение переменной оказывается Неопределено , а последующий код рассчитывает на определенный тип значения . Например:

```
Если ЧтоТоТам Тогда МояПеременная = 10; ИначеЕсли // ряд следующих веток … КонецЕсли; . . . = МояПеременная; // если ЧтоТоТам не ИСТИНА , то нужно учитывать, что МояПеременная может быть равна Неопределено
```

## Правильно:

```
МояПеременная = 0; // значение по умолчанию Если ЧтоТоТам Тогда МояПеременная = 10; ИначеЕсли // ряд следующих веток … КонецЕсли; . . . = МояПеременная; // используем значение переменной , которая всегда имеет числовое значение
```

Данная рекомендация имеет смысл для больших блоков Если/ ИначеЕсли/Иначе , внутри которых сложно визуально по тексту контролировать инициализацию переменных .

## Использование Журнала регистрации

- 1 . Журнал регистрации предназначен для хранения событий , возникающих в процессе работы пользователей с информационной базой . При администрировании эту информацию часто необходимо анализировать в различных разрезах для того , чтобы например , узнать какие события происходили в определенный момент времени , какие действия выполнял тот или иной пользователь .
- 2 . Рекомендуется производить запись в Журнал регистрации из встроенного языка в тех случаях , когда администратору необходимо сообщить дополнительную диагностическую информацию о событиях , которые не записываются платформой 1С:Предприятие . Такая необходимость может возникнуть как при выполнении бизнес­логики , вызываемой при интерактивной работе , так и в фоновых (регламентных) заданиях . Для удобства анализа Журнала регистрации одна его запись должна соответствовать одному событию , а сами записи должны содержать ряд обязательных атрибутов , в разрезе которых проводится анализ .
- 2 . 1 . Строковый идентификатор типа события . Как правило , список типов событий в конфигурации может быть сколь угодно большим , поэтому типы событий рекомендуется группировать по функциональному признаку: «Название группы событий . Название события» . Например , правильно записывать события с типами «Поручения . Уведомление о новых задачах» и «Поручения . Уведомление о зависших задачах» вместо двух «плоских» типов событий «Уведомление о новых задачах» и «Уведомление о зависших задачах» . Текст типа события – локализуем , при этом всегда задается основной язык конфигурации .
- 2 . 2 . Уровень важности события . Критичные события , требующие повышенного внимания администратора (ошибки бизнес­логики , сбои в программе , и т . п . ) , записываются в Журнал регистрации с уровнем важности «Ошибка» . Потенциальные проблемы и не фатальные ошибки регистрируются как «Предупреждения» . Для вывода информационных сообщений об успешном завершении той или иной операции используется уровень важности «Информация» . Также возможно применять и более низкий уровень важности – «Примечание» .
- 2 . 3 . Комментарий . Содержит текстовую неструктурированную информацию о событии . В случае ошибок в этом поле содержится информация , необходимая для расследования причины проблемы . Не следует помещать в комментарий информацию сразу о нескольких событиях . Например , неправильно записывать одно событие с комментарием вида:

[01 . 01 . 2010 00:00:01] Начало инициализации обмена данными по настройке " Обмен данными выгрузка " , номер строки настройки: 1 [01 . 01 . 2010 00:00:02] Окончание инициализации обмена данными (успешно)

[01

.

01

.

2010

00:00:03]

Начало

процесса

обмена

данными

по

настройке

```
" Обмен данными выгрузка " , номер строки настройки: 1 [01 . 01 . 2010 00:00:04] Начало записи изменений в файл обмена [01 . 01 . 2010 00:00:05] Окончание записи изменений в файл обмена (успешно) [01 . 01 . 2010 00:00:06] Окончание процесса обмена данными по настройке " Обмен данными выгрузка " , номер строки настройки: 1 [01 . 01 . 2010 00:00:07] Выполнено , Выгрузка данных , Обработано 1 объектов
```

```
правильно записать столько событий 5
```

, сколько их реально произошло .

Текст комментария – локализуем . Для записи в Журнал регистрации информации о возникшем исключении следует использовать конструкцию:

ПодробноеПредставлениеОшибки(ИнформацияОбОшибке())

Пример регистрации дополнительных событий в функциональной подсистеме «Мой механизм»:

```
Попытка ЗаписьЖурналаРегистрации(НСтр( " ru = ' Мой механизм . Действие с возможной ошибкой ' " , КодОсновногоЯзыка) , УровеньЖурналаРегистрации . Информация , , , НСтр( " ru = ' Начато действие ' " )); ДействиеСВозможнойОшибкой(ОбъектДействия); ЗаписьЖурналаРегистрации(НСтр( " ru = ' Мой механизм . Действие с возможной ошибкой ' " , КодОсновногоЯзыка) , УровеньЖурналаРегистрации . Информация , , , НСтр( " ru = ' Завершено действие ' " ); Исключение ЗаписьЖурналаРегистрации(НСтр( " ru = ' Мой механизм . Действие с возможной ошибкой ' " , КодОсновногоЯзыка) , УровеньЖурналаРегистрации . Ошибка , , , НСтр( " ru = ' " Во время выполнения действия произошла неизвестная ошибка . ' " ) + Символы . ПС + ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()); КонецПопытки; КонецПроцедуры
```

где переменная КодОсновногоЯзыка содержит код основного языка конфигурации . Подробнее см . Требования по локализации конфигурации , п . .

- 3 . Не следует использовать выборку из журнала регистрации в тех задачах , где критична высокая скорость выполнения выборки . Поскольку при больших объемах журнала регистрации скорость выборки падает пропорционально увеличению его объема .

Рекомендуется заводить отдельный регистр для протоколирования интересующих событий или обращаться к специализированным объектам

платформы (например , МенеджерФоновыхЗаданий для выборки истории выполнения фоновых заданий) .

Эту особенность нужно также учитывать при разработке отчетов по журналу регистрации .

## См . также

- Строки интерфейса в модулях конфигурации: требования по локализации

## Перехват исключений в коде

- 1 . В общем случае не рекомендуется перехватывать исключения . В частности не нужно перехватывать исключения только ради выдачи сообщения об ошибке . Необработанное исключение в любом случае будет выдано пользователю в виде сообщения об ошибке (а также будет записано в журнал регистрации для администратора , если исключение возникло на сервере) .
- 2 . Тем не менее , необходимость перехвата исключений в коде все же возникает . Например , для того чтобы уточнить текст ошибки , дополнив его прикладной , понятной конечному пользователю , информацией . Однако при этом необходимо фиксировать причину ошибки в журнале регистрации для того , чтобы системный администратор имел возможность выполнить диагностику проблемы и при необходимости передать информацию об ошибке в службу технической поддержки .

При этом рекомендуется записывать в журнал регистрации подробное представление исключения , а краткое представление добавлять в текст сообщения пользователю .

- 3 . Частные случаи некорректного использования и перехвата исключений .
- Попытка ВыполнитьОперацию(); Исключение ТекстСообщения = КраткоеПредставлениеОшибки(ИнформацияОбОшибке()); ПоказатьПредупреждение( , НСтр( " ru = ' Операция не может быть выполнена по причине: ' " ) + Символы . ПС + ТекстСообщения); КонецПопытки; 3 . 2 . Не следует анализировать текст исключений с целью интерпретации причины ошибки . Текст исключения может меняться в зависимости от локализации . В условиях отсутствия штатных средств (например , типизированных исключений) , следует выдавать пользователю тексты исключений «как есть» . Для понятности , его можно дополнить пояснением возможных причин . Например: Попытка ЗагрузитьФайлИзИнтернета( . . . ); Исключение ТекстСообщения = КраткоеПредставлениеОшибки(ИнформацияОбОшибке()); ТекстСообщения = НСтр( " ru = ' Не удалось загрузить файл: ' " ) + Символы . ПС + ТекстСообщения + Символы . ПС + НСтр( " ru = ' Возможные причины: · Нет подключения к Интернету; · На веб­узле возникли неполадки; · Брандмауэр или другое промежуточное ПО (антивирусы и т . п . ) блокируют попытки программы подключиться к Интернету; · Подключение к Интернету выполняется через прокси ­ сервер, но его параметры не заданы в программе . ' " ); ПоказатьПредупреждение( , ТекстСообщения); КонецПопытки; В тех случаях , когда анализ типов исключений критически важен для корректной работы бизнес ­ логики , следует отказаться от исключений и использовать коды ошибок (коды возврата) . При этом недопустимо использовать числовые коды ошибок , т . к . код становится нечитаемым: КодОшибки = ЗагрузитьФайлИзИнтернета( . . . ); Если КодОшибки = 12345 Тогда . . . ИначеЕсли . . . правильно применять строковые литералы (например , " Успешно " , " НетМестаНаДиске " , " Отменено " и т . п . ): РезультатЗагрузки = ЗагрузитьФайлИзИнтернета( . . . ); Если РезультатЗагрузки = " Успешно " Тогда . . . ИначеЕсли . . . Строковые литералы кодов ошибок не локализуются . Исключение составляют случаи работы с веб­сервисами и другими внешними системами , где коды ошибок не доступны , а результат работы транслируется в вызывающий код прикладной конфигурации в виде исключений . 3 . 3 . Если имеется некоторая клиентская бизнес­логика (код выполняется полностью на клиенте): &amp;НаКлиенте Процедура СоздатьФайлНаДиске() // код , приводящий к вызову исключения
- 3 . 5 . Недопустимо делать проверки наличия у объекта реквизитов , методов , макетов и т . п . , используя для этого исключения , т . к . это может привести к сложно диагностируемым ошибкам , а также затрудняет отладку в режиме «Останавливаться по ошибке» . Вместо перехвата исключений в этом случае рекомендуется:
- использовать механизмы работы с метаданными , чтобы явным образом проверять наличие или отсутствие реквизита (макета и т . п . );
- если различия связаны с особенностями встраивания библиотек – описывать особенности явным образом в переопределяемых модулях (см . Переопределяемые и поставляемые объекты);
- пересмотреть логику работы методов , использующих перехват исключений . Например , можно предусмотреть параметры , которые определяются в вызывающем коде и указывают нужно или нет обращаться к какому­либо методу или свойству объекта .

<!-- image -->

```
. . . . КонецПроцедуры то рекомендуется делать дополнительный серверный вызов для протоколирования неудачного результата операции в журнал регистрации: Попытка // клиентский код , приводящий к вызову исключения СоздатьФайлНаДиске(); Исключение ТекстСообщения = КраткоеПредставлениеОшибки(ИнформацияОбОшибке()); ПоказатьПредупреждение( , НСтр( " ru = ' Операция не может быть выполнена по причине: ' " ) + Символы . ПС + ТекстСообщения); ЗаписатьОшибкуРаботыСФайлами(ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()))); КонецПопытки; &НаСервереБезКонтекста Процедура ЗаписатьОшибкуРаботыСФайлами( . . . ) ЗаписьЖурналаРегистрации(НСтр( " ru = ' Выполнение операции ' " ) , УровеньЖурналаРегистрации . Ошибка , , , ПодробноеПредставлениеОшибки); КонецПроцедуры 3 . 4 . Недопустимо перехватывать любые исключения , бесследно для системного администратора: Попытка // код , приводящий к вызову исключения . . . . Исключение // перехват любых исключений КонецПопытки; Как правило , подобная конструкция скрывает реальную проблему , которую впоследствии невозможно диагностировать . Правильно: Попытка // код , приводящий к вызову исключения . . . . Исключение // Пояснение причин перехвата всех исключений " незаметно " от пользователя . // . . . . // И запись события в журнал регистрации для системного администратора . ЗаписьЖурналаРегистрации(НСтр( " ru = ' Выполнение операции ' " ) , УровеньЖурналаРегистрации . Ошибка , , , ПодробноеПредставлениеОшибки(ИнформацияОбОшибке())); КонецПопытки; См . также Доступ к файловой системе из кода конфигурации , удаление временных файлов
```

```
Например , неправильно: Попытка КонтекстЭДОСервер . ПолучитьМакет( " КомпонентаОбмена " ); ПутьВК = КонтекстЭДОСервер . ПутьКОбъекту + " . Макет . КомпонентаОбмена " ; Исключение КонецПопытки; Правильно: МакетКомпонентыОбмена = КонтекстЭДОСервер . Метаданные() . Макеты . Найти( " КомпонентаОбмена " ); Если МакетКомпонентыОбмена <> Неопределено Тогда ПутьКМакету = КомпонентаОбмена . ПолноеИмя() КонецЕсли; 3 . 6 . При использовании транзакций следует придерживаться следующей схемы обработки исключений в коде на сервере: // 1 . Начало транзакции НачатьТранзакцию(); Попытка // 2 . Вся логика блокировки и обработки данных размещается в блоке Попытка -Исключение Запрос = Новый Запрос( " . . . " ); Выборка = Запрос . Выполнить() . Выбрать(); Пока Выборка . Следующий() Цикл . . . КонецЦикла; // 3 . В самом конце обработки данных выполняется попытка зафиксировать транзакцию ЗафиксироватьТранзакцию(); Исключение // 4 . В случае любых проблем с СУБД , транзакция сначала отменяется . . . ОтменитьТранзакцию(); // 5 . . . . затем проблема фиксируется в журнале регистрации . . . ЗаписьЖурналаРегистрации(НСтр( " ru = ' Выполнение операции ' " ) , УровеньЖурналаРегистрации . Ошибка , , , ПодробноеПредставлениеОшибки(ИнформацияОбОшибке())); // 6 . . . . после чего , проблема передается дальше вызывающему коду . ВызватьИсключение; КонецПопытки;
```

Поскольку исключение не отменяет транзакцию сразу , но запрещает успешное завершение транзакции , то все вызовы НачатьТранзакцию , с одной стороны , и ЗафиксироватьТранзакцию или ОтменитьТранзакцию , с другой стороны , должны быть парными .

Отсутствие обработки исключительных ситуаций приводит к зависшим транзакциям и к сложнодиагностируемым ошибкам вида «В этой транзакции уже происходили ошибки» в произвольных местах кода . При этом в случае вложенных операторов НачатьТранзакцию , следует обеспечить вызов всех парных операторов ОтменитьТранзакцию . Для этого в конце блока Исключение необходимо пробросить исключение выше по стеку с помощью ВызватьИсключение (как в примере выше) и соответствующим образом обработать исключение на каждом уровне стека .

- 3 . 7 . Неправильно использовать исключения для приведения значения к типу . Для таких операций необходимо использовать возможности объекта ОписаниеТипов .

## Например , неправильно:

```
Попытка КоличествоДнейРазрешения = Число(Значение); Исключение КоличествоДнейРазрешения = 0; // значение по умолчанию КонецПопытки;
```

## Правильно:

```
ОписаниеТипа = Новый ОписаниеТипов( " Число " ); КоличествоДнейРазрешения = ОписаниеТипа . ПривестиЗначение(Значение);
```

## Ограничение на использование оператора Перейти

Методическая рекомендация (полезный совет)

- 1 . В коде на встроенном языке не рекомендуется использовать оператор Перейти , так как необдуманное использование данного оператора приводит к получению запутанных , плохо структурированных модулей , по тексту которых затруднительно понять порядок исполнения и взаимозависимость фрагментов . Вместо оператора Перейти рекомендуется использовать другие конструкции встроенного языка .

## Например , неправильно:

```
Если ПланВидовРасчета = Объект . ПланВидовРасчета Тогда Перейти ~ПланВидовРасчета; КонецЕсли; правильно Если ПланВидовРасчета = Объект . ПланВидовРасчета Тогда ОбработатьПланВидовРасчета(); КонецЕсли;
```

Область применения (уточнение): управляемое приложение , обычное приложение .

- 2 . Запрещается использовать оператор Перейти в общих модулях с признаком " Клиент (управляемое приложение) " , модулях команд и в клиентском коде модулей управляемых форм , так как данный метод не поддерживается платформой 1С:Предприятие в режиме веб­клиента .

## Сортировка строк таблиц значений

- 1 . При двух и более операциях поиска в объекте ТаблицаЗначений с большим количеством строк
( * ) рекомендуется:
- Индексировать колонки , по которым выполняется поиск;
- Но только те из них , которые обладают хорошей селективностью (т . е . каждому значению этой колонки должно соответствовать небольшое количество строк) . В противном случае , индексирование не даст эффекта , либо он будет отрицательным (потрачено лишнее время на индексирование) .
* Примечание: следует ориентироваться на 1000 строк и более , а также учитывать не только размер таблицы , в которой выполняется поиск , но и сколько раз он выполняется . Например , даже если таблица относительно небольшая в 100 строк , но поиск по ней выполняется 100 раз , ее тоже имеет смысл индексировать . В то же время , нет смысла индексировать таблицу из­за только одной единственной операции поиска .
- 2 . Для поиска значений предусмотрены два метода объекта

## ТаблицаЗначений:

- Найти
- НайтиСтроки

При поиске значения в одной колонке таблицы значений оба метода одинаково эффективно используют индекс , если он был задан (см . п . 1) . Однако при поиске значения сразу по нескольким (или по всем) колонкам необходимо учитывать следующие ограничения .

- 2 . 1 . Не следует использовать метод Найти для поиска по нескольким колонкам в таблицах значений с большим количеством строк , даже если проиндексированы все колонки , обладающие хорошей селективностью . Это ограничение вызвано тем , что метод Найти выполняет поиск с применением индекса только по одному полю . Например:

```
ТЗ . Индексы . Добавить( " Колонка1 " ); ТЗ . Индексы . Добавить( " Колонка2 " ); . . . = ТЗ . Найти( " найдется все " , " Колонка1 , Колонка2 " ); // Индекс НЕ используется!
```

В этом примере , несмотря на наличие индекса для колонок Колонка1 и Колонка2 , поиск все равно будет выполняться перебором всех строк в таблице значений (что очень ресурсоемко на больших объемах данных) .

- 2 . 2 . При использовании метода НайтиСтроки в таблицах значений с большим количеством строк следует обеспечить , чтобы список полей индекса был

точно таким же , в такой же последовательности , как он задан в структуре поиска . В противном случае , индекс не будет задействован , и поиск будет выполняться перебором всех строк в таблице значений (что очень ресурсоемко на больших объемах данных) . Например:

```
ТЗ . Индексы . Добавить( " Колонка1 " ); ТЗ . Индексы . Добавить( " Колонка2 " ); . . . = ТЗ . НайтиСтроки(Новый Структура( " Колонка1 , Колонка2 " , " Ищу1 " , " Ищу2 " )); // Индекс НЕ используется! . . . = ТЗ . НайтиСтроки(Новый Структура( " Колонка1 " , " Ищу1 " ) ); // OK ­ индекс используется . . . = ТЗ . НайтиСтроки(Новый Структура( " Колонка2 " , " Ищу2 " ) ); // OK ­ индекс используется
```

## Другой пример:

```
ТЗ . Индексы . Добавить( " Колонка1 , Колонка2 " ); . . . = ТЗ . НайтиСтроки(Новый Структура( " Колонка1 , Колонка2 " , " Ищу1 " , " Ищу2 " )); // OK ­ индекс используется . . . = ТЗ . НайтиСтроки(Новый Структура( " Колонка2 , Колонка1 " , " Ищу2 " , " Ищу1 " )); // Индекс НЕ используется! . . . = ТЗ . НайтиСтроки(Новый Структура( " Колонка1 " , " Ищу1 " ) ); // Индекс НЕ используется! . . . = ТЗ . НайтиСтроки(Новый Структура( " Колонка2 " , " Ищу2 " ) ); // Индекс НЕ используется!
```

- 2 . 3 . Аналогичное ограничение действует и для метода Скопировать таблицы значений при вызове с параметром ПараметрыОтбора (Структура) .
- 3 . Не следует менять значения в проиндексированных колонках таблицы значений и менять состав строк , т . к . это приводит к перестроению индекса . Такие операции следует выполнять до индексирования таблицы значений , .
- или в другой неиндексированной таблице Например , неправильно (особенно в цикле):
- 4 . В тех случаях , когда для таблицы значений применяется сортировка по колонкам , содержащим ссылочные значения , необходимо учитывать , что при этом для каждой из этих колонок для всех строк таблицы значений системой будет выполнено обращение к информационной базе за представлением этой ссылки .

```
ЗаполнитьЗначениеСвойств(ИндексированнаяТаблица . Добавить() , Источник);
```

## Поэтому рекомендуется:

- В тех случаях , когда требуется сортировка по наименованию – сразу , на этапе заполнения , добавлять в таблицу дополнительные колонки с
- представлениями , и сортировку выполнять уже по ним . Если , конечно , это не вызовет аналогичных многократных обращений к информационной базе;
- В остальных случаях – сортировать «по ссылке» , а не по представлению . Для этого в методе Сортировать следует использовать объект СравнениеЗначений:

<!-- image -->

Особенно это важно для таблиц с большим количеством (несколько сотен и тысяч) строк , в алгоритмах критических ко времени исполнения .

## См . также

- Упорядочивание результатов запроса

## Использование объекта РегистрСведенийМенеджерЗаписи

- 1 . Чтение записи (набора записей) из регистра сведений без последующей модификации необходимо выполнять запросом .
- 2 . Объект РегистрСведенийМенеджерЗаписи следует применять только тогда , когда выполнение операций с регистром сведений требует использования отбора одновременно по всем измерениям . При этом менеджер записи использует для выполнения записи два набора записей , устанавливая им соответствующие значения отборов . Поэтому обработчики событий набора записей вызываются и тогда , когда для записи данных используется менеджер записи .
- 3 . В остальных случаях следует использовать объект РегистрСведенийНаборЗаписей . С точки зрения производительности использование менеджера записей в некоторых случаях будет столь же эффективным , как и использование набора записей , а в некоторых ­ менее , так как будут выполняться лишние действия .

## Правильно:

```
Набор = РегистрыСведений . ЗначенияПравПользователя . СоздатьНаборЗаписей(); Набор . Отбор . НаборПрав . Установить(ЗначениеНабораПрав); Для Каждого СтрокаТаблицы ИЗ ТаблицаЗначенийПрав Цикл Запись = Набор . Добавить(); Запись . НаборПрав = ЗначениеНабораПрав; Запись . Право = СтрокаТаблицы . Право; Запись . Значение = СтрокаТаблицы . Значение; КонецЦикла; Набор . Записать(); Неправильно: Для Каждого СтрокаТаблицы ИЗ ТаблицаЗначенийПрав Цикл ЭлементРегистраСведений = РегистрыСведений . ЗначенияПравПользователя . СоздатьМенеджерЗаписи(); ЭлементРегистраСведений . НаборПрав = ЗначениеНабораПрав; ЭлементРегистраСведений . Право = СтрокаТаблицы . Право; ЭлементРегистраСведений . Значение = СтрокаТаблицы . Значение; ЭлементРегистраСведений . Записать(); КонецЦикла;
```

## Копирование строк между таблицами значений (табличными частями и т. т. п . ) произвольной структуры

При копировании строк между различными таблицами значений (табличными частями и т . п . ) со схожим составом колонок следует использовать метод глобального контекста ЗаполнитьЗначенияСвойств .

Алгоритмы , использующие данный метод значительно эффективнее , чем например , многократный перебор колонок таблицы значений , выполняемый для получения их состава .

## Правильно:

## Для каждого СтрокаТаблицыИсточника Из ТаблицаИсточник Цикл СтрокаТаблицыПриемника = ТаблицаПриемник . Добавить(); ЗаполнитьЗначенияСвойств(СтрокаТаблицыПриемника , СтрокаТаблицыИсточника); КонецЦикла; Неправильно: Для каждого СтрокаТаблицыИсточника Из ТаблицаИсточник Цикл СтрокаТаблицыПриемника = ТаблицаПриемник . Добавить(); Для каждого Колонка Из ТаблицаПриемник . Колонки Цикл КолонкаТаблицыИсточника = ТаблицаИсточник . Колонки . Найти(Колонка . Имя); Если КолонкаТаблицыИсточника &lt;&gt; Неопределено Тогда СтрокаТаблицыПриемника[Колонка . Имя] = СтрокаТаблицыИсточника[Колонка . Имя]; КонецЕсли; КонецЦикла; КонецЦикла;

## Порядок записи движений документов

1 . Не рекомендуется использовать явную запись наборов записей регистров (с помощью метода Записать) в процедурах обработки проведения документов . Запись должна производится неявно системой , при завершении процедуры проведения .

В случае же нарушения этого правила , при параллельной работе нескольких пользователей , возможна ситуация возникновения взаимных блокировок при проведении документов .

- 2 . Исключением является ситуация , когда данные , сохраняемые в регистрах , необходимы в последующих алгоритмах , выполняемых до момента выхода из процедуры проведения .

## См . также

- Требования к проведению документов
- Самодостаточность регистров
- Использование активности движений

## Получение представлений для ссылочных значений в табличном документе

Методическая рекомендация (полезный совет)

При формировании табличного документа запрещено в качестве параметров ячеек с типом заполнения Параметр указывать ссылочные значения , поскольку в этом случае в момент вывода данных в табличный документ будет выполнено многократное обращение к базе данных для получения представлений этих значений .

Поэтому в качестве параметров следует указывать сами представления .

Исключением могут быть случаи , когда для получения представлений придется выполнять аналогичное многократное обращение к базе данных .

При этом следует иметь ввиду , что при получении представлений для полей непосредственно в самом запросе (через поле Представление или функцией Представление(&lt;Имя поля&gt;)) выполняется неявное соединение с таблицей объекта , для которого получаются представления . Для полей составного типа ­ несколько соединений , для каждого из типов , входящих в состав . Это может приводить к увеличению времени выполнения запроса (и как следствие , общего времени формирования итогового документа) , а при большом количестве типов – к невозможности его выполнения в клиент­серверной версии из­за ограничения Microsoft SQL Server 2005 , по которому в запросе не может участвовать больше 256 таблиц . Такие случаи также могут быть исключением для данного правила , в них представления для ссылочных значений допускается получать в момент их вывода в табличный документ .

Поскольку однозначно рекомендовать ­ какой из способов получения представлений следует выбрать ­ нельзя , такой выбор должен делаться разработчиком самостоятельно , на основании данных , полученных экспериментально .

## См . также

- Особенности работы с полем Представление и функцией Представление() языка запросов (статья на ИТС)
- Вывод ссылочных полей

## Программное создание прикладных объектов

1 . Для программного создания прикладных объектов следует использовать методы соответствующих менеджеров (СоздатьЭлемент , СоздатьДокумент , СоздатьНаборЗаписей и т . д . ) .

Для программного создания прикладных объектов , у которых существует соответствующие менеджеры объектов , использование конструктора (оператор встроенного языка Новый) запрещается .

Правильно:

ДокументПриходная

Документы

.

=

ПоступлениеТоваровУслуг

Неправильно:

```
ДокументПриходная = Новый( " ДокументОбъект . ПоступлениеТоваровУслуг " );
```

2 . При программном создании объекта следует явно вызывать метод объекта Заполнить . Если данных для заполнения нет , то передать значение Неопределено . В этом случае корректно отработают свойства реквизитов объекта " Значение заполнения " , будет вызван обработчик ОбработкаЗаполнения и подписки на это событие , как при интерактивной работе с объектом .

Например , неправильно:

```
Папка = Справочники . ПапкиФайлов . СоздатьЭлемент(); // . . . Папка . Записать();
```

Правильно:

```
Папка = Справочники . ПапкиФайлов . СоздатьЭлемент(); // . . . Папка . Заполнить(Неопределено); // . . . Папка . Записать();
```

Исключением могут быть случаи , когда объект полностью загружается из источника при обмене данными или восстановление базы из резервной копии (загрузка из XML) .

.

СоздатьДокумент();

## Использование модуля объекта , модуля менеджера объекта и общих модулей

Методическая рекомендация (полезный совет)

1 . Модуль объекта предназначен для реализации поведения отдельного экземпляра объекта (СправочникОбъект , ДокументОбъект и т . п . ) . В модуле объекта размещаются процедуры и функции , которые работают с данными объекта (ЭтотОбъект и переменные модуля объекта) , в том числе когда он еще не записан в информационную базу .

Например , в модуле объекта могут размещаться:

- обработчики событий объекта
- процедуры заполнения экземпляра объекта .

Следует иметь в виду , что для вызова экспортных процедур и функций модуля объекта из других модулей может потребоваться предварительно получить сам экземпляр объекта из информационной базы с помощью метода ПолучитьОбъект . При этом происходит загрузка объекта из базы целиком , вместе с его табличными частями , что достаточно ресурсоемко .

См . также: Чтение отдельных реквизитов объекта из базы данных

2 . Модуль менеджера объекта предназначен для размещения " статической " функциональности , которая логически неразрывно связана с объектом метаданных , но не зависит от состояния конкретного экземпляра объекта данных . Это могут быть процедуры и функции:

- относящиеся не к одному , а сразу к некоторой совокупности объектов . Например , это функции для вывода на печать списка объектов; функции , возвращающие информацию , общую для всех экземпляров объекта метаданных; процедуры обновления данных информационной базы , которые связаны с объектом метаданных; и т . п .
- которые работают с объектом , записанным в ИБ . В таких функциях входным параметром является ссылка на объект . Например , это функции для получения печатной формы по ссылке на объект , процедуры формирования движений по ссылке на объект и т . п .

Для выполнения функций модуля менеджера объекта не должен требоваться экземпляр объекта данных (СправочникОбъект , ДокументОбъект и т . п . ) .

- 3 . Если функциональность невозможно однозначно отнести к тому или иному объекту метаданных , то она является логически общей для нескольких объектов . В этом случае ее следует размещать в общем модуле .

## Ограничения на использование экспортных процедур и функций

Не следует размещать экспортные процедуры и функции в модулях команд и общих команд . К этим модулям нет возможности обращаться из внешнего по отношению к ним кода , поэтому экспортные процедуры и функции в этих модулях не имеют смысла .

## Установка параметров выбора и связей параметров выбора для объектов метаданных

- 1 . Как правило , такие ограничения бизнес­логики как ограничения выбора , должны быть одинаковыми для всех форм , в которых редактируется тот или иной объект . Поэтому задавать параметры выбора и связи параметров выбора рекомендуется в свойствах объектов метаданных ­ в реквизитах справочников , документов и т . п .
- 2 . Однако могут встречаться случаи , когда ограничения выбора могут зависеть от конкретного сценария работы . В таких случаях параметры выбора могут быть уточнены по месту , в конкретной форме .

Например , в конфигурации имеются

- справочник Сотрудники , в котором есть реквизиты Организация и ВидСотрудника (перечисление со значениями Основной/ Совместитель);
- документ ПриказОПриеме , в котором есть реквизит Организация и Сотрудник; при этом для реквизита Сотрудник документа ПриказОПриеме задана связь параметра выбора Отбор . Организация с реквизитом Организация .

Требуется реализовать возможность выбора только основных сотрудников в зависимости от значения функциональной опции

ВыбратьТолькоИзОсновыхСотрудников . Для этого необходимо

- в форме документа ПриказОПриеме реализовать дополнительный реквизит формы ВидыСотрудников ,
- после чего для поля формы Сотрудник может быть установлена связь параметра выбора Отбор . ВидСотрудника с реквизитом формы ВидыСотрудников ,
- при этом реквизит формы ВидыСотрудников заполняется на основании анализа функциональной опции .

(При этом установить для реквизита Сотрудник документа ПриказОПриеме связь для параметра выбора Отбор . ВидСотрудника нет возможности , т . к . реквизита ВидСотрудника в документе ПриказОПриеме не существует . )

Тогда установка связи для параметра Отбор . Организация в свойствах реквизита Сотрудник документа ПриказОПриеме и связи для параметра Отбор . ВидСотрудника в поле формы документа ПриказОПриеме приведет к тому , что в режиме 1С:Предприятия будут работать обе связи параметра выбора . Таким образом , при выборе сотрудника в форме приказа о приеме отбор в списке сотрудников будет установлен как по организации ,

заполненной в документе , так и по виду сотрудника , который будет определен на основании функциональной опции .

## Использование РеквизитФормыВЗначение и ДанныеФормыВЗначение

Методическая рекомендация (полезный совет)

В большинстве случаев , в модулях форм следует использовать метод формы РеквизитФормыВЗначение вместо метода ДанныеФормыВЗначение .

Рекомендация обусловлена соображениями унификации прикладного кода и тем , что синтаксис метода

```
РеквизитФормыВЗначение проще , чем у ДанныеФормыВЗначение (а следовательно , меньше вероятность ошибки) . В ДанныеФормыВЗначение необходимо
```

дополнительно передавать тип значения:

ТаблицаПодписей = ДанныеФормыВЗначение(ТаблицаПодписей , Тип( " ТаблицаЗначений " ));

а для РеквизитФормыВЗначение это не обязательно , а в практическом плане ­ избыточно:

```
ТаблицаПодписей = РеквизитФормыВЗначение( " ТаблицаПодписей " );
```

Наличие в платформе 1С:Предприятие метода формы РеквизитФормыВЗначение (наряду с методом глобального контекста ДанныеФормыВЗначение) объясняется только удобством его применения . С точки зрения эффективности и результата методы работают одинаково .

## Применение параметров отчета в СКД

При использовании параметров в отчетах , реализуемых с помощью системы компоновки данных , следует придерживаться следующих рекомендаций .

- Избегать использования параметров отчета в том случае , если можно обойтись " обычным " управлением элементами отбора . Например , не применять в запросах СКД условия типа:

ГДЕ Организация = &amp;Организация

Взамен этого дать пользователю возможность управлять элементом отбора Организация .

- Избегать применения обязательных параметров для того , чтобы исключить ситуацию , когда пользователь может отключить параметры отчета , ожидая отмены их применения , и получить при этом ошибку выполнения " Не задан параметр отчета " . Для этого следует использовать синтаксические элементы расширения языка запросов системы компоновки данных {ГДЕ . . . } .

Например , применение конструкции

{ГДЕ Сведения . Период &gt;= &amp;ДатаНачала , Сведения . Период &lt;= &amp;ДатаОкончания}

приведет к тому , что оба параметра отчета ДатаНачала и ДатаОкончания будут необязательными и при их отключении пользователем будут отключены соответствующие фрагменты условия .

## Использование объектов типа Структура

Требования , предъявляемые данным стандартом к Структурам , направлены на повышение читаемости кода и упрощение внесения изменений в код разными авторами (разработчиками) как при коллективной разработке , так и при доработке прикладных решений на конкретных внедрениях . Повышение читаемости кода в свою очередь ведет к уменьшению допускаемых при разработке ошибок и повышает качество прикладного решения .

- 1 . При создании объекта типа Структура не рекомендуется передавать в конструктор более 3­х значений свойств . Вместо этого рекомендуется использовать метод Вставить или присваивать значения свойствам явным образом

## Неправильно

- ПараметрыФормыКомпоновки = Новый Структура( " НеПомещатьНастройкиВСхемуКомпоновкиДанных , |НеРедактироватьСхемуКомпоновкиДанных , |НеНастраиватьУсловноеОформление , |НеНастраиватьВыбор , |НеНастраиватьПорядок , |АдресСхемыКомпоновкиДанных , |АдресНастроекКомпоновкиДанных , |УникальныйИдентификатор , |Заголовок " , Истина , Истина , Истина , Истина , Истина , ТекущиеДанные . АдресСхемыКомпоновкиДанных , ?(АдресНастроекСхемыКомпоновкиДанных &lt;&gt; Неопределено , АдресНастроекСхемыКомпоновкиДанных , ТекущиеДанные . АдресНастроекСхемыКомпоновкиДанных) , УникальныйИдентификатор , ЗаголовокФормыНастройкиСхемыКомпоновкиДанных)); Правильно ПараметрыФормыКомпоновки = Новый Структура; ПараметрыФормыКомпоновки . Вставить( " НеПомещатьНастройкиВСхемуКомпоновкиДанных " , Истина); ПараметрыФормыКомпоновки . Вставить( " НеРедактироватьСхемуКомпоновкиДанных " , Истина); ПараметрыФормыКомпоновки . Вставить( " НеРедактироватьСхемуКомпоновкиДанных " , Истина); ПараметрыФормыКомпоновки . Вставить( " НеНастраиватьВыбор " , Истина); ПараметрыФормыКомпоновки . Вставить( " НеНастраиватьПорядок " , Истина); ПараметрыФормыКомпоновки . Вставить( " АдресСхемыКомпоновкиДанных " , ТекущиеДанные . АдресСхемыКомпоновкиДанных); ПараметрыФормыКомпоновки . Вставить( " АдресНастроекКомпоновкиДанных " , ? (АдресНастроекСхемыКомпоновкиДанных &lt;&gt; Неопределено , АдресНастроекСхемыКомпоновкиДанных , ТекущиеДанные . АдресНастроекСхемыКомпоновкиДанных)); ПараметрыФормыКомпоновки . Вставить( " УникальныйИдентификатор " , УникальныйИдентификатор); ПараметрыФормыКомпоновки . Вставить( " Заголовок " , ЗаголовокФормыНастройкиСхемыКомпоновкиДанных); 2 . Не рекомендуется в конструкторе структуры использовать конструкторы других объектов , если эти конструкторы принимают параметры . В частности в конструкторе одной структуры не рекомендуется создавать другие структуры с объявлением значений свойств . Неправильно НоменклатураСервер . ЗаполнитьСлужебныеРеквизитыПоНоменклатуреВКоллекции( Объект . Товары , Новый Структура( " ЗаполнитьПризнакХарактеристикиИспользуются , |ЗаполнитьПризнакТипНоменклатуры , ЗаполнитьПризнакВариантОформленияПродажи " , Новый Структура( " Номенклатура " , " ХарактеристикиИспользуются " ) , Новый Структура( " Номенклатура " , " ТипНоменклатуры " ) , Новый Структура( " Номенклатура " , " ВариантОформленияПродажи " ) ) );

Правильно

```
ПараметрыЗаполненияРеквизитов = Новый Структура; ПараметрыЗаполненияРеквизитов . Вставить( " ЗаполнитьПризнакХарактеристикиИспользуются " , Новый Структура( " Номенклатура " , " ХарактеристикиИспользуются " )); ПараметрыЗаполненияРеквизитов . Вставить( " ЗаполнитьПризнакТипНоменклатуры " , Новый Структура( " Номенклатура " , " ТипНоменклатуры " )); НоменклатураСервер . ЗаполнитьСлужебныеРеквизитыПоНоменклатуреВКоллекции(Объект . Товары , ПараметрыЗаполненияРеквизитов); 3 . Не рекомендуется в конструкторе структуры вызывать функции с большим (более 3) количеством параметров . Неправильно СведенияОТоваре = Новый Структура( " ПараметрыТовара , ЦенаПродажиИОстаткиТовара , ЦенаЗакупкиИОстаткиТовара " , ПодборТоваровКлиентСервер . ПараметрыТовара() , ПодборТоваровВызовСервера . ЦенаПродажиИОстаткиТовара( Номенклатура , Характеристика , Соглашение , Валюта , ВидыЦен) , ЦенаЗакупкиИОстаткиТовара( Номенклатура , Характеристика , Соглашение , Валюта , ВидыЦен)); Правильно СведенияОТоваре = Новый Структура( " ПараметрыТовара , ЦенаПродажиИОстаткиТовара , ЦенаЗакупкиИОстаткиТовара " ); СведенияОТоваре . ПараметрыТовара = ПодборТоваровКлиентСервер . ПараметрыТовара(); СведенияОТоваре . ЦенаПродажиИОстаткиТовара = ПодборТоваровВызовСервера . ЦенаПродажиИОстаткиТовара( Номенклатура , Характеристика , Соглашение , Валюта , ВидыЦен); СведенияОТоваре . ЦенаПродажиИОстаткиТовара = ЦенаЗакупкиИОстаткиТовара . ЦенаЗакупкиИОстаткиТовара( Номенклатура , Характеристика , Соглашение , Валюта , ВидыЦен);
```

## См . также

- Параметры процедур и функций
- Особенности использования структур в качестве параметров процедур и функций

## Настройка обмена данными для классификаторов между различными информационными базами

1 . К классификаторам относятся справочники и регистры сведений , которые содержат условно ­ постоянную информацию , одинаковую для всех совместно используемых информационных баз . Примерами классификаторов являются классификаторы банков , стран мира , валют , общероссийский классификатор единиц измерения (ОКЕИ) , адресный классификатор и пр .

При использовании инструмента «Конвертация данных» для создания обменов данными между различными конфигурациями , необходимо придерживаться следующих рекомендаций по синхронизации классификаторов .

- 2 . Данные классификаторов объектного типа (например , страны мира , ОКЕИ и т . п . ) должны сопоставляться по уникальным идентификаторам ссылок , а в случае , если сопоставление по уникальным идентификаторам ссылок не дало положительного результата , то сопоставление должно продолжаться по полям поиска (режим автоматического сопоставления) . Для этого требуется:
- в правиле конвертации объекта (ПКО) классификатора установить признаки:
- " Искать объект приемника по внутреннему идентификатору объекта источника "
- " Продолжить поиск по полям поиска , если по идентификатору объект приемник не найден "
- указать правила конвертации свойств (ПКС) , которые используются в качестве полей поиска . Например , " БИК " для классификатора банков .
- при необходимости определить код обработчика ПКО " Поля поиска " в случае сложного сценария идентификации объектов .

В противном случае , данные классификаторов могут продублироваться , так как у одинаковых с прикладной точки зрения элементов справочника в разных базах , как правило , различные уникальные идентификаторы ссылок .

- 3 . Данные классификаторов , представленные наборами записей (например , адресный классификатор) в обмене участвовать не должны . Данные таких классификаторов должны заполняться и поддерживаться в актуальном состоянии отдельно в каждой информационной базе , между которыми настроен обмен данными . Это позволяет предотвратить избыточную миграцию данных этих классификаторов при обмене данными .

## См . также

- Описание инструмента «Конвертация данных» в разделе «Методическая поддержка 1С:Предприятия 8»

## Разработка планов обмена с отборами

Рекомендация (полезный совет)

1 . 1 . Как правило , для синхронизации данных между различными конфигурациями и для организации распределенной информационной базы (РИБ) используется технология планов обмена . В этом случае часто возникает задача организации обмена не всеми данными информационной базы , а только частью данных . Например , данные могут быть отобраны для отправки в другие узлы в разрезе организаций , складов , подразделений и пр .

Для определения узлов ­ получателей для отправки данных следует использовать события ПередЗаписью и ПередУдалением объектов информационной базы , в которых предусмотреть логику регистрации изменений данных на узлах планов обмена (далее – логика регистрации) .

При использовании в конфигурации подсистемы «Обмен данными» Библиотеки стандартных подсистем логика регистрации может быть задана декларативно в правилах регистрации объектов (ПРО) , которые разрабатываются в конфигурации «Конвертация данных» . Подробнее см . документацию к подсистеме «Обмен данными» .

- 1 . 2 . Кроме того , при проектировании логики регистрации необходимо учитывать следующие особенности:
- данные из сообщения обмена загружаются в произвольном порядке , поэтому на момент выполнения логики регистрации необходимые ей данные могут быть еще не загружены;
- логика регистрации в том числе выполняется в контексте загрузки данных в транзакции записи объекта , при этом признак ОбменДанными . Загрузка игнорируется . Поэтому любые ошибки логики регистрации приведут к аварийному завершению загрузки данных из сообщения обмена;
- в обмене в распределенной информационной базе (РИБ) могут участвовать не все данные , например , движения в регистрах мигрируют между узлами , а регистраторы (документы) – нет;
- обращение к полям связанных таблиц " через точку " приводит к неявному соединению с дополнительными таблицами , что снижает производительность обмена .

При разработке планов обмена для синхронизации с другими программами (не РИБ, Б, по правилам конвертации) с помощью подсистемы «Обмен данными» Библиотеки стандартных подсистем первые два пункта не требуется учитывать в правилах регистрации для ссылочных типов объектов (СправочникСсылка , ДокументСсыслка и пр . ) , поскольку регистрация ссылочных объектов выполняется отложенно отдельной операцией после загрузки всех данных из сообщения обмена .

- 2 . С учетом перечисленных особенностей рекомендуется придерживаться следующих правил .
- 2 . 1 . Обеспечить самодостаточность данных , участвующих в обмене . Таблицы данных (справочники , документы , регистры и пр . ) , участвующие в обмене , должны содержать все необходимые данные для выполнения логики регистрации . Логика регистрации не должна обращаться к полям связанных таблиц , она должна оперировать только данными основной таблицы , регистрацию изменений данных которой необходимо выполнить .

## Пример:

- Данные регистрируются в разрезе организаций .
- В обмене участвует две таблицы: документ и регистр накопления , в котором содержатся движения документа . И документ , и регистр накопления являются самодостаточными , т . к . содержат ссылку на организацию .
- При записи данных пользователем или при загрузке данных , логика регистрации отрабатывает независимо для документа и для набора записей регистра .

См . также: Самодостаточность регистров , Разыменование ссылочных полей составного типа в языке запросов

Если требование самодостаточности данных нельзя поддержать по другим соображениям , то нужно рассмотреть следующие варианты .

- 2 . 2 . Исключить из обмена вторичные данные . Данные , которые могут быть вычислены независимо в каждой из информационных баз , участвующих в обмене , следует исключить из состава плана обмена . Тем самым , более не требуется логика регистрации этих данных , которая могла обращаться к полям связанных таблиц , участвующих в обмене .

## Пример:

- Данные регистрируются в разрезе организаций .
- В обмене участвует только одна таблица – документы поступления товаров .
- Есть регистр сведений , который используется для определения прав доступа пользователей к документам поступления товаров . Этот регистр не является самодостаточным , т . к . не содержит ссылку на организацию , поэтому он не участвует в обмене данными .
- Данные регистра вычисляются независимо в каждом узле распределенной информационной базы при загрузке документов поступления товаров .
- 2 . 3 . Регистрировать изменения связанных данных . Если в обмене участвуют несколько логически взаимосвязанных таблиц данных , то логика регистрации должна регистрировать к выгрузке данные всех взаимосвязанных таблиц вне зависимости от того , для какой таблицы данных выполняется логика

регистрации . При этом логика регистрации не должна аварийно прерываться в случае , когда необходимые для логики регистрации данные отсутствуют .

## Пример:

- Данные регистрируются в разрезе организаций .
- В обмене участвует две таблицы: справочник " Основные средства " и регистр сведений " Основные средства организаций " . В регистре сведений хранится связь основного средства и организации , которой принадлежит основное средство .
- При записи элемента справочника , и при записи набора записей регистра к выгрузке регистрируются как элемент справочника , так и набор записей регистра .
- Если при загрузке данных из сообщения обмена сначала выполняется загрузка элемента справочника , то он записывается в базу данных , но не регистрируется к выгрузке на другие узлы планов обмена , т . к . логика регистрации проверяет , что набор записей регистра еще не загружен .
- При последующей загрузке набора записей регистра выполняется регистрация изменений как самого набора записей , так и соответствующего элемента справочника .

## Безопасность прикладного программного интерфейса сервера

При работе в режиме управляемого приложения , клиентское приложение (тонкий или веб­клиент) обращается к серверу 1С:Предприятия посредством открытого HTTP­протокола . Таким образом , сервер 1С:Предприятия может быть вызван извне сторонними программами тем же способом , как это штатно делает клиентское приложение , и злоумышленник может получить несанкционированный доступ к пользовательским данным , нарушить работоспособность сервера .

- 1 . Несанкционированный вызов серверного кода конфигурации с клиента .
- 1 . 1 . Потенциальную угрозу безопасности представляют все серверные процедуры и функции , доступные для вызова из клиентского кода . Они составляют прикладной программный интерфейс сервера 1С:Предприятия . К ним , как правило , относятся:
- Экспортные процедуры и функции , размещенные в общих модулях с признаками " Сервер " и " Вызов сервера " . Вызов таких процедур и функций возможен напрямую с клиента .

Подробнее см . Ограничение на установку признака " Вызов сервера " у общих модулей

- Все процедуры и функции модулей форм объектов с директивами компиляции &amp;НаСервере , &amp;НаСервереБезКонтекста . Вызов таких процедур и функций доступен из контекста клиента после успешного получения формы , даже если эти процедуры и функции не экспортные . Это делает возможным вызов кода в контексте , который не предполагался разработчиком .

Например , код модуля формы Справочник . Сотрудники . ФормаЭлемента:

&amp;НаКлиенте

Процедура УволитьСотрудника(Команда)

Если ДатаРегистрацииУвольнения &gt; ДатаЗапрета Тогда ЗарегистрироватьУвольнение();

КонецЕсли;

КонецПроцедуры

&amp;НаСервере

Процедура ЗарегистрироватьУвольнение()

.

.

.

КонецПроцедуры

Пример стороннего кода , вызывающий напрямую серверную процедуру для обхода проверки , предусмотренной разработчиком формы в обработке команды

## УволитьСотрудника:

```
ПараметрыФормы = Новый Структура( " Ключ " , ВыбранныйСотрудник) Форма = ПолучитьФорму( " Справочник . Сотрудники . ФормаЭлемента " , ПараметрыФормы); Форма . ЗарегистрироватьУвольнение();
```

- 1 . 2 . В общем случае не рекомендуется размещать в серверных процедурах и функциях модулей форм код , обеспечивающий бизнес­логику , и который не относится к клиент­серверному взаимодействию и обработке реквизитов формы .
- 1 . 3 . Особого внимания требуют серверные процедуры и функции , использующие установку привилегированного режима , или размещенные в общих модулях с признаком

## Привилегированный .

- 2 . Проникновение небезопасного кода на сервер и его выполнение .

Любые возможности конфигурации по выполнению " внешнего " кода или произвольных текстов запросов на сервере , не являющихся частью самого прикладного решения , представляют серьезную опасность .

Также опасны внешние отчеты и обработки , COM ­ объекты и внешние компоненты . В частности , код внешних обработок может непосредственно обращаться ко всем общим модулям без признака " Вызов сервера " , к модулям объектов и менеджеров объектов конфигурации , пытатся переходить в привилегированный режим .

Такие возможности создают прямую угрозу работоспособности сервера из­за некорректного или преднамеренно вредоносного кода: порчу или похищение данных , зависание или остановка рабочего процесса из­за зацикливания , утечек памяти , ресурсоемких операций и запросов и т . д .

Подробнее см . Ограничение на выполнение " внешнего " кода на сервере .

- 3 . Клиентское приложение (тонкий клиент или веб­браузер) не гарантирует безопасность данных , переданных на сторону клиента . Эти данные легко могут быть перехвачены и прочитаны вредоносным программным обеспечением , установленным на клиентском компьютере .

Серверные процедуры и функции должны возвращать в форму только окончательный результат расчета . Следует избегать передачи в форму исходных или промежуточных данных , которые могут раскрывать побочную , возможно приватную информацию бизнес­процесса .

## Ограничение на выполнение «внешнего» кода на сервере

1 . 1 . Для прикладных решений , работающих в модели сервиса , запрещено выполнение любого кода или текстов запросов на сервере 1С:Предприятия , которые не являются частью самого прикладного решения (конфигурации) .

Примеры недопустимого выполнения «внешнего» кода:

- внешние отчеты и обработки (печатные формы и т . п . ) , и любые другие аналогичные возможности , с помощью которых пользователи подключают к конфигурации внешний код;
- алгоритмы на встроенном языке , тексты запросов или их фрагменты , которые пользователи интерактивно вводят в режиме 1С:Предприятия , и которые затем передаются в методы глобального контекста Выполнить или Вычислить);
- изменение пользователями схем компоновки данных в отчетах , в которых разрешено использование внешних функций (эта возможность закрыта при использовании стандартной формы отчета: она не позволяет пользователям изменять схему компоновки данных , а из пользовательских полей использовать функции общих модулей нельзя) . В том числе , возможность загрузки пользователями схем компоновки данных из внешних файлов .

Это требование обусловлено , прежде всего , требованиями к надежности сервиса . Внешний код , умышленно или неумышленно , может представлять собой угрозу работоспособности сервиса .

Ограничение не распространяется на код , выполняемый на клиенте .

- 1 . 2 . При разработке решений , работающих в модели сервиса , нужно учитывать , что опасно не только непосредственное выполнение кода , написанного в режиме Предприятие , но и те места , где методами Выполнить или Вычислить исполняется код , сконструированный на основе параметров , переданных в серверные функции и процедуры .

Например , код написан следующим образом:

- в клиентской функции в форме создается структура , в которую вставляется строка , написанная разработчиком конфигурации;
- клиентская функция передает эту структуру в серверную функцию формы;
- серверная функция формы вызывает серверную функцию общего модуля;
- в серверной функции исполняется код из строки , вставленной в структуру .

В этом случае требования п . 1 . 1 . соблюдены – не выполняется код , который интерактивно вводит пользователь , но , тем не менее , есть следующая

## уязвимость:

- злоумышленник создает структуру , в которую вставляет строку с вредоносным кодом;
- злоумышленник вызывает клиентскую функцию формы и таким образом исполняет вредоносный код на сервере .

Еще опаснее , если методы , в которых с помощью Выполнить или Вычислить исполняется код , принимаемый из параметров , будут располагаться в модулях с установленным признаком ВызовСервера .

- 1 . 3 . Для исключения уязвимостей , описанных в пунктах 1 . 1 и 1 . 2 , нужно в серверных процедурах и функциях вызов методов Выполнить или Вычислить предварять кодом:
- 2 . Исключение могут составлять отдельные обоснованные случаи , когда безопасность пользовательских данных гарантируется какими­либо альтернативными способами . К таким исключением должны быть даны необходимые пояснения в тексте комментария в коде конфигурации .
- 3 . В случае если в конфигурации предусмотрен перенос данных в сервис из локальной версии программы , необходимо обеспечить отключение всех пользовательских фрагментов кода или текстов запросов , которые были введены в локальной версии .

```
Если ОбщегоНазначенияПовтИсп . РазделениеВключено() Тогда ТекстИсключения = НСтр( " ru = ' Попытка выполнения недопустимых методов в режиме сервиса . ' " ); ВызватьИсключение ТекстИсключения; КонецЕсли;
```

При использовании в конфигурации Библиотеки стандартных подсистем , также имеется возможность предварительной обработки данных , загружаемых из локальной версии в сервис (см . документацию к подсистеме Работа в модели сервиса) .

## См . также

- Облачные технологии (статья на сайте 1c . ru)
- Безопасность прикладного программного интерфейса сервера

## Ограничение на установку признака «Вызов сервера» у общих модулей

1 . Не следует всем общим модулям с признаком Сервер принудительно устанавливать флажок Вызов сервера . В таких общих модулях следует размещать только те процедуры и функции , которые действительно предназначены для вызова из клиентского кода и гарантируют выполнение только тех действий (и передачи только тех данных на сторону клиента) , которые разрешены пользователю при его работе в программе . Например , серверная функция , реализующая некоторый алгоритм расчета , должна передавать на сторону клиента окончательный результат этого расчета , но не исходные (или промежуточные) данные для расчета , которые сами по себе могут быть недоступны текущему пользователю .

См . также: Безопасность прикладного программного интерфейса сервера , Правила создания общих модулей

Особого внимания требуют процедуры и функции , использующие установку привилегированного режима , или размещенные в общих модулях с признаком Привилегированный .

Серверные процедуры и функции , не предназначенные для вызова из клиентского кода , следует размещать в общих модулях без признака Вызов сервера .

- 2 . 1 . Как правило , при разработке объектов конфигурации (справочников , документов и пр . ) исходят из того , что в управляемом режиме работа с экземплярами этих объектов (СправочникОбъект , ДокументОбъект и т . д . ) выполняется на стороне сервера . Поэтому в управляемом режиме не гарантируется возможность работы с ними на стороне клиентского приложения .

В частности , в толстом клиенте в режиме управляемого приложения не следует создавать или получать объекты:

- в клиентских общих модулях (пользуясь инструкцией препроцессора ТолстыйКлиентУправляемоеПриложение);
- в обычных формах при запуске в управляемом режиме . Такие формы следует использовать только в режиме обычного приложения .

Это позволит избежать выполнения кода модулей объектов и подписок на события на клиенте , а также избыточных серверных вызовов процедур и функций общих модулей из этого кода .

См . также: Поддержка толстого клиента , управляемое приложение , клиент­сервер

- 2 . 2 . Если конфигурация не рассчитана на работу в толстом клиенте , управляемое приложение , следует снять флажок Толстый клиент

(управляемое приложение , режим клиент ­ сервер) , для того чтобы при проверке конфигурации избежать ложных сообщений об ошибках .

## Использование модулей с повторным использованием возвращаемых значений

Методическая рекомендация (полезный совет)

- 1 . Общие модули с повторным использованием возвращаемых значений (далее: кэш) предусмотрены для кэширования результатов работы функций , которые в них размещены ­ на время сеанса или на время вызова . Их следует применять для экономии вычислительных ресурсов сервера и для минимизации клиент ­ серверного взаимодействия .

См . также: раздел " Повторное использование возвращаемых значений " документации по платформе 1С:Предприятие , Использование значений, й, влияющих на поведение клиентского приложения

- 2 . В то же время , чрезмерное (неоправданное) применение общих модулей с повторным использованием возвращаемых значений может приводить к излишнему потреблению памяти .
- 2 . 1 . Недопустимо создать общие модули с повторным использованием , из которых возвращаются данные , вычисление которых выполняется быстрее , чем получение из кэша . Например , строковые константы . Кроме того , что получение строковой константы каждый раз будет работать гораздо быстрее , чем получение ее из общего модуля с повторным использованием , эти данные будут занимать память кэша .

Например , неправильно размещать в модуле с повторным использованием:

Функция ИмяПакетаУправления() Экспорт Возврат " ManagementPackage " ; КонецФункции

Имеет смысл кэшировать данные , полученные из базы данных , внешних источников данных или путем сложных (ресурсоемких) вычислений . Причем в ряде случаев , даже значения , полученные из базы данных , не стоит кэшировать , если выгода от их кэширования – неочевидна . Например , не стоит кэшировать константы (объект метаданных) примитивных типов , поскольку часто они привносят лишь незначительную долю от общего времени выполнения ресурсоемкой операции .

- 2 . 2 . Следует помещать в кэш только такие данные , к которым потом будут часто обращаться .

В частности , следует иметь в виду , что кэш не хранит данные вечно . Закэшированное значение будет удалено из кэша через 20 минут после вычисления или через 6 минут после последнего использования (в зависимости от того , что наступит раньше * ) . Кроме этого значение будет удалено при нехватке оперативной памяти в рабочем процессе сервера , при

перезапуске рабочего процесса и при переключении клиента на другой рабочий процесс . Поэтому если никто " не успел " воспользоваться данными из кэша , то этот ресурс был потрачен зря .

* Примечание: конкретные цифры могут варьироваться в зависимости от используемой версии платформы 1С:Предприятие .

- 2 . 3 . Диапазон значений входных параметров функций , размещенных в общих модулей с повторным использованием , не должен быть широким . Например , в конфигурации предусмотрена функция , получающая на вход контрагента . Если контрагентов в базе очень много , а сценарий работы пользователей таков , что вероятность того , что кто­то за 5 минут обратится к этому же контрагенту , очень невысокая , то ресурсы будут потрачены впустую . Кроме того , если эту «трату» умножить на количество одновременно работающих пользователей , то бесполезные расходы ресурсов становятся значительными .
- 3 . Не следует изменять данные , полученные из кэша . В противном случае , возможны скрытые ошибки в работе программы , а также бесполезное расходование памяти (ресурсов кэша) . Поэтому в качестве возвращаемых значений рекомендуется использовать значения , состояние которых изменить нельзя , например: ФиксированныйМассив , ФиксированнаяСтруктура .

Это ограничение вызвано тем , что кэш возвращает каждый раз не копию объекта , а ссылку на один и тот же объект в памяти . Например , если в массив , который возвращает функция с повторным использованием , при каждом вызове при проведении документов дописывать новое значение , то в результате кэш очень быстро «распухнет» . Кроме того , при очередном сбросе кэша , добавленные значения будут потеряны и код , который на них опирался , будет работать некорректно .

- 4 . Если в модуле с повторным использованием размещено несколько экспортных функций , которые не только вызываются «снаружи» , но и вызывают друг друга , то следует иметь в виду , что результат «внутренних» вызовов не кэшируется .

Например , если в модуле ОбменДаннымиПовтИсп размещено две экспортных функции:

Функция

АвтономнаяРаботаПоддерживается()

Возврат

.

.

.

КонецФункции

Функция ЭтоАвтономноеРабочееМесто() Экспорт Возврат АвтономнаяРаботаПоддерживается() И . . . ; КонецФункции

которые последовательно вызываются из прикладного кода ,

. . . = ОбменДаннымиПовтИсп . АвтономнаяРаботаПоддерживается(); . . . = ОбменДаннымиПовтИсп . ЭтоАвтономноеРабочееМесто();

Экспорт

<!-- image -->

## Использование значений , влияющих на поведение клиентского приложения

В том случае , если поведение целого ряда форм или команд зависит от одних и тех же значений (параметров , задаваемых пользователем или иных настроек поведения клиентского приложения) , для минимизации клиент -серверного взаимодействия рекомендуется применять общие модули с повторным использованием возвращаемых значений (свойство «Повторное использование возвращаемых значений» равно «На время сеанса») . Применение таких общих модулей допускается , если изменение соответствующего значения в течение сеанса не является критичным , т . е . в течение всего сеанса может использоваться однажды полученное значение .

При этом функции такого общего модуля должны за один вызов возвращать сразу все значения , которые могут понадобиться в тех или иных обстоятельствах .

Например , если при работе всех форм подсистемы регистрации занятости сотрудников , требуются пользовательские параметры «Время занятости по умолчанию» , «Время начала рабочего дня» и «Время окончания рабочего дня» , то все эти параметры необходимо получать одним вызовом , возвращающим структуру с тремя полями:

```
Настройки = НастройкиПодсистемыРегистрации(); ВремяНачала = Настройки . ВремяНачалаРабочегоДня; ВремяОкончания = Настройки . ВремяОкончанияРабочегоДня;
```

Следует помнить , что применение клиентских общих модулей с повторным использованием возвращаемых значений должно быть разумно ограничено . В частности , данные , влияющие на поведение отдельных форм , рекомендуется размещать в реквизитах самой формы , получая их при создании формы на сервере . И только если от некоторого значения (или нескольких значений) зависит поведение команд или большого числа форм приложения , следует применять общие модули с повторным использованием возвращаемых значений .

Не рекомендуется использовать переменные модуля управляемого приложения и модуля обычного приложения для минимизации клиентсерверного взаимодействия .

## Получение предопределенных значений на клиенте

Для получения значения ссылок на предопределенные элементы справочников , планов видов характеристик , планов счетов , планов видов расчета , ссылки на значения перечислений , системных перечислений и точек маршрута бизнес­процессов в коде , выполняемом «на стороне» тонкого клиента , веб ­ клиента , где объекты типа СправочникМенеджер . &lt;ИмяСправочника&gt; , ПеречислениеМенеджер . &lt;ИмяПеречисления&gt; и т . п . не доступны , предназначена функция глобального контекста ПредопределенноеЗначение . Например:

ЮрФизЛицо

=

ПредопределенноеЗначение(

Перечисление

.

ЮридическоеФизическоеЛицо

.

ЮридическоеЛицо

При этом не следует в прикладном коде реализовывать собственные механизмы кеширования на клиенте предопределенных значений . Функция ПредопределенноеЗначение не ухудшает клиент ­ серверное взаимодействие: серверный вызов выполняется только при первом обращении к значению , а результат автоматически кешируется в кеше конфигурации на клиенте до следующего обновления версии конфигурации или версии платформы .

Подробнее см . раздел Работа с предопределенными значениями в документации к платформе 1С:Предприятие (на ИТС) .

## См . также

- Использование предопределенных элементов

"

"

);

## Минимизация количества серверных вызовов

- 1 . 1 . Разработку управляемого приложения необходимо вести с контролем количества вызовов серверных процедур и функций из клиентского кода (серверных вызовов) , а в некоторых случаях – также объем передаваемых данных между клиентом и сервером (трафик) .

Общее количество серверных вызовов складывается из

- обращений на сервер , которые выполняет платформа 1С:Предприятие ,
- и вызовов , которые выполняются из клиентского кода конфигурации – отклонение , привносимое конфигурацией по отношению к платформе .

В общем виде , при проектировании клиент ­ серверного взаимодействия в конфигурации следует руководствоваться тем , что на каждое действие пользователя в клиентском коде конфигурации не должно выполняться дополнительных вызовов на сервер . Любые исключения из этого правила требуют дополнительного обоснования .

- 1 . 2 . Отдельно для режима с низкой скоростью соединения следует оптимизировать не только количество вызовов , но и объем передаваемых данных между клиентом и сервером (трафик) . Отладку клиент­серверного взаимодействия в этом режиме работы рекомендуется проводить в режиме имитации задержек серверных вызовов .

Ниже рассмотрены типовые действия пользователя и даны рекомендации по организации клиент­серверного взаимодействия .

## Запуск клиентского приложения

- 2 . 1 . В простейшем случае , код конфигурации , выполняемый при запуске клиентского приложения , не должен приводить к обращениям на сервер . В тех случаях , когда все же необходимо получать данные с сервера:
- не следует напрямую вызывать серверные процедуры и функции из кода модуля приложения , модуля управляемого приложения и модуля внешнего соединения .
- правильно: за один вызов на сервер передавать на клиент все параметры , .
- необходимые для запуска приложения

В случае если параметры для запуска клиентского приложения требуется запрашивать с сервера из разных мест клиентского кода , следует разместить такую функцию в общем серверном модуле с повторным использованием возвращаемых значений . При первом вызове этой функции происходит одно обращение к серверу , после чего полученное значение автоматически кешируется платформой на клиенте для всех повторных вызовов этой функции .

## Пример:

```
// Фрагмент общего серверного модуля СтандартныеПодсистемыПереопределяемый с повторным использованием возвращаемых значений Функция ПараметрыРаботыКлиента() Параметры = Новый Структура(); Параметры . Вставить( " ИнформационнаяБазаФайловая " , ОбщегоНазначения . ИнформационнаяБазаФайловая()); // Инициализация других параметров , необходимых на клиенте при запуске приложения // Параметры . Вставить(имя параметра , значение параметра); Возврат Параметры; КонецФункции
```

Пример клиентского кода , использующего функцию ПараметрыРаботыКлиента:

```
ИнформационнаяБазаФайловая = СтандартныеПодсистемыПереопределяемый . ПараметрыРаботыКлиента() . ИнформационнаяБазаФайловая; Если ИнформационнаяБазаФайловая Тогда // обработка этого случая в клиентском коде // … См . также: Использование значений, й, влияющих на поведение клиентского приложения
```

## Открытие управляемой формы

- 3 . 1 . В случае если открытие формы выполняется из кода , следует открывать форму за один вызов с помощью метода глобального контекста ОткрытьФорму (при использовании версии платформы 1С:Предприятие 8 . 2 и более ранних версий ­ также ОткрытьФормуМодально) . Для передачи параметров в форму следует использовать параметр этих методов Параметры .
- 3 . 2 . При открытии формы не допускается выполнять обращений к серверу из кода модуля формы в обработчиках клиентских событий формы , таких как ПриОткрытии и ПриПовторномОткрытии . При необходимости обращения из них к серверным данным , следует размещать эти данные в реквизитах формы в ПриСозданииНаСервере .

## Например , неправильно:

```
НастройкаПроксиСервера = СерверныйМодуль . НастройкаПроксиСервера(); ОткрытьФорму( " ОбщаяФорма . ПараметрыПроксиСервера " , Новый Структура( " Настройка " , НастройкаПроксиСервера)); правильно: ОткрытьФорму( " ОбщаяФорма . ПараметрыПроксиСервера " ); при этом получение значения константы выполнять в обработчике ПриСозданииНаСервере формы ПараметрыПроксиСервера .
```

## Выполнение локальной команды управляемой формы

- 4 . 1 . Выполнение локальной команды формы должно приводить не более чем к одному вызову сервера .
- Если команда выполняет только клиентские операции (приводит к открытию новой формы , устанавливает отбор в списке , меняет стиль оформление и пр . ) , то все необходимые данные для ее выполнение должны быть заранее переданы на клиент . Рекомендуется заранее готовить эти данные в обработчике события формы ПриСозданииНаСервере и размещать их в реквизитах формы .

## Пример:

При выборе товаров из списка номенклатуры требуется запретить для пользователя выбор групп номенклатуры: при попытке выбрать группу программа должна выдавать останавливающее сообщение . Для проверки , является ли выбранный элемент номенклатуры группой , неправильно вызывать отдельную серверную функцию . Следует добавить в таблицу значений , которая связана с полем списка на форме , реквизит ЭтоГруппа и заполнять его в обработчике события формы ПриСозданииНаСервере . Тогда проверка на клиенте выполняется без дополнительного серверного вызова и имеет вид:

```
ТекущаяСтрока = Элемент . ТекущиеДанные; Если ТекущаяСтрока . ЭтоГруппа Тогда Сообщение = Новый СообщениеПользователю(); Сообщение . Текст = НСтр( " ru = ' Выбор группы запрещен . ' " ); Сообщение . Сообщить(); Возврат; КонецЕсли;
```

- Если команда связана с выполнением бизнес­логики , которую возможно отработать только на сервере , то вся она должна выполняться за один серверный вызов .

## Выбор из справочника

- 4 . 2 . В общем случае , при выборе из справочника допускается выполнять только один серверный вызов из кода , к которому приводит вызов метода глобального контекста ОткрытьФорму (или ОткрытьФормуМодально) .
- 4 . 3 . В случае если после выбора из справочника необходимо выполнить бизнес­логику , которую возможно отработать только на сервере , то допустимо выполнять ее за один дополнительный серверный вызов .

## Выполнение глобальной команды

- 5 . 1 . При выполнении глобальной команды допускается выполнять только один серверный вызов из кода . В случае если команда открывает форму , то этот вызов должен выполняться при вызове метода глобального контекста ОткрытьФорму (или ОткрытьФормуМодально) .

## Выполнение команды формирования отчета

- 6 . 1 . При выполнении команды формирования отчета не допускается выполнять дополнительных серверных вызовов из кода конфигурации .

В частности , при открытии формы отчета не допускается выполнять обращений к серверу из кода модуля формы в обработчиках клиентских событий формы , таких как ПриОткрытии и ПриПовторномОткрытии .

Например , неправильно выполнять формирование отчета , использующего систему компоновки данных , из обработчика формы ПриОткрытии:

```
&НаКлиенте Процедура ПриОткрытии(Отказ) ВывестиОтчет(); КонецПроцедуры &НаСервере Процедура ВывестиОтчет() // код по формированию отчета … КонецПроцедуры
```

## правильно:

- открывать форму отчета с параметром СформироватьПриОткрытии = Истина , либо
- установить параметр формы СформироватьПриОткрытии в значение Истина в обработчике ПриСозданииНаСервере .

## Выполнение подбора элементов

- 7 . 1 . Особенность клиент ­ серверного взаимодействия при выполнении подбора элементов состоит в необходимости передавать список выбранных элементов между формой объекта и формой подбора . При этом объем передаваемых данных может быть достаточно большим .

В этом случае не рекомендуется передавать потенциально большой массив данных в качестве параметра формы подбора . Потенциально большой массив данных , хранимый в форме подбора в параметре типа ДанныеФормыКоллекция , может оказаться на клиенте не полным за счет оптимизации работы управляемой формы . Как результат – для передачи параметра будет выполнено дополнительное " дочитывание " данных формы с сервера .

- 7 . 2 . В целях оптимизации передачи данных между формой объекта и формой подбора рекомендуется использовать временное хранилище , чтение и запись которого должна выполняться на сервере .

Проиллюстрируем методику использования формы подбора на примере подбора элементов справочников Товары в табличную часть Товары документа РасходТовара . (Из демонстрационной конфигурации по платформе 1С:Предприятие) .

Открытие формы подбора из клиентского кода должно приводить не более чем к двум обращениям на сервер . С этой целью локальная команда открытия формы подбора в модуле формы документа РасходТовара помещает список товаров из табличной части во временное хранилище (первый вызов) и открывает форму подбора (второй вызов) , передавая адрес временного хранилища:

```
&НаКлиенте Процедура ОбработчикКомандыПодбора() АдресТоваровВХранилище = ПоместитьТоварыВХранилище(); ПараметрыПодбора = Новый Структура( " АдресТоваровДокумента , ВидЦен , Склад " , АдресТоваровВХранилище , Объект . ВидЦен , Объект . Склад); ФормаПодбора = ОткрытьФорму( " Документ . РасходТовара . Форма . ФормаПодбора " , ПараметрыПодбора , ЭтотОбъект); КонецПроцедуры &НаСервере // Функция помещает список товаров во временное хранилище и возвращает адрес Функция ПоместитьТоварыВХранилище() Возврат ПоместитьВоВременноеХранилище(Объект . Товары . Выгрузить( , " Товар , Цена , Количество " ) , УникальныйИдентификатор); КонецФункции Форма подбора получает список выбранных товаров из временного хранилища в обработчике ПриСозданииНаСервере: &НаСервере Процедура ПриСозданииНаСервере(Отказ , СтандартнаяОбработка) АдресТоваровДокумента = Параметры . АдресТоваровДокумента; Товары . Загрузить(ПолучитьИзВременногоХранилища(АдресТоваровДокумента)); … КонецПроцедуры
```

Закрытие формы подбора должно приводить не более чем к двум обращениям на сервер . При закрытии форма подбора помещает список выбранных товаров во временное хранилище (первый вызов):

<!-- image -->

## Минимизация кода , выполняемого на клиенте

- 1 . 1 . Необходимо минимизировать объем кода , который выполняется на стороне клиентского приложения . В частности не следует выполнять на клиенте сложные алгоритмы , требующие значительных ресурсов компьютера . В таких случаях выполнение алгоритма на клиенте может занимать гораздо больше времени , чем передача управления с клиента на сервер , выполнение алгоритма на сервере и возврат результата обратно на клиент .

Следует размещать такие алгоритмы в серверном коде , выполняя к ним минимально необходимое число обращений с клиента .

См . также: Минимизация количества серверных вызовов

Это требование продиктовано тем , что

- как правило , клиентский компьютер менее производительный , чем серверный компьютер;
- необходимостью приемлемого качества работы в веб­клиенте . Клиентский код выполняется интерпретатором встроенного языка , который в веб­клиенте работает заметно медленнее , чем в тонком или толстом клиенте .
- 1 . 2 . Рекомендуется оставлять на клиенте такие алгоритмы , скорость работы которых заведомо быстрее , чем затраты , необходимые на вызов одной серверной функции . Например , перерасчет доступности элементов управления в форме при изменении пользователем данных выполняется на клиенте , т . к . контекстный серверный вызов для сложной формы может сделать работу пользователя в этой форме неприемлемой .

См . также: Особенности табличного документа в веб­клиенте

- 2 . 1 . Исключение из этого правила составляют отдельные случаи , когда функциональная подсистема предназначена для работы с программным обеспечением , установленным на клиентском компьютере . Например , работа с торговым оборудованием , интеграция с клиент ­ банком , формирование печатных форм в офисные программы и т . п .
- 2 . 2 . В тех случаях когда функциональная подсистема предназначена для работы с клиентским программным обеспечением только в определенных режимах работы клиента , следует использовать директивы препроцессора . Например , для кода , недоступного в веб­клиенте:

#Если ВебКлиент Тогда Предупреждение(НСтр( " ru = ' Загрузка адресного классификатора не доступна в веб ­ клиенте . ' " )); #Иначе

ОткрытьФорму( " РегистрСведений . АдресныйКлассификатор . Форма . ФормаЗагрузкиАдресногоКлассификатора " ); #КонецЕсли

## Доступ к файловой системе из кода конфигурации

- 1 . При обращении из кода конфигурации к файлам и каталогам файловой системы следует иметь в виду , что доступ к ним ограничен правами пользователя операционной системы , от имени которого запущено приложение .
- 1 . 1 . Если доступ к файловой системе осуществляется из кода , выполняемого на клиенте , то он выполняется под правами пользователя , от имени которого запущено приложение (тонкий , толстый или веб ­ клиент) . Как правило , это текущий пользователь операционной системы .
- 1 . 2 . Если доступ к файловой системе осуществляется из кода , выполняемого на сервере , то:
- при использовании клиент ­ серверной информационной базы , доступ ограничен правами пользователя , от имени которого запущен сервер 1С:Предприятия ( * );
- при использовании файловой базы , опубликованной на веб­сервере , доступ ограничен правами пользователя , от имени которого запущен вебсервер .
* Рабочие процессы могут быть также запущены от имени другого пользователя , отличного от того , под которым запускается агент сервера . Подробнее см . руководство администратора клиент ­ серверного варианта , описание служебного файла swpuser. r. ini

<!-- image -->

## Работа с временными файлами и каталогами

При необходимости использования временных файлов и каталогов необходимо соблюдать следующие требования:

- 1 . Для получения имени временного файла следует использовать метод ПолучитьИмяВременногоФайла . В противном случае возможна некорректная работа конфигурации в многопользовательском режиме , с включенными профилями безопасностями , возникновение проблем с правами доступа к файлам операционной системы .

## Неправильно:

ИмяПромежуточногоФайла = " C:\Временные файлы 1С\TempFile . xml " Данные . Записать(ИмяПромежуточногоФайла);

У текущего пользователя может не быть прав на запись в указанный каталог . Кроме того , при одновременном выполнении этого кода из двух разных сеансов возникнет ошибка .

## Правильно:

ИмяПромежуточногоФайла = ПолучитьИмяВременногоФайла( " xml " ); Данные . Записать(ИмяПромежуточногоФайла);

При использовании этой функции будет получено уникальное имя , гарантирован доступ к файлу .

- 2 . Для создания временного каталога рекомендуется также использовать имя , полученное при помощи метода ПолучитьИмяВременногоФайла . Это гарантирует уникальность имени создаваемого каталога при работе в многопользовательском режиме . После этого , внутри созданного каталога можно создавать другие каталоги и файлы без ограничений .
- 3 . Даже если не планируется локализация конфигурации на другие языки , следует обеспечивать переносимость файлов , сформированных из кода конфигурации , между различными операционными системами с различными кодировками . Для этого необходимо:
- 3 . 1 . В именах файлов , автоматически формируемых из кода конфигурации , указывать только английские буквы , а также цифры , а в качестве кодировки текстовых файлов использовать только UTF­8 (именно этот формат предпочтителен , т . к . только с ним корректно работает операционная система OS X) .

Это ограничение распространяется на файлы сообщений обмена , выгрузки данных , электронных документов и пр . , которые автоматические формируются системой , в том числе на файлы , упакованные в архивы (например , zip) . Исключение составляют случаи , когда на формат файлов невозможно повлиять , например , это формат сторонней системы .

- 3 . 2 . В тех случаях , когда имя файла не генерируется системой , а его явно вводит пользователь , разрешить ввод русскоязычных имен , но при этом дать возможность транслитерировать его в англоязычное имя . По умолчанию , если это технически возможно и не снижает удобство работы , рекомендуется предлагать англоязычное имя файла , а для текстовых файлов – сохранение в кодировке UTF ­ 8 .

Также эти рекомендации по выбору имени и кодировки файла следует разместить в справке к тем местам программы , где пользователь имеет возможность сохранять файлы и выбирать кодировку .

В конфигурациях на базе Библиотеки стандартных подсистем для транслитерации имен файлов рекомендуется использовать функцию СтроковыеФункцииКлиентСервер . СтрокаЛатиницей .

- 4 . При выполнении кода на веб клиенте или в редких случаях , если не требуется обеспечение работы в многопользовательском режиме например , обновление файловой информационной базы , монопольный режим) , необходимо использовать для формирования имени файла или каталога функцию КаталогВременныхФайлов .

См . также Особенности разработки конфигураций для ОС Linux, x, об особенностях использования имен и путей файлов .

- 5 . После окончания работы с временным файлом или каталогом , его необходимо удалить самостоятельно . Нельзя рассчитывать на автоматическое удаление файлов и каталогов при следующем запуске платформы , это может привести к исчерпанию свободного места в каталоге временных файлов .
- 6 . При использовании временных файлов и каталогов на сервере , необходимо полностью завершать работу с ними в рамках одного серверного вызова . При работе конфигурации с использованием кластера серверов , при следующем вызове эти файлы могут стать недоступны , так как код начнет исполняться на другом компьютере . При необходимости сохранить данные между серверными вызовами в пределах одного сеанса следует использовать временное хранилище платформы (методы ПоместитьВоВременноеХранилище , ПолучитьИзВременногоХранилища) .
- 6 . 1 . В редких случаях может возникнуть необходимость передачи данных во временных файлах между сеансами , например , при подготовке данных для

```
ИмяПромежуточногоФайла = ПолучитьИмяВременногоФайла( " xml " ); Данные . Записать(ИмяПромежуточногоФайла); // Работа с файлом . . . // Удаляем временный файл Попытка УдалитьФайлы(ИмяПромежуточногоФайла); Исключение ЗаписьЖурналаРегистрации(НСтр( " ru = ' Мой механизм . Действие ' " ) , УровеньЖурналаРегистрации . Ошибка , , , ПодробноеПредставлениеОшибки(ИнформацияОбОшибке())); КонецПопытки;
```

См . также: Использование Журнала регистрации .

фонового задания , при организации длительного процесса , обслуживающего несколько последовательных вызовов web­сервиса . Необходимо самостоятельно обеспечивать гарантировано общее место хранения , права для доступа к файлам из разных мест их обработки , удаление файлов по истечению сроков их обработки или аварийного завершения процесса обработки . Рекомендуется использовать следующий подход:

- Для обеспечения доступа со всех возможных мест обработки заводится константа для хранения общего пути к файлам , доступного для доступа со всех серверов кластера;
- При создании временных файлов их имена заносятся во вспомогательный регистр сведений с сохранением времени создания файла;
- При штатном прохождении процесса , последняя операция , которой были нужны файлы , перед своим завершением удаляет как сам файл , так и записи о них во вспомогательном регистре;
- Вспомогательное регламентное задание периодически проверяет наличие записей во вспомогательном регистре , время существования которых заведомо превышает время штатного завершения процесса . При обнаружении таких записей , задание удаляет временные файлы и записи о них .

## Передача файлов между клиентом и сервером

1 . При одновременной работе с файлом на клиенте и на сервере необходимо использовать передачу файла через временное хранилище (методы ПоместитьФайлы , ПолучитьФайл , ПолучитьФайлы , НачатьПомещениеФайла , ПоместитьВоВременноеХранилище , ПолучитьИзВременногоХранилища) . В общем случае клиент и серверы кластера ­ это разные компьютеры с разной файловой системой , причем доступ к файлам может происходить под разными пользователями ОС с различными правами .

## Неправильно:

```
&НаКлиенте Процедура ОбработкаФайла() . . . ИмяФайла = " C:\Файлы для обработки\Загрузка . xml " ; Результат = ПроизвестиОбработкуНаСервере(ИмяФайла); . . . КонецПроцедуры &НаСервере Функция ПроизвестиОбработкуНаСервере(ИмяФайла) Чтение = Новый ЧтениеТекста(ИмяФайла) . . .
```

```
Результат = Чтение . Прочитать(); Возврат Результат; КонецФункции
```

## Правильно:

```
&НаКлиенте Процедура ОбработкаФайла() . . . ИмяФайлаДляОбработки = " C:\Файлы для обработки\Загрузка . xml " ; ОписаниеОповещения = Новый ОписаниеОповещения( " ПослеПомещенияФайла " , ЭтотОбъект); НачатьПомещениеФайла(ОписаниеОповещения , , ИмяФайлаДляОбработки , Ложь , УникальныйИдентификатор); КонецПроцедуры &НаКлиенте Процедура ПослеПомещенияФайла(Результат , Адрес , ВыбранноеИмяФайла , ДополнительныеПараметры) . . . Результат = ПроизвестиОбработкуНаСервере(Адрес); . . . КонецПроцедуры &НаСервере Функция ПроизвестиОбработкуНаСервере(Адрес) Данные = ПолучитьИзВременногоХранилища(Адрес) ИмяПромежуточногоФайла = ПолучитьИмяВременногоФайла( " txt " ); Данные . Записать(ИмяПромежуточногоФайла); Чтение = Новый ЧтениеТекста(ИмяПромежуточногоФайла) . . . Результат = Чтение . Прочитать(); . . . УдалитьФайлы(ИмяПромежуточногоФайла); Возврат Результат; КонецФункции
```

- 2 . Для сохранения данных во временном хранилище между несколькими серверными вызовами , при помещении его в хранилище необходимо использовать параметр УникальныйИдентификаторФормы метода

ПоместитьФайл , передав в него идентификатор текущей формы . Такие значения будут удалены из временного хранилища только при закрытии указанной формы . При этом , при повторном помещении того же файла во временное хранилище , предыдущее значение необходимо удалять вручную . Например:

## Неправильно:

```
&НаКлиенте Процедура ОбработкаФайла() . . . // Первый серверный вызов ИмяФайлаДляОбработки = " C:\Файлы для обработки\Загрузка . xml " ; ОписаниеОповещения = Новый ОписаниеОповещения( " ПослеПомещенияФайлаНачало " , ЭтотОбъект); НачатьПомещениеФайла(ОписаниеОповещения , , ИмяФайлаДляОбработки , Ложь , УникальныйИдентификатор); . . . КонецПроцедуры &НаКлиенте Процедура ПослеПомещенияФайлаНачало(Результат , Адрес , ВыбранноеИмяФайла , ДополнительныеПараметры) . . . Результат = ПроизвестиНачальнуюОбработкуНаСервере(Адрес); ОбработкаФайлаПродолжение(); . . . КонецПроцедуры &НаКлиенте Процедура ОбработкаФайлаПродолжение() . . . // Второй серверный вызов с той же версией файла Результат = ПроизвестиПромежуточнуюОбработкуНаСервере(Адрес); . . . // Третий серверный вызов с новой версией файла ОписаниеОповещения = Новый ОписаниеОповещения( " ПослеПомещенияФайлаОкончание " , ЭтотОбъект); НачатьПомещениеФайла(ОписаниеОповещения , , ИмяФайлаДляОбработки , Ложь , УникальныйИдентификатор); КонецПроцедуры
```

```
&НаКлиенте Процедура ПослеПомещенияФайлаОкончание(Результат , Адрес , ВыбранноеИмяФайла , ДополнительныеПараметры) . . . Результат = ПроизвестиКонечнуюбОбработкуНаСервере(Адрес); . . . КонецПроцедуры
```

При этом во временном хранилище формы останется две копии файлов . Адрес второй копии будет находиться в переменной Адрес , а адрес первой копии будет утерян . Это приводит к затрате дополнительных ресурсов приложения , замедлению работы .

## Правильно:

```
&НаКлиенте Процедура ОбработкаФайла() . . . // Первый серверный вызов ИмяФайлаДляОбработки = " C:\Файлы для обработки\Загрузка . xml " ; ОписаниеОповещения = Новый ОписаниеОповещения( " ПослеПомещенияФайлаНачало " , ЭтотОбъект); НачатьПомещениеФайла(ОписаниеОповещения , , ИмяФайлаДляОбработки , Ложь , УникальныйИдентификатор); . . . КонецПроцедуры &НаКлиенте Процедура ПослеПомещенияФайлаНачало(Результат , Адрес , ВыбранноеИмяФайла , ДополнительныеПараметры) . . . Результат = ПроизвестиНачальнуюОбработкуНаСервере(Адрес); ОбработкаФайлаПродолжение(); . . . КонецПроцедуры &НаКлиенте Процедура ОбработкаФайлаПродолжение() . . . // Второй серверный вызов с той же версией файла Результат = ПроизвестиПромежуточнуюОбработкуНаСервере(Адрес); . . . // Третий серверный вызов с новой версией файла
```

<!-- image -->

## См . также

- Общие требования к конфигурации

## Оптимизация использования оперативной памяти

Методическая рекомендация (полезный совет)

- 1 . Не следует разрабатывать решения исходя из неограниченного объема оперативной памяти . Для многопользовательских систем любое неэффективное использование памяти может катастрофически сказаться на работоспособности .

Следует избегать формирования больших структур данных в памяти . Если объём данных , с которыми работает бизнес­логика , сам по себе ничем не ограничен , его нужно ограничивать искусственно , обрабатывая данные порциями и сохраняя результаты в базу или файлы .

- 2 . При потенциально неограниченных выборках данных из ИБ следует получать данные из базы порциями фиксированного размера . Например , неправильно:

```
Запрос = Новый Запрос; Запрос . Текст = " ВЫБРАТЬ | Номенклатура . Ссылка , | Номенклатура . Наименование , | Номенклатура . ВидНоменклатуры |ИЗ | Справочник . Номенклатура КАК Номенклатура " ; // Выгрузка всего справочника в таблицу значений Номенклатура = Запрос . Выполнить() . Выгрузить(); Для каждого ПозицияНоменклатуры Из Номенклатура Цикл // Обработка элемента справочника // . . . КонецЦикла;
```

поскольку весь результат запроса сразу помещается в память , в таблицу значений .

Также неправильно:

```
Запрос = Новый Запрос; Запрос . Текст = " ВЫБРАТЬ | Номенклатура . Ссылка , | Номенклатура . Наименование , | Номенклатура . ВидНоменклатуры |ИЗ | Справочник . Номенклатура КАК Номенклатура " ;
```

```
РезультатЗапроса = Запрос . Выполнить(); // Обход результата запроса ВыборкаДетальныеЗаписи = РезультатЗапроса . Выбрать(); Пока ВыборкаДетальныеЗаписи . Следующий() Цикл // Обработка элемента выборки // . . . КонецЦикла;
```

поскольку и в этом случае при выполнении запроса его результат будет сначала считан в память целиком ( * ) .

* Примечание . Если используется 32­битная версия платформы, ы, и размер результата запроса превосходит размер имеющейся памяти, и, то данные будут записаны на диск, к, а затем считаны оттуда в процессе вызовов Выборка . Следующий() .

## Правильно ограничивать результат запроса искусственно:

```
ВсеОбработано = Ложь; Пока Истина Цикл Запрос = Новый Запрос; Запрос . Текст = " ВЫБРАТЬ ПЕРВЫЕ 1000 | Номенклатура . Ссылка , | Номенклатура . Наименование , | Номенклатура . ВидНоменклатуры |ИЗ | Справочник . Номенклатура КАК Номенклатура |ГДЕ | <условие выборки необработанных записей> " ; РезультатЗапроса = Запрос . Выполнить(); ВсеОбработано = РезультатЗапроса . Пустой(); Если ВсеОбработано Тогда Прервать; КонецЕсли; // Обход порции результата запроса ВыборкаДетальныеЗаписи = РезультатЗапроса . Выбрать(); Пока ВыборкаДетальныеЗаписи . Следующий() Цикл // Обработка элемента выборки // . . . КонецЦикла; КонецЦикла; Также правильно: Выборка = Справочники . Номенклатура . Выбрать( . . . , Отбор); Пока Выборка . Следующий() Цикл // Обработка элемента выборки
```

<!-- image -->

поскольку в этом случае платформа 1С:Предприятие выполняет получение данных из базы порциями фиксированного размера .

Кроме того , число элементов выборки автоматически ограничивает платформа 1С:Предприятие в запросах динамических списков .

- 3 . Недопустимо работать с большими XML документами с помощью объектов встроенного языка , предназначенных для обработки файлов целиком: текстовые документы в ТекстовыйДокумент , XML в ДокументDOM и HTML в ДокументHTML , а также создавать в памяти XDTO­пакеты размером с весь XML­ L­ файл целиком .

В противном случае , весь файл загружается в оперативную память целиком . Исключения составляют отдельные случаи , когда необходим произвольный доступ к содержимому файла , к какой ­ то конкретной его части .

Следует использовать объекты для последовательной записи и последовательного чтения: ЧтениеXML , ЧтениеТекста , ЗаписьXML , ЗаписьТекста , с помощью которых можно прочитать файл порциями и расходовать память экономно .

При использовании механизмов XDTO неправильно зачитывать в память весь XML­ L­ файл целиком (ФабрикаXTDO . ПрочитатьXML(ЧтениеXML)) . Вместо этого следует зачитывать XML­ L­ файл последовательно , с помощью объекта ЧтениеXML , а его отдельные фрагменты (теги) десериализовывать с помощью фабрики XDTO .

- 4 . Другая распространенная причина неэффективное использование памяти ­ утечки памяти . К утечкам памяти приводит создание циклических ссылок – память выделяется и не освобождается . Например , если есть объекты , внутри которых вложены другие объекты , и где ­ то в глубине они ссылаются на самый верхний объект . В результате образуется циклическая ссылка . Упрощенный пример циклической ссылки:

```
Данные = Новый Структура; Данные . Вставить( " Ключ " , Данные);
```

Следует разрывать (очищать) ссылки , когда объект становится не нужен . Например , для примера выше:

```
Данные . Ключ = Неопределено;
```

Для выявления утечек памяти можно применять технологический журнал , включив в файл настройки параметров технологического журнала logcfg . xml элемент &lt;leaks&gt; .

Подробнее см . :

- Документация к платформе 1С:Предприятие , Приложение 3 . Описание и расположение служебных файлов ­ logcfg . xml
- Поиск циклических ссылок
- 5 . Чрезмерное (неоправданное) применение общих модулей с повторным использованием возвращаемых значений может также приводить к излишнему потреблению памяти .

## Безопасное хранение паролей

- 1 . При разработке подсистем , взаимодействующих с различными внешними ресурсами (электронной почтой , веб ­ сервисами , FTP ­ ресурсами и т . п . ) возникает необходимость запрашивать и передавать данные аутентификации к этим ресурсам: логин и пароль .
- 2 . Для сведения к минимуму возможности перехвата пароля злоумышленниками не следует хранить пароли и другую конфиденциальную информацию в информационной базе . При этом минимальный уровень защищенности – в файловых информационных базах , в которых файл базы может быть скопирован целиком любым пользователем информационной базы . В клиент­серверной информационной базе доступ к базе данных , как правило , имеется только у администраторов СУБД .

Таким образом , следует запрашивать логин и пароль у пользователя и передавать их сразу , не сохраняя в информационной базе .

- 3 . В ряде случаев такая схема работы доставляет объективные неудобства или принципиально невозможна:
- интерактивный запрос логина и пароля на каждую операцию может создавать значительный дискомфорт от работы , а временного сохранения на стороне клиента недостаточно;
- взаимодействие с различными внешними ресурсами должно выполняться на сервере , не зависимо от интенсивности работы пользователей с программой .

В таких случаях допустимо организовать хранение паролей и другой конфиденциальной информации в информационной базе , предупредив пользователей о последствиях . Следует помнить , что подобное хранение паролей не решает всех проблем безопасности , а лишь усложняет задачу для злоумышленника .

- 3 . 1 . При этом не следует хранить пароли и другую конфиденциальную информацию в реквизитах тех же объектов метаданных , с которыми ведется повседневная работа . Для хранения такой информации следует использовать отдельный объект метаданных (например , регистр сведений) , организовав к нему безопасный доступ на уровне системы прав доступа 1С:Предприятия .
- 3 . 2 . При использовании Библиотеки стандартных подсистем (БСП) следует использовать безопасное хранилище паролей , которое решает ряд задач:
- Имея доступ к объекту метаданных , пользователь может прочитать содержимое реквизита с паролем , что невозможно при использовании безопасного хранилища . Для исключения случаев несанкционированного доступа к безопасному хранилищу получение и запись данных (паролей) возможна только привилегированном режиме .
- Данные в безопасном хранилище хранятся в закрытом виде и тем самым исключаются случаи непредумышленной «засветки» паролей .
- Безопасное хранилище исключено из планов обмена , что предотвращает утечку паролей из информационной базы при обмене данными .

Для работы с безопасным хранилищем паролей предназначены процедуры и функции общего модуля ОбщегоНазначения:

ЗаписатьДанныеВБезопасноеХранилище , ПрочитатьДанныеИзБезопасногоХранилища и УдалитьДанныеИзБезопасногоХранилища . Подробнее см . комментарии к этим функциям в БСП и раздел «3 . 4 . Базовая функциональность ­ Использование при разработке конфигурации ­ Безопасное хранилище паролей» документации БСП .

- 3 . 3 . Не следует хранить пароли в реквизитах формы , их следует извлекать только на стороне сервера и непосредственно перед их использованием . В противном случае , при открытии формы с маскированным вводом (или просмотром) пароля , пароль передается с сервера на клиент в открытом виде , что делает возможным его перехват . Установка привилегированного

режима производится непосредственно перед вызовом функций , а не внутри них , что бы исключить получение или запись любых паролей в сеансе с любыми правами . Безопасность вызова должен обеспечивать вызывающий код , который обращается к конкретным паролям .

Для маскировки пароля на форме в обработчике событии формы ПриСозданииНаСервере необходимо разместить следующий код:

```
УстановитьПривилегированныйРежим(Истина); Пароли = ОбщегоНазначения . ПрочитатьДанныеИзБезопасногоХранилища(Объект . Ссылка , " Пароль , ПарольSMTP " ); // Пароль , ПарольSMTP – ключи соответствия данных в безопасном хранилище УстановитьПривилегированныйРежим(Ложь); Пароль = ?(ЗначениеЗаполнено(Пароли . Пароль) , ЭтотОбъект . УникальныйИдентификатор , "" ); ПарольSMTP = ?(ЗначениеЗаполнено(Пароли . ПарольSMTP) , ЭтотОбъект . УникальныйИдентификатор , "" );
```

## В обработчике события формы ПриЗаписиНаСервере:

```
Если ПарольИзменен Тогда УстановитьПривилегированныйРежим(Истина); ОбщегоНазначения . ЗаписатьДанныеВБезопасноеХранилище(ТекущийОбъект . Ссылка , Пароль); Пароль = ?(ЗначениеЗаполнено(Пароль) , ЭтотОбъект . УникальныйИдентификатор , "" ); КонецЕсли; Если ПарольSMTPИзменен Тогда УстановитьПривилегированныйРежим(Истина); ОбщегоНазначения . ЗаписатьДанныеВБезопасноеХранилище(ТекущийОбъект . Ссылка , ПарольSMTP , " ПарольSMTP " ); ПарольSMTP = ?(ЗначениеЗаполнено(ПарольSMTP) , ЭтотОбъект . УникальныйИдентификатор , "" ); КонецЕсли;
```

где Пароль и ПарольSMTP ­ реквизиты формы . Если пароль ранее был сохранен в программе , то следует присвоить соответствующему реквизиту уникальный идентификатор формы , эмулирующий наличие пароля . При записи объекта в форме , если был введен новый пароль , то записываем его в объект , а реквизит формы вновь затираем уникальным идентификатором .

## Таймауты при работе с внешними ресурсами

- 1 . При работе с внешними ресурсами с помощью объектов WSОпределения , WSПрокси , HTTPСоединение , FTPСоединение , ИнтернетПочтовыйПрофиль следует задавать таймаут – предельное время ожидания выполнения операции . В противном случае , в результате бесконечного ожидания программа зависнет или часть функционала программы станет недоступна .

Например , при получении описания веб­сервиса и вызове его операций – если удаленная сторона долго не отвечает (например , выключена , находится на обслуживании или возникли временные неполадки) , ожидание ответа может длиться бесконечно . Поэтому если веб­сервис был вызван в результате интерактивных действий пользователя , то внешне будет выглядеть так , что «программа зависла»; а если веб­сервис вызывается из регламентного задания , то связанная с ним часть функционала программы может стать недоступна .

- 2 . Величину таймаута рекомендуется определять , исходя из ожидаемого времени выполнения конкретной операции:
- Если операция может выполняться очень долго , как например , передача объемных двоичных данных , то и таймаут должен быть большим (иначе операция не успеет выполниться) .
- Для быстрых операций величина таймаута должна выбираться , соответственно , небольшой .
- Ни при каких случаях , величину таймаута не следует выбирать более 3 мин (или с бесконечным ожиданием) . Веб ­ сервисы , операции которых занимают больше времени , следует переводить на асинхронный режим выполнения: запускать фоновое задание для выполнения «тяжелой» операции и предусмотреть дополнительную операцию по проверке готовности и получению результата .
- 3 . 1 . При этом следует явно разделять операции подключения к внешнему ресурсу и выполнение действий с ним . Например , при таймауте в 60 секунд и недоступности удаленной стороны – система (или пользователь) будет зря ожидать 60 секунд .
- 3 . 2 . В частности , при разработке веб­сервисов , на операции которых предусмотрен таймаут более 20 секунд (ориентировочно) , рекомендуется:
- предусмотреть в веб­сервисе отдельную контрольную операцию Ping;
- при работе с этим веб­сервисом , предварительно получать для нее прокси с небольшим таймаутом в 3 секунды и вызывать контрольную операцию Ping;
- только после этого получать основной прокси .

Пример вызова веб­сервиса .

## Неправильно

## Правильно

```
Реализация модуля веб­сервиса PingPong: Функция Pong(Знач Параметр) Возврат СтроковыеФункцииКлиентСервер . ПодставитьПараметрыВСтроку(НСтр( " ru = ' Привет , %1 ' " ) , Параметр); КонецФункции Функция Ping() Возврат "" ; // Проверка связи КонецФункции Функция Pong(Знач Параметр) Возврат СтроковыеФункцииКлиентСервер . ПодставитьПараметрыВСтроку(НСтр( " ru = ' Привет , %1 ' " ) , Параметр); КонецФункции Реализация вызывающей стороны (без использования Библиотеки стандартных подсистем): // Ждем не более минуты PingPong = Новый WSПрокси(АдресВебСервиса , , , , , 60); Результат = PingPong . Pong(НСтр( " ru = ' Мяч ' " )); // Ждем не более 3 секунд PingPong = Новый WSПрокси(АдресВебСервиса , , , , , 3); PingPong . Ping(); // проверка связи // Сервис жив , далее работаем с ним и ждем не более минуты PingPong = Новый WSПрокси(АдресВебСервиса , , , , , 60); Результат = PingPong . Pong(НСтр( " ru = ' Мяч ' " ));
```

При использовании Библиотеки стандартных подсистем:

- для работы с веб­сервисами предназначена функция WSПрокси общего модуля ОбщегоНазначения (включает в себя поддержку контрольной операции Ping);
- для получения данных по протоколам HTTP(S) и FTP(S) – подсистема «Получение файлов через Интернет» .

Пример реализации вызывающей стороны с использованием Библиотеки стандартных подсистем:

```
// Сделать контрольный вызов Ping и ждать не более минуты на дальнейших операциях . PingPong = ОбщегоНазначения . WSПрокси(АдресВебСервиса , . . . , 60 , Истина); // Сервис точно жив , далее работаем с ним . Результат = PingPong . Pong(НСтр( " ru = ' Мяч ' " ));
```

- 3 . 3 . Для других видов внешних ресурсов (не веб­сервисов) рекомендуется применять аналоги операции Ping . Например:
- для сервисов , работающих через REST API – это контрольная отправка тестовой команды; в большинстве случаев , если ответ с кодом 200 , то сервис работает;
- для FTP/WebDAV­ресурсов – это контрольная загрузка (отправка) файла­пустышки .
- 4 . Рекомендуемые величины таймаутов для различных операций:

| Операция                                                                                                                                                        | Таймаут (секунд)   |
|-----------------------------------------------------------------------------------------------------------------------------------------------------------------|--------------------|
| Получение описания  веб­сервиса                                                                                                                                 | 3                  |
| «Быстрые» операции ,  например:  проверка  корректности  введенного адреса , взаимодействие с менеджером сервиса  в  модели сервиса  и  пр .                    | 10 ­ 20            |
| Обычные операции ,  например:  получение сведений об одном  контрагенте , обмен сообщениями ,  отправка SMS ,  удаленное администрирование ИБ в  модели сервиса | 60 ­ 120*          |
| «Тяжелые» операции ,  например:  передача сообщений обмена данными через веб­сервис получение фрагментов файлов  из внешнего ресурс и  пр .                     | 120 ­ 180*         |

*

СледуетвызыватьтолькопослеконтрольнойоперацииPing

.

## Разработка конфигураций с повторным использованием общего кода и объектов метаданных

## Методическая рекомендация (полезный совет)

- 1 . В условиях разработки нескольких конфигураций (например , линейки продуктов) возникает задача повторного использования общего кода и объектов конфигурации . Эту задачу рекомендуется решать с использованием вспомогательных конфигураций – библиотек .

Библиотечная конфигурация (библиотека) – это конфигурация , которая в отличие от «обычных» прикладных решений не предназначена для использования конечными пользователями , а служит только для поддержки конфигураций , пользующихся ее функциональностью . В них размещается функциональность , общая для прикладных решений .

Библиотечный подход к разработке общей функциональности прикладных решений позволяет:

- вести разработку общей функциональности централизованно (а не в каждом прикладном решении «по месту»);
- выпускать версии общей функциональности в виде продукта (дистрибутива или файла поставки библиотеки);
- повторно использовать код и объекты библиотеки в конфигурациях с помощью механизма постановки на поддержку платформы 1С:Предприятия;
- унифицировать конфигурации по набору общих объектов метаданных и функциональных подсистем .
- 2 . В свою очередь , библиотека может стоять на поддержке у другой библиотеки , образуя таким образом иерархию библиотек . Библиотечная конфигурация , которая стоит на поддержке у другой библиотеки (библиотеки­родителя) , называется библиотекой­наследником .

Как правило , библиотеки не являются самостоятельным предметом разработки , а предназначены только для создания прикладных решений . Таким образом , прикладные решения являются конечными конфигурациямипотребителями в иерархии библиотек .

## См . также

- Использование дублирующего кода
- Переопределяемые и поставляемые объекты библиотеки
- Обеспечение обратной совместимости библиотек

## Имена объектов метаданных в иерархии библиотек

- 1 . При разработке конфигурации в условиях использования одной или нескольких библиотек следует избегать конфликтов имен объектов метаданных (справочников , документов , общих модулей и др . ) , поставляемых из библиотек , с объектами самой конфигурации .

Для разрешения таких конфликтов за библиотекой более «низкого» уровня рекомендуется организационно закрепить преимущественное право выбора названия . Если в одном из ее потребителей оказывается объект с таким же именем , то следует переименовать объект в потребителе с использованием более конкретного названия .

Например: если в конфигурации «Управление предприятием» имеется группа команд Настройки , конфликтующая с одноименной группой команд из библиотеки «Базовая функциональность» , то для группы команд в конфигурации­потребителе следует выбрать более точное название НастройкиУправленческогоУчета или НастройкиРасчетаСебестоимости или что­то иное .

- 2 . При разработке независимых друг от друга библиотек (одноуровненых) такие конфликты могут быть выявлены достаточно поздно – при или после их внедрения в конфигурацию­потребитель .

Для того чтобы снизить вероятность возникновения конфликтов в этом случае , следует всегда предметно называть объекты метаданных . Название должно кратко описывать сущность объекта; не должно называться слишком « универсально» .

- 2 . 1 . Наиболее «универсальные» названия объектов метаданных следует использовать в библиотеках самого нижнего уровня иерархии . Например , общие модули ОбщегоНазначения , СтроковыеФункции , РаботаСФормами и т . п .
- 2 . 2 . В конечных конфигурациях­потребителях и в библиотеках более высокого уровня использовать более специфичные для данной прикладной области названия .

Например , общие модули ТорговыйУчет , ЗарплатаКадры , ПроведениеСкладскихДокументов и т . п .

- 2 . 3 . Функционал , который расширяет аналогичный функционал библиотеки более низкого уровня или конфликтует с «соседней» одноуровненой библиотекой , рекомендуется именовать с добавлением уточняющих постфиксов , которые соответствуют имени конкретной библиотеки или конечной конфигурации­потребителя .

## Например:

- общий модуль ОбновлениеИнформационнойБазыМФ – функции обновления ИБ , специфичные для прикладного решения , конечной

конфигурации­потребителя

«Мои финансы» (постфикс МФ)

- общий модуль СтроковыеФункцииРегл – функции общего назначения , специфичные для библиотеки регламентированного учета (постфикс Регл)
- общий модуль РаботаСФормамиЗарплатаКадры – функции для работы с формами в библиотеке базовой зарплатно­кадровой функциональности (постфикс ЗарплатаКадры) .
- подписка на событие
- УстановитьПометкуУдаленияПрисоединенныхФайловЗарплатаКадры ­ определена в библиотеке базовой зарплатно­кадровой функциональности .

## Переопределяемые и поставляемые объекты библиотеки

- 1 . С точки зрения возможностей по настройке функциональности библиотеки для работы в конкретной конфигурации­потребителе все объекты библиотеки условно делятся на три категории:
- Непереопределяемые объекты – «готовые» объекты , которые можно брать и использовать в конфигурации­потребителе «как есть» . Их не следует изменять в конфигурации­потребителе , чтобы они были гарантированно одинаковы во всех конфигурациях , основывающихся на данной библиотеке . Более того , такие объекты обязательно должны присутствовать в конфигурациях , использующих библиотеку . Примеры: справочник Пользователи .
- Переопределяемые объекты – «изменяемые» объекты для настройки библиотеки под конкретную конфигурацию . Они могут или должны быть изменены в конфигурациипотребителе . Могут поставляться с базовой реализацией . С помощью таких объектов решаются задачи изменения поведения библиотечной функциональности , ее параметризации спецификой конфигурации­потребителя , а также для подключения библиотечной функциональности к объектам конфигурации­потребителя .
- Определители типов – объекты ­ «классификаторы» , которые не имеют базовой реализации . Предназначены для формирования единого пространства имен в конфигурациях , а реализация при этом может как угодно сильно различаться в конфигурациях­потребителях . Например: справочники ­ классификаторы , в которых определено только «название»; сущность «организация» должна быть везде представлена справочником с именем Организации и т . п .
- 2 . Рекомендуется устанавливать для объектов этих категорий следующие правила поставки:
- Непереопределяемые объекты – «изменения не рекомендуются»;
- Переопределяемые объекты и определители типов – «изменения разрешены» .

Эти рекомендации продиктованы следующими соображениями:

- Непереопределяемые объекты – это зона ответственности разработчиков библиотеки , поэтому они не должны разрабатываться «по месту» в конфигурациях­потребителях . Но если необходимость изменений носит срочный характер (например , исправление критичной ошибки) или продиктована какими­то другими особыми соображениями , то допускается вносить изменения в непереопределяемые библиотечные объекты непосредственно в конфигурациях­потребителях . При этом нужно иметь в виду , что эти изменения могут быть потеряны при следующем обновлении версии библиотеки в конфигурации­потребителе , если не принять специальные меры (донести до разработчиков библиотеки необходимость внесения изменений или задокументировать этот отход от общей инструкции по обновлению библиотеки) .
- Переопределяемые объекты и определители типы должны или могут быть изменены в конфигурации­потребителе , исходя из их назначения .
- 3 . Для того чтобы упростить настройку библиотеки и снизить трудоемкость последующих обновлений версии библиотеки в конфигурации­потребителе следует минимизировать количество переопределяемых объектов с помощью следующих методик:
- Настройка состава типов переопределяемых реквизитов (свойств) тех или иных объектов библиотеки – для подключения библиотечной функциональности к объектам конфигурации­потребителя .
- Например: можно подключить библиотечную функциональность к конкретным объектам конфигурации с помощью расширения состава типов общей команды , измерения составного типа в регистре сведений и т . п .
- Добавление предопределенных элементов – для параметризации библиотечной функциональности спецификой конфигурации­потребителя . Например: для библиотечной подсистемы ведения и обработки контактной информации с помощью предопределенных элементов библиотечного справочника

ВидыКонтактнойИнформации можно указать , какие виды контактной информации (телефон , адрес , электронный адрес и т . п . ) должны быть предусмотрены для объектов конфигурации­потребителя .

- Переопределяемые общие модули – для изменения поведения библиотечной функциональности в конкретной конфигурации­потребителе
- с помощью переопределения тех или иных «обработчиков событий» , предоставляемых библиотекой; например:

ПриПодготовкеМакетаОписанияОбновлений() ПриЗаписиСпискаБизнесПроцессов()

- а также для того , чтобы сообщить ту или иную информацию из конфигурациипотребителя в библиотеку . Например:
- ЭтоБазоваяВерсияКонфигурации() ОбработчикиОбновления()
- 3 . 1 . Переопределяемые общие модули следует называть с постфиксом Переопределяемый .
- 3 . 2 . Переопределяемые общие модули должны содержать только экспортные процедуры , которые вызываются из кода самой библиотеки . Другими словами , не следует допускать вызовов процедур переопределяемых модулей непосредственно из кода конфигурациипотребителя .

```
См . также: правила создания общих модулей
```

Такое ограничение обусловлено соображением повышения устойчивости кода конфигурации , который вызывает библиотечные процедуры и функции , составляющие программный интерфейс библиотеки . К программному интерфейсу библиотеки следует относить только экспортные процедуры и функции непереопределяемых общих модулей .

Например , в библиотеке имеются модули ПапкиФайлов и ПапкиФайловПереопределяемый . Для использования в конфигурациях­потребителях в модуле ПапкиФайлов реализуется экспортная функция:

```
Функция ПапкаФайлов(ВладелецФайловСсылка) Экспорт СтандартнаяОбработка = Истина; Результат = Неопределено; ПапкиФайловПереопределяемый . ПриПолученииПапкиФайлов(ВладелецФайловСсылка , Результат , СтандартнаяОбработка); Если СтандартнаяОбработка Тогда // реализация по умолчанию Результат = . . . КонецЕсли; Возврат Результат;
```

## КонецФункции

а в модуле ПапкиФайловПереопределяемый ­ процедура­обработчик ПриПолученииПапкиФайлов:

```
// Вызывается из библиотеки при необходимости получить папку файлов для указанного владельца . // // Параметры: // ВладелецФайловСсылка – ЛюбаяСсылка ­ владелец файлов , для которого нужно вернуть папку . // ПапкаФайлов – СправочникСсылка . ПапкиФайлов ­ в этот параметр нужно записать результат . // СтандартнаяОбработка – Булево ­ по умолчанию, Истина . В этом случае папка будет получена способом по умолчанию . // Если значение параметра установить в Ложь , то в этой процедуре можно реализовать свой способ ,
```

```
// которым в конфигурации получают папки файлов . // Процедура ПриПолученииПапкиФайлов(ВладелецФайловСсылка , ПапкаФайлов , СтандартнаяОбработка) Экспорт КонецПроцедуры При этом все вызовы из конфигурации­потребителя должны идти только к библиотечному модулю ПапкиФайлов . Обращение к ПапкиФайловПереопределяемый разрешается только из библиотечного модуля ПапкиФайлов . 3 . 3 . При этом в переопределяемом модуле следует располагать только экспортные процедуры с пустой реализацией . В нем не должно быть каких­либо других не­экспортных процедур или функций . Базовую реализацию переопределяемых процедур и функций следует располагать в непереопределяемом коде . Такое ограничение вызвано необходимостью снизить трудоемкость последующих обновлений переопределяемых модулей в конфигурации­потребителе . Например , неправильно поставлять переопределяемый модуль МояБиблиотекаПереопределяемый с какой­либо реализацией: Функция НастройкаПараметровРаботы() Экспорт ПараметрыРаботы = Новый Структура; // если настройки по умолчанию не подходят , то измените их . ПараметрыРаботы . Вставить( " ПоказыватьЕдинственныйРаздел " , Ложь); ПараметрыРаботы . Вставить( " ЗадаватьДатуДляПрочихРазделов " , Ложь); ПараметрыРаботы . Вставить( " ИспользоватьВнешнихПользователей " , Ложь); Возврат ПараметрыРаботы; КонецФункции правильно: // Позволяет настроить работу подсистемы . // // Параметры: // ПараметрыРаботы ­ Структура ­ с полями: // * ПоказыватьЕдинственныйРаздел ­ Булево ­ по умолчанию Ложь . // * ЗадаватьДатуДляПрочихРазделов ­ Булево ­ по умолчанию Ложь . // * ИспользоватьВнешнихПользователей ­ Булево ­ по умолчанию Ложь . // Процедура ПриПолученииНастроекПараметровРаботы(ПараметрыРаботы) Экспорт КонецПроцедуры а установку значений по умолчанию перенести в непереопределяемый общий модуль библиотеки: Функция НастройкаПараметровРаботы() ПараметрыРаботы = Новый Структура; // настройки по умолчанию ПараметрыРаботы . Вставить( " ПоказыватьЕдинственныйРаздел " , Ложь); ПараметрыРаботы . Вставить( " ЗадаватьДатуДляПрочихРазделов " , Ложь); ПараметрыРаботы . Вставить( " ИспользоватьВнешнихПользователей " , Ложь); // а теперь запросим конфигурацию ­ потребитель на случай , // если эти умолчания не устраивают МояБиблиотекаПереопределяемый . ПриПолученииНастроекПараметровРаботы(ПараметрыРаботы); Возврат ПараметрыРаботы; КонецФункции
```

- 3 . 4 . При обновлении версии библиотеки в конфигурации­потребителе особого внимания требуют модули корневого объекта конфигурации и переопределяемые общие модули , так как автоматическое обновление таких «узких мест» конфигурации­потребителя невозможно . Для настройки в конфигурации переопределяемых общих модулей рекомендуется придерживаться общего подхода:
- При первой настройке переопределяемого общего модуля следует ознакомиться с документацией к его экспортным процедурам и функциям , приведенной в комментариях к ним . И при необходимости вписать реализацию в экспортные процедуры и функции модуля .
- При каждом обновлении переопределяемого общего модуля требуется перенести новые экспортные процедуры и функции , удалить устаревшие и убедиться , что комментарии , количество и имена параметров у всех функций совпадают с их библиотечными эквивалентами . При необходимости вписать реализацию в новые экспортные процедуры и функции модуля , а также актуализировать реализацию уже существующих функций , если в новой версии библиотеки было изменено их назначение или состав параметров .

## См . также

- Переопределение общих модулей в условиях иерархии библиотек

## Переопределение общих модулей в условиях иерархии библиотек

Методическая рекомендация (полезный совет)

При разработке нескольких библиотек , стоящих на поддержке друг у друга , следует минимизировать трудоемкость по обновлению кода переопределяемых общих модулей в каждой из библиотек . Для этого рекомендуется использовать следующую методику:

- 1 . В библиотеке нижнего уровня иерархии (самой базовой) объявляется переопределяемый модуль по общим правилам , изложенным выше . Например: БазоваяБиблиотекаПереопределяемый .
- 2 . В библиотеках более высокого уровня реализация процедур и функций переопределяемого модуля базовой библиотеки может быть при необходимости доопределена . При этом в переопределяемом модуле размещается не сама реализация (ее код) , а только один вызов .

Например , в общем модуле БазоваяБиблиотекаПереопределяемый в библиотеке верхнего уровня «Базовая библиотека» реализация фактически размещается в модуле МодульБазовойБиблиотеки:

```
Процедура НастроитьИнтерфейс(Знач ПараметрыРаботы) Экспорт // Начало: Базовая библиотека МодульБазовойБиблиотеки . НастроитьИнтерфейс(Знач ПараметрыРаботы); // Конец: Базовая библиотека
```

## КонецПроцедуры

в этом же общем модуле БазоваяБиблиотекаПереопределяемый в следующей библиотеке верхнего уровня «Библиотека второго уровня»:

```
Процедура НастроитьИнтерфейс(Знач ПараметрыРаботы) Экспорт // Начало: Базовая библиотека МодульБазовойБиблиотеки . НастроитьИнтерфейс(Знач ПараметрыРаботы); // Конец: Базовая библиотека // Начало: Библиотека второго уровня МодульБиблиотекиВторогоУровня . НастроитьИнтерфейс(Знач ПараметрыРаботы); // Конец: Библиотека второго уровня
```

```
и т . д .
```

- 3 . Таким образом , в конечной конфигурации­потребителе реализация переопределяемого модуля имеет вид:

```
Процедура НастроитьИнтерфейс(Знач ПараметрыРаботы) Экспорт // Начало: Базовая библиотека МодульБазовойБиблиотеки . НастроитьИнтерфейс(Знач ПараметрыРаботы); // Конец: Базовая библиотека // Начало: Библиотека второго уровня МодульБиблиотекиВторогоУровня . НастроитьИнтерфейс(Знач ПараметрыРаботы); // Конец: Библиотека второго уровня // а теперь выполняем настройки так , как это надо нашей конфигурации // . . . КонецПроцедуры
```

Такой подход позволяет

- скрыть от библиотек верхнего уровня и конфигураций­потребителей детали реализации библиотек более нижнего уровня , что минимизирует риск ошибки при обновлении кода переопределяемого общего модуля;
- но при этом , в общем случае , оставляет возможность выбора: воспользоваться или отказаться от нее .

## Размещение сведений о настройках подсистемы

Для задействования возможностей по настройке функциональности библиотеки для работы в конкретной конфигурации­потребителе используются переопределяемые объекты .

Все настройки подсистемы , доступные для изменения разработчикам на внедрении , можно разделить на общие для всех объектов подсистемы (или для группы объектов) и специфичные для конкретных объектов . При выборе места размещения таких настроек следует руководствоваться следующими принципами .

- 1 . Настройки подсистемы , общие для всех объектов или для группы объектов метаданных , рекомендуется задавать в переопределяемом модуле . Для этого создать одну процедуру с именем ПриОпределенииНастроек и параметром Настройки типа Структура , которая предварительно заполнена значениями по умолчанию . Использования структуры в качестве значения параметра позволяет расширять программный интерфейс , добавляя новые свойства в структуру , без нарушения обратной совместимости .

Например , определение настроек подсистемы Варианты отчетов , общих для всех отчетов в общем модуле ВариантыОтчетовПереопределеяемый:

```
Процедура ПриОпределенииНастроек(Настройки) Экспорт Настройки . ВыводитьОтчетыВместоВариантов = Истина; Настройки . ВыводитьОписания = Истина; Настройки . ДругиеОтчеты . ПоказыватьФлажок = Истина; КонецПроцедуры
```

- 1 . 1 . Для определения списка объектов конфигурации , с которыми работает подсистема , не следует использовать перебор объектов метаданных с конструкцией Попытка Исключение . Вместо этого , рекомендуется создавать отдельную процедуру переопределяемого модуля , в которой перечислять такие объекты . Например , ПриОпределенииПодключенныхОтчетов содержит в себе список отчетов конфигурации , подключенных к подсистеме .
- 1 . 2 . Процедуры , позволяющие переопределить бизнес­логику сразу для всех объектов , с которыми работает подсистема , также рекомендуется размещать в переопределяемом модуле . Имена процедур рекомендуется выбирать исходя из выполняемого действия . Например: ПриРегистрацииИзмененийКлючейВариантовОтчетов описывает изменения имен вариантов отчетов . Для каждого выполняемого действия рекомендуется создавать отдельную процедуру .
- 2 . Настройки или обработчики , специфичные для отдельного объекта , рекомендуется размещать в модуле менеджера этого объекта . Для процедуры , содержащей в себе информацию о свойствах , реквизитах или о наличии методов объекта рекомендуется использовать имена вида ПриОпределенииНастроек&lt;ИмяПодсистемы&gt; . Например ПриОпределенииНастроекВариантовОтчетов .

Процедуры , задающие переопределяемую бизнес­логику , специфичную для конкретного объекта так же рекомендуется размещать в модуле менеджера этого объекта . Для каждого выполняемого действия рекомендуется создавать отдельную процедуру . При этом наличие той или иной процедуры в модуле менеджера задается в процедуре ПриОпределенииНастроек&lt;ИмяПодсистемы&gt; , что позволяет избежать использования конструкции Попытка Исключение для проверки наличия процедуры .

Например , в модуле менеджера отчета заданы процедуры:

```
Процедура ПриОпределенииНастроекВариантовОтчетов(Настройки) Экспорт Настройки . ОпределитьНастройкиФормы = Истина; Настройки . Размещение . Вставить(ВариантыОтчетовКлиентСервер . ИдентификаторНачальнойСтраницы() , " Важный " ); Настройки . ПриПолученииДанныхОтчета = Истина; // Наличие процедуры . КонецПроцедуры Процедура ПриПолученииДанныхОтчета(Данные) Экспорт Данные . Очистить(); // Своя процедура получения данных . КонецПроцедуры
```

Процедура ПриОпределенииНастроекВариантовОтчетов определяет настройки конкретного отчета и сообщает о наличии процедуры ПриПолученииДанныхОтчета , в которой задана переопределяемая

обработка данных отчета .

## Обеспечение обратной совместимости библиотек

- 1 . При разработке библиотек необходимо обеспечивать обратную совместимость между различными версиями библиотек в пределах одной редакции библиотеки .

Например , версии библиотеки 2 . 0 . 1 , 2 . 0 . 2 и 2 . 0 . 5 должны быть обратно совместимы . Однако допустимо , если следующая редакция 2 . 1 будет содержать существенные изменения , нарушающие это правило .

Обратная совместимость библиотек позволяет существенно минимизировать затраты на обновление библиотеки в конфигурациях­потребителях , так как не требует от прикладных разработчиков пересматривать код и адаптировать объекты метаданных своих конфигураций под новые требования и возможности библиотеки . Прикладное решение может «уверенно» использовать старые возможности библиотеки , не «торопясь» переходить на новые .

При разработке нескольких библиотек , стоящих на поддержке друг у друга , обратная совместимость позволяет вести совместную разработку «соседних» библиотек на разных версиях базовой библиотеки , без необходимости частого обновления всего дерева библиотек .

- 1 . 1 . В целях обеспечения обратной совместимости следует
- выделить программный интерфейс библиотеки , скрыв от потребителей все остальные детали ее реализации;
- и не изменять программный интерфейс и поведение . Его допустимо только расширять .

При этом требования обеспечения обратной совместимости имеют приоритет над следующими стандартами разработки:

- Имя , синоним комментарий
- Названия процедур и функций
- 1 . 2 . К программному интерфейсу библиотеки относятся те ее объекты метаданных , которые предназначены для использования в прикладном коде:
- имена и состав параметров экспортных процедур и функций общих модулей , модулей объектов , менеджеров , наборов записей и т . п . , которые размещены в разделе «программный интерфейс»;
- имена и состав параметров всех экспортных процедур и функций переопределяемых общих модулей;
- имена объектов метаданных (включая их реквизиты , табличные части и пр . ) , к которым допускается непосредственное обращение из прикладного кода или из запросов .

Программный интерфейс библиотеки является самостоятельным предметом проектирования .

1 . 3 . Рекомендуется размещать программный интерфейс библиотеки только в ее общих модулях , а не в модулях объектов , менеджеров , наборов записей и т . п .

1 . 4 . Для разделения программного интерфейса от служебных процедур и функций необходимо размещать их в разных разделах модуля или в разных общих модулях .

При размещении в разных общих модулях , к модулям со служебными процедурами и функциями может быть добавлен постфикс Служебный . Например:

- Общие модули ОбменСообщениями и ОбменСообщениямиКлиент – программный интерфейс подсистемы «Обмен сообщениями»
- Общий модуль ОбменСообщениямиСлужебный – служебные процедуры и функции подсистемы , которые не предназначены для использования в коде конфигурации­потребителя .

Такое размещение программного интерфейса в отдельных общих модулях позволяет

- сосредоточить весь программный интерфейс библиотеки в относительно небольшом , обозримом количестве общих модулей ,
- а также выводить в контекстной подсказке при вводе текстов модулей только те процедуры и функции , которые действительно являются частью программного интерфейса . Например , после точки в строке «ОбменСообщениями . » в редакторе текста модуля разработчик конфигурации­потребителя увидит только то , что ему действительно может понадобиться в работе .

1 . 5 . Обратную совместимость не нарушает расширение программного интерфейса библиотеки , например:

- добавление нового реквизита в справочник , регистр и т . п .
- добавление новой функции;
- добавление еще одного необязательного параметра в конец списка формальных параметров существующей функции .

1 . 6 . В остальных случаях , когда согласно п . 1 допустимо отказаться от поддержки обратной совместимости , следует документировать в сопроводительной документации к библиотеке любые изменения , приводящие к нарушению обратной совместимости . Документация должна включать инструкцию для прикладных разработчиков по адаптации своих конфигураций к новому программному интерфейсу библиотеки . Примеры фрагментов документации:

- Общий модуль ВнешниеЗадачиПереопределяемыйВызовСервера переименован в
- ВнешниеЗадачиВызовСервераПереопределяемый . Необходимо заменить все обращения к этому модулю в коде конфигурации .
- Процедура УстановитьПроизвольныйЗаголовокПриложения общего модуля СтандартныеПодсистемыКлиент переименована в УстановитьРасширенныйЗаголовокПриложения . Необходимо заменить все обращения к этой процедуре в коде конфигурации .
- Отчет СправкаПоИсполнительскойДисциплине удален . Вместо него следует использовать одноименный вариант отчета Задачи . Необходимо заменить все обращения к этому отчету в коде и в метаданных конфигурации .
- В общий модуль ЗащитаПерсональныхДанныхПереопределяемый добавить процедуру
- ДополнитьДанныеОрганизацииОператораПерсональныхДанных , перенеся ее определение из поставки библиотеки .
- Хранение предмета взаимодействий перенесено из реквизита документа в реквизит Предмет регистра сведений ПредметыПапкиВзаимодействий . Необходимо заменить все обращения к реквизиту Предмет документов взаимодействий на реквизит Предмет регистра сведений .
- 2 . Для обеспечения обратной совместимости программного интерфейса библиотеки в условиях активного развития ее функциональности ниже приведен ряд практических рекомендаций .
- 2 . 1 . При необходимости переименовать (или удалить) экспортную функцию (процедуру) следует оставить старую реализацию функции , пометив ее как устаревшую с помощью комментария вида:

```
// Устарела: Следует использовать функцию ПересчитатьПоКурсу // … Функция ПересчитатьИзВалютыВВалюту(Сумма , ВалютаНач , ВалютаКон , ПоКурсуНач , ПоКурсуКон , ПоКратностьНач = 1 , ПоКратностьКон = 1) Экспорт
```

и разместить новую версию функции с новым именем (в данном примере ­ ПересчитатьПоКурсу) . Как правило , реализация старой версии функции при этом заменяется на вызов новой версии функции .

При этом устаревшую функцию следует перенести в область общего модуля УстаревшиеПроцедурыИФункции , которая размещена внутри области ПрограммныйИнтерфейс . В процедурах и функциях , размещенных в области УстаревшиеПроцедурыИФункции , допустимы отклонения от других стандартов разработки согласно п . 1 . 1 .

В этом случае , существующий прикладной код не потребуется переписывать . При этом , если при выпуске новой редакции библиотеки будет принято решение удалить все устаревшие функции , то такие функции могут быть легко выявлены в коде библиотеки и удалены .

По каждой устаревшей функции в сопроводительной документации к библиотеке также даются рекомендации по их замене следующего вида:

- Процедура ПересчитатьИзВалютыВВалюту общего модуля ОбщегоНазначения устарела , вместо нее следует использовать ПересчитатьПоКурсу . Устаревшая функция оставлена для обратной совместимости .
- 2 . 2 . При необходимости пересмотреть состав параметров экспортных функций (процедур) следует использовать опциональные параметры , которые добавляются в конец списка формальных параметров . Например:

```
Функция ПересчитатьИзВалютыВВалюту(Сумма , ВалютаНач , ВалютаКон , ПоКурсуНач , ПоКурсуКон , ПоКратностьНач = 1 , ПоКратностьКон = 1) Экспорт
```

При этом в случае большого числа параметров рекомендуется более радикально пересмотреть их состав и действовать согласно п . 2 . 1 .

- 2 . 3 . Для минимизации ситуаций , когда в конфигурациях­потребителях возникает потребность в прямом обращении к объектам метаданным библиотеки (реквизитам , табличным частям справочников , документов и пр . ) , следует предусмотреть в библиотеке программный интерфейс , посредством которого прикладной код может взаимодействовать с библиотекой . Это снижает зависимость прикладного кода от особенностей реализации библиотеки и , тем самым , повышает его устойчивость к обновлениям на новые версии библиотеки .

Например , вместо «прямого» запроса к библиотечному регистру из прикладного кода:

```
Запрос = Новый Запрос; Запрос . Текст = " ВЫБРАТЬ | ОбластиДанных . Представление |ИЗ | РегистрСведений . ОбластиДанных КАК ОбластиДанных |ГДЕ | ОбластиДанных . ОбластьДанных = &ОбластьДанных " ; Запрос . УстановитьПараметр( " ОбластьДанных " , ПараметрыСеанса . ОбластьДанныхЗначение); ТаблицаОбластейДанных = Запрос . Выполнить() . Выгрузить(); ИмяПриложения = ?(ТаблицаОбластейДанных . Количество() = 0 , "" , ТаблицаОбластейДанных . Получить(0) . Получить(0));
```

следует предусмотреть в библиотеке экспортную функцию , которая специально предназначена для использования в прикладном коде:

```
ИмяПриложения = РаботаВМоделиСервиса . ИмяПриложения();
```

При этом если в текущей версии библиотеки отсутствует специализированная функция , а потребность обращаться к ее данным есть уже сейчас , то рекомендуется реализовать в прикладном коде временную функцию , которую при следующем обновлении библиотеки можно легко заменить на ее библиотечный эквивалент .

2 . 4 . Другой пример скрытия деталей реализации библиотеки от потребителя . Допустим:

- в первой версии библиотеки потребителям предоставлялась экспортная функция общего модуля с повторным использованием возвращаемых значений;
- но в следующей версии библиотеки это проектное решение пересмотрено в пользу «обычного» общего модуля , куда эта функция была перенесена (аналогично , если в обратную сторону) .

В данном примере , для того чтобы избавить потребителя библиотеки от дополнительных усилий по замене вызовов «старой» функции на новую , рекомендуется сразу размещать экспортную функцию в «обычном» модуле , в его разделе «программный интерфейс» . Тогда эта функция , в зависимости от текущего проектного решения , может вызывать служебную функцию из модуля с повторным использованием возвращаемых значений или из любого другого модуля , или непосредственно сама содержать реализацию . Однако для потребителя ее местоположение уже не будет меняться в следующих версиях библиотеки .

## Разработка ролей в библиотеках

- 1 . При проектировании ролей в библиотеках рекомендуется придерживаться общего подхода к определению границ функциональности библиотеки:
- в библиотеку включаются те объекты метаданных , которые в неизменном или переопределенном виде войдут в состав конфигурацийпотребитилей .
- объекты , специфичные для конкретной конфигурации­потребителя , в библиотеке не разрабатываются , а создаются на этапе внедрения и настройки библиотеки в конфигурации .
- 2 . В большинстве случаев , библиотека должна предоставлять готовый набор ролей для работы со своими данными (с объектами метаданных , содержащих данные: справочники , регистры и т . п . ) .

Например , вместе с универсальной подсистемой анкетирования в библиотеку входят роли для добавления и изменения шаблонов , опросов , ответов на вопросы анкет , просмотра ответов на вопросы и для администрирования (настройки) подсистемы анкетирования .

Исключение из этого правила составляют случаи , когда

- библиотечный объект не является «самостоятельным» , а всегда подчинен какому ­ либо объекту­владельцу конфигурации . Например: библиотечные присоединенные файлы к объектам конфигурации (номенклатуре , проектам и т . п . ) не имеет собственных ролей , т . к . доступ к файлам задается в ролях для работы с номенклатурой , проектами и т . п .
- библиотечный объект не является полностью законченным объектом , готовым для использования «как есть» , а предполагает существенное переопределение в прикладных решениях . Например , библиотечные справочники Организации , Физические лица и т . п . содержат минимальную базовую реализацию , общую для всех прикладных решений , и не предоставляют «полноценные» роли для работы с ними .
- библиотека не содержит данных , а только алгоритмы для работы с ними .
- 3 . При этом в ролях могут быть определены не только права к библиотечным объектам , но и логика ограничений доступа к ним на уровне записей (RLS – Row­Level Security) .

В этом случае поставляемый RLS должен быть разработан таким образом , чтобы в прикладных решениях он использовался «как есть» и его не приходилось менять (дорабатывать) . Тогда при обновлении библиотеки в конфигурации библиотечные роли всегда переносятся в конфигурацию «как есть» .

Исключение из этого правила составляют случаи , когда

- в прикладном решении не предусмотрено никакой настройки прав доступа на уровне записей . В этом случае тексты RLS , если они предусмотрены , должны быть удалены из библиотечных ролей на этапе внедрения (обновления) библиотеки в конфигурацию .
- в прикладном решении предусмотрены прикладные сущности , в разрезе которых настраивается доступ , в том числе , к библиотечным объектам . Например , в разрезе «проектов» или «грифов доступа» предусмотрена настройка видимости библиотечных «присоединенных файлов» . В этом случае в тексты RLS в библиотечных ролях должна быть добавлена логика ограничения для этих сущностей на этапе внедрения (обновления) библиотеки в конфигурацию , либо должно быть принято решение не поставлять роли к таким объектам из библиотеки .

4 . При использовании в библиотеке правил поставки для всех библиотечных ролей следует задавать правило поставки «Изменения разрешены» . Это требование обусловлено технологическими особенностями платформы 1С:Предприятие: при добавлении/удалении метаданных в конфигурации происходит неявно изменение ролей .

## См . также

- Стандартные роли
- Переопределяемые и поставляемые объекты библиотеки
- Настройка ролей и прав доступа

## Размеры экрана

- 1 . При проектировании интерфейсов типовым разрешением экрана следует считать 1024х768 пикселей . Разработку (конфигурирование) нужно вести в стандартном разрешении ‐ 96 DPI .
- 2 . Условия эксплуатации:
- Основное окно программы растянуто на весь экран
- Панель задач операционной системы видна , расположена в нижней части экрана и уменьшает его высоту на 40 пикселей
- Программа открыта в браузере . Высота рабочей области сокращается из‐ за заголовков и панелей браузера в среднем на 60 пикселей (Internet Explorer – на 54 , Mozilla Firefox – на 63 , Google Chrome – на 60) .
- 3 . Исходя из вышеприведенных значений , область , доступная для работы с программой , имеет размер 1024х668 пикселей .
- 4 . При типовом разрешении экрана элементы внутри форм должны помещаться без вертикальной и горизонтальной полос прокрутки . Исключение составляют списки , в которых вертикальная полоса прокрутки допускается , а горизонтальная – является нежелательной .

См .

также: Общие рекомендации (8 . 2)

Оформление групп разделов с настройками и справочниками

1

.

Группа раздела может включать в себя:

–

–

Заголовок (1)

Реквизиты и настройки (2)

–

Информационные сообщения (3)

Например:

.

<!-- image -->

2

.

Разделы

,

состоящие из нескольких групп

,

должны быть реализованы в виде свертываемых групп

.

отображения заголовка свертываемой группы в Конфигураторе используются следующие параметры:

–

–

–

–

Поведение: Свертываемая

ОтображениеУправления:

Картинка

Отображение: Обычное выделение

ЦветТекстаЗаголовка: Авто

–

ШрифтЗаголовка: Авто

Например:

2

.

1

.

Рекомендуется формировать группы раздела таким образом

все группы умещались на экране

прокрутки

Например

.

,

в разделе

Продажи

.

Следует сворачивать группы

все группы свернуты по

,

,

чтобы при типовом разрешении 1024х768 пикселей

по возможности избегая

‐

умолчанию:

<!-- image -->

появления

вертикальной

Для

правильного

"

.

"

<!-- image -->

2

.

2

.

Допускается оставлять первую группу раздела развернутой

формы за

,

если это не повлечет за собой

пределы типового разрешения экрана 1024х768 пикселей

Например

экрана:

<!-- image -->

в разделе

"

Закупки

"

первая группа развернута

.

остальные группы в свернутом виде не выходят за рамки

"

растягивания

"

,

—

- 3 . Раздел , состоящий из одной группы , должен быть развернутым и иметь параметры " Поведение: Обычное " . Заголовок в такой группе не используется .

Например:

<!-- image -->

## Компоновка форм

Содержание:

1

.

Общие принципы

2

3

4

.

.

Вкладки

Вспомогательные формы

.

Свертываемые группы

## 1 . Общие принципы

<!-- image -->

<!-- image -->

<!-- image -->

<!-- image -->

1

.

3

.

1

.

Обязательно к соблюдению

Использование вертикальной зеленой черты для выделенных отдельных элементов и групп взаимосвязанных реквизитов не допускается

выделения следует использовать состояния:

‐

слабое выделение;

‐

‐

обычное выделение;

нет

.

<!-- image -->

Правильно

Неправильно

Использование сильного выделения с вертикальной зеленой полосой допускается в тех случаях

взаимосвязанных реквизитов располагаются в несколько колонок по горизонтали

Например

в документе

"

Шаблон магнитных карт

"

.

соблюдается четкое визуальное разделение групп реквизитов:

.

В качестве

,

,

когда группы

<!-- image -->

1 . 4 . Внутри формы документа рекомендуется группировать элементы следующим образом:

<!-- image -->

отдельной вкладке

.

<!-- image -->

"

"

1 . 4 . 2 . Если на форме имеются несколько невзаимосвязанных табличных частей , то их следует размещать на отдельных

<!-- image -->

1 . 4 . 2 . Если на форме имеются несколько невзаимосвязанных табличных частей , то их следует размещать на отдельных вкладках .

- 1 . 5 . Формы следует проектировать таким образом , чтобы они не были перегружены функциями , реквизитами и элементами . Чтобы этого достичь , можно использовать:
- ‐ возможность скрытия элементов в зависимости от настроек программы или функциональных опций
- ‐ размещение части элементов на отдельных вкладках , в свертываемых группах или во вспомогательных формах Конкретный способ выбирается в зависимости от ситуации и решаемых задач .

## 2 . Вкладки

<!-- image -->

- 2 . 2 . Поля , обязательные для заполнения , следует располагать на вкладке , активной в момент открытия формы
- 2 . 3 . Не рекомендуется делать вкладки , содержащие небольшое число элементов (1‐2) , если они не занимают все пространство вкладки

## 3 . Вспомогательные формы

- 3 . 1 . При размещении элементов во вспомогательных формах рекомендуется действовать следующим образом:
- 1 . Среди всего множества реквизитов и элементов выбрать второстепенные , в большинстве случаев заполняемые автоматически , а также те , которые использует небольшое количество пользователей . Чаще всего такие реквизиты будут являться необязательными для заполнения
- 2 . Разделить эти элементы на несколько смысловых групп
- 3 . Разместить эти группы в одной или нескольких вспомогательных формах
- 3 . 2 . Для открытия вспомогательной формы следует использовать гиперссылку , размещаемую в основной форме . При открытии вспомогательная форма блокирует окно владельца .
- 3 . 3 . Текст гиперссылки может формироваться одним из двух способов . Вариант 1 . В тексте ссылки указывается название вспомогательной формы . При этом название должно быть таким , чтобы по нему быть понятно , какие реквизиты могут располагаться внутри .

Например:

<!-- image -->

Вариант 2 . В тексте ссылки указывается перечень значений реквизитов , заполняемых внутри вспомогательной формы . Если этот перечень слишком велик , то в первую очередь в него следует вынести реквизиты:

- ‐ значения которых важно видеть сразу из основной формы
- ‐ которые обязательны для заполнения

Например:

4

4

‐

‐

<!-- image -->

<!-- image -->

<!-- image -->

<!-- image -->

## Шрифты

Действует для платформы с версии 8 . 3 . 2

При разработке конфигураций следует использовать стилевые шрифты:

&lt;Шрифт текста&gt;

&lt;Мелкий шрифт текста&gt;

- &lt;Крупный шрифт текста&gt;

&lt;Очень крупный шрифт текста&gt;

При необходимости также можно использовать шрифты из состава MS Core

Fonts:

Andale Mono

Arial

Arial Black

Comic Sans MS

Courier New

Georgia

Impact

Times New Roman

Trebuchet MS

Verdana

Webdings

Не следует использовать в конфигурациях прочие шрифты , так как они могут поддерживаться не во всех операционных системах , в которых работает клиент 1С:Предприятия .

## Общие принципы построения командного интерфейса

Командный интерфейс – средство навигации пользователей по функциональности конфигурации . Он включает в себя:

-  Панель разделов
-  Панель функций текущего раздела
-  Меню функций
-  Команды навигации и действий

Каждый из этих элементов имеет свое назначение , но все вместе они создают пространство команд – возможностей для пользователя .

Состав и расположение панелей можно настраивать . При этом следует руководствоваться спецификой прикладного решения , а также следующими принципами:

- 1 . Количество элементов в панелях и меню должно быть таким , чтобы при стандартном разрешении экрана они помещались без прокрутки
- 2 . Элементы внутри панелей и меню следует располагать в порядке убывания важности и частоты использования . Наиболее приоритетные пункты и команды следует располагать первыми .
- 3 . Не рекомендуется располагать рядом команды и пункты меню , в названиях которых совпадают первые символы .
- 4 . Командный интерфейс нужно проектировать таким образом , чтобы он способствовал повышению эффективности выполнения повседневной работы и быстрому освоению программы . Чтобы этого добиться , при разработке следует учитывать мнение пользователей и их представление о том , как команды должны быть сгруппированы .

## Правильно

Неправильно

Регламентированные отчеты Отчеты для руководителя

Регламентированные отчеты

Регламентные операции

См .

также: Командный интерфейс (8 . 2)

## Панель разделов

Панель разделов может выводиться как в виде отдельной панели , так и в составе меню функций:

<!-- image -->

<!-- image -->

## 1 . Состав панели

Панель разделов является " лицом " программы и имеет большое значение на этапе освоения , поэтому состав и порядок разделов следует проектировать с особой тщательностью . Количество и состав разделов должен соответствовать реальным участкам работ и областям деятельности так , как их видят пользователи .

- 1 . 1 . Раздел " Главное " по умолчанию присутствует во всех конфигурациях и располагается первым . В него рекомендуется добавлять команды перехода к объектам , относящимся ко всей конфигурации , и не включать объекты , относящиеся к конкретным разделам учета или областям деятельности .
- 1 . 2 . Списки с условно‐постоянной информацией (справочники , регистры сведений , списки перечислений и другие) , в командном интерфейсе можно размещать:
-  внутри раздела , с которым связан такой список (в конце меню или в " См . также " )
- Например , список должностей в разделе Кадры
-  в специально выделенном разделе конфигурации . При этом в других разделах команды перехода к подобным спискам , как правило , не размещаются
- Например , разделы " Справочники " , " Настройки " , " НСИ " .
-  в панели навигации формы списка с условно‐постоянной информацией , которой они " подчинены "
- Например , " Счета учета номенклатуры " в панели навигации справочника " Номенклатура "

Исключение составляют списки с условно‐постоянной информацией , с которых начинаются бизнес‐процессы . Такие списки рекомендуется помещать в группы меню соответствующего раздела .

Например , справочник " Сотрудники " размещается в разделе " Кадры " , потому что сначала в него вводится информация о работнике , а потом на основании этих данных создается приказ о приеме на работу и другие документы .

- 1 . 3 . Разделы для настройки , администрирования и выполнения сервисных действий следует располагать в конце панели .

## 2 . Названия разделов

- 2 . 1 . Общая длина названия раздела не должна превышать 25 знаков с учетом пробелов . Лучше выбирать названия примерно одного размеры по ширине , чтобы они смотрелись единообразно и ровно .
- 2 . 2 . Старайтесь сделать названия разделов конкретными и запоминающимися . Назначение раздела должно быть понятно из его названия .
- 2 . 3 . По возможности не используйте длинные слова . При выборе названия рекомендуется комбинировать слова следующим образом:
- 2 . 4 . Используйте в названиях только общеупотребительные и соответствующие целевой аудитории сокращения и аббревиатуры . Например , " НДС " или " МСФО " .

Комбинация слов

Пример

Одно‐два средних слова

Продажи

Зарплата и персонал

Одно длинное и одно короткое

Отчетность и справки

Два коротких и одно длинное

Учет, т, налоги , отчетность

При этом сокращение обязательно нужно расшифровать во всплывающей подсказке .

Например , для названия раздела " ОС и НМА " появляется всплывающая подсказка " Основные средства и нематериальные активы "

- 2 . 5 . Не рекомендуется делать раздел с названием " Сервис " , т . к . он будет перекликаться с пунктом " Сервис " главного меню и группой " Сервис " в панели / меню функций

## 3 . Картинки разделов

- 3 . 1 . Названия разделов рекомендуется выводить в режиме " Картинка и текст "
- 3 . 2 . Картинки следует делать разными по начертанию и ведущим цветам для лучшей запоминаемости . Но при этом они должны быть нарисованы в одном стиле , с одинаковым направлением света . Картинки должны быть нарисованы во фронтальной плоскости проекции

См . также:

Панель разделов (8 . 2) Названия разделов (8 . 2) Картинки разделов (8 . 2) .

Подсказки для интерфейсных подсистем (8 2)

## Навигация внутри раздела

<!-- image -->

## 1 . Состав команд

1 . 1 . В раздел рекомендуется помещать команды перехода к:

-  спискам и журналам документов
-  спискам " первичных " документов (данных) , с которых начинаются бизнес‐процессы
-  рабочим местам
-  специальным обработкам , похожим на обычные списки
-  отчетам

При этом все эти команды должны решать задачу по конкретному участку работ или области деятельности .

- 1 . 2 . Второстепенные и подчиненные другим объекты можно не выносить в командный интерфейс .

Чаще всего это справочники и регистры сведений , доступ к которым можно получить из документов или других объектов .

Например:

Справочники " Контрагенты " , " Договоры " выносятся в командный интерфейс:

- ‐ эти справочники открываются из разных документов , но они могут использоваться и без привязки к документам , например , для просмотра контактной информации по контрагенту или условий оплаты по договору
- ‐ справочники могут содержать много элементов , может потребоваться работа с их списком . Например , поиск договоров по статусу или периоду , удаление дубликатов контрагентов

## 2 . Названия команд

2 . 1 . Чтобы при стандартном разрешении экрана не возникало полос прокрутки , рекомендуется следить , чтобы названия команд не превышали 38 символов , а лучше – умещались в 30 .

## 3 . Группировка команд

- 3 . 1 . Область команд включает в себя блок с командами навигации и блок с командами действий , но для пользователя все они выглядят одинаково . Поэтому при группировке следует объединять команды не по техническим признакам (вид объекта; действие , происходящее при выборе команды) , а по тому , как их структурирует пользователь в своей работе .
- 3 . 2 . В одну группу рекомендуется включать не более 5‐6 команд

<!-- image -->

Справочник

средства

"

"

Причины списания основного

не выносится в командный интерфейс:

- ‐ этот справочник можно открыть из одного специализированного документа " Списание основного средства "
- ‐ элементов этого справочника мало и они редко изменяются , у пользователя нет необходимости просматривать список этих элементов в отрыве от контекста

<!-- image -->

<!-- image -->

<!-- image -->

Командная панель документа

1

.

В командной панели кнопка по умолчанию должна быть расположена самой крайней слева

большинстве случаев кнопкой по умолчанию является

2

3

.

.

или

Провести и закрыть

"

"

Порядок расположения команд во всех документах должен быть одинаковым

Состав системных кнопок командной панели

друг друга изменять не рекомендуется

4

.

.

Командная панель должна позволять пользователю при стандартных настройках экрана (ширина экрана 1024 точки

панель инструментов выведена слева вертикально) выполнить

открывая подменю

5

.

‐

‐

‐

‐

‐

‐

‐

.

Еще

При стандартных настройках экрана пользователю должны быть сразу видны все все важные команды:

Провести и закрыть / Записать и закрыть

Записать

Провести

Создать на основании

Печать

Глобальные команды

‐

Дополнительные сведения

‐

‐

.

.

Движения документа

и т

д

Отчеты (контекстные

,

из панели навигации)

Если в командной панели расположено большое количество команд

.

6

кнопками с картинками без текста

Например

,

,

:

.

командная панель документа

Реализация товаров и услуг

В Конфигураторе элементы командной панели структурируются следующим образом:

Команда

Команда

Подменю

Подменю

Подменю

"

Записать

Провести

"

—

—

свойство Отображение = Картинка

свойство Отображение = Картинка

"

"

"

"

—

Создать на основании

свойство Отображение = Картинка

Печать

Отчеты

"

—

"

—

свойство Отображение = Авто

свойство Отображение = Авто

См

.

также: Командная панель формы (8

.

2)

"

"

"

"

самые важные и частотные действия с документом

,

.

В подавляющем

Записать и закрыть

"

,

и их порядок относительно

,

не

,

.

отображаемых платформой по умолчанию

"

"

"

рекомендуется отображать важные команды

<!-- image -->

## Итоги в документах

Итоги в документах можно выводить несколькими способами:

-  отдельными полями ввода
-  в подвалах таблиц

## 1 . Итоги в виде отдельных полей ввода

## Расположение

1 . 1 . Итоги размещаются сразу под таблицей (или несколькими таблицами) , по которым они выводятся . Не следует вставлять элементы , разделяющие табличную часть и группу с итогами .

<!-- image -->

<!-- image -->

<!-- image -->

<!-- image -->

## Поля " Ответственный " и " Комментарий "

## 1 . Поле " Комментарий "

Поле " Комментарий " может выводиться:

-  В виде однострочного поля в нижней части формы документа

-  В виде многострочного поля на отдельной вкладке формы документа

Если поле " Комментарий " в типовых случаях будет большим , то допускается делать его многострочным и выносить на отдельную вкладку . В остальных случаях рекомендуется использовать однострочное поле " Комментарий " .

## 1 . 1 . Однострочное поля " Комментарий "

-  Располагается в нижней части формы документа , самым последним

-  Заголовок располагается слева от поля

-  В поле отсутствует кнопки выбора , списка выбора и другие

- 1 . 2 . Многострочное поле " Комментарий "

-  Располагается на отдельной вкладке

-  Заголовок " Комментарий " выводится в названии вкладки . У поля заголовок не отображается

-  На вкладке размещается только поле с текстом комментария , которое растягивается по вертикали и по горизонтали

-  Если поле с комментарием заполнено , то в заголовке вкладки отражается картинка " Комментарий

- 2 . Поле " Ответственный "

-  Поле следует выводить в нижней части формы документа .

- 3 . Группа полей " Ответственный " и " Комментарий "

-  При одновременном наличии в форме документа поля " Ответственный " и однострочного поля " Комментарий " , их следует объединять в группу .

-  Эту группу следует располагать в самом низу формы документа .

-  Внутри группы поля размещаются в одну строку , рядом друг с другом .

<!-- image -->

<!-- image -->

См . также:

<!-- image -->

## Тумблер

- 1 . Тумблер следует использовать в ситуации , когда при выборе значения происходит изменение состава или расположения элементов в форме . Он похож на кнопку и своим видом показывает, т, что при нажатии что ‐ то произойдет .
- 2 . Количество кнопок в тумблере рекомендуется делать небольшим , а их названия ‐ краткими . Если количество вариантов ‐ большое , а названия длинные , то лучше использовать выпадающий список .
- 3 . Заголовок рекомендуется добавлять в случае , если:
- ‐ по названиям кнопок не понятно назначение тумблера
- ‐ тумблер выступает в качестве переключателя

<!-- image -->

## Подсказки на форме

Подсказки рекомендуется выводить по тем элементам интерфейса , которые требуют пояснения , расшифровки и донесения до пользователя подробного описания их назначения . Для реквизитов , используемых в ежедневной работе , подсказки добавлять не следует .

В тексте подсказки не рекомендуется приводить инструкции и объяснять работу реквизита , вместо этого следует оптимизировать сценарии работы , с ним связанные .

## 1 . Текстовые подсказки к полям

- 1 . 1 . Текстовые подсказки к полям рекомендуется прятать в гиперссылке " ? " Для этого в Конфигураторе устанавливается режим отображения подсказки " Кнопка " .
- 1 . 2 . Если в подсказку , помимо обычного текста , необходимо добавить ссылки , иконки или использовать форматированный текст , то следует использовать " расширенную " подсказку .

<!-- image -->

## Пример расширенной подсказки:

<!-- image -->

- 1 . 3 . Не рекомендуется выводить в подсказке много текста (более 255 символов , включая пробелы) . Если потребуется более длинная подсказка , то в ней можно дать ссылку на статью ИТС с подробным описанием .

## 2 . Текстовые подсказки к настройкам

- 2 . 1 . Текстовые подсказки к настройкам следует выводить внизу — под настройкой .

<!-- image -->

<!-- image -->

## Пользовательские представления объектов

Если для объекта метаданных определены свойства пользовательского представления , они заполняются следующим образом .

- 1 . Синоним объекта должен быть определен так , чтобы осмысленно , лаконично описывать объект . Заполняется обязательно .
- 2 . Представление объекта (для регистра ­ представление записи) . Задается название объекта в единственном числе , например , " Валюта " . Название должно быть лаконичным и понятным . Например , вместо " Версия проверяемой конфигурации " нужно использовать " Версия " .

См . также: Имя , синоним, м, комментарий, й, Тексты

Представление объекта заполняется в случае , если синоним не может быть использован , как название объекта в единственном числе .

- 3 . Расширенное представление объекта (для регистра ­ расширенное представление записи) . Задается полное название объекта в единственном числе . Заполняется в случае , когда название объекта , заданное в представлении объекта (или , если не заполнено , то ­ в синониме) менее информативно , чем его полное название . Например , в расширенном представлении объекта указано " Реализация товаров и услуг " , в то время как в представлении объекта указано " Реализация " .
- 4 . Представление списка . Задается название объектов во множественном числе , например , " Валюты " . Кроме этого , в некоторых случаях может указываться название списка , если оно является самостоятельным термином , например , «Классификатор единиц измерения» . Название должно быть лаконичным и понятным . Например , вместо " Общероссийский классификатор основных фондов " нужно использовать " Классификатор ОКОФ " .

Заполняется в случае , если синоним не может быть использован , как название списка объектов .

- 5 . Расширенное представление списка . Задается полное название списка объектов . Заполняется в случае , когда заданное в представлении списка (или , если не заполнено , то в синониме) название списка менее информативно , чем полное название списка .

Например , в расширенном представлении списка указано " Номенклатура (товары и услуги) " , представление списка не заполнено , а в синониме указано " Номенклатура " .

- 6 . Расширенное представление . Задается полное название объекта метаданных . Заполняется в случае , когда заданное в синониме название объекта менее информативно , чем его полное название .
- Например , синоним обработки ­ " Клиент банка " , а расширенное представление ­ " Клиент банка (обмен платежными документами) " .
- 7 . Пояснение . Задается пояснение по назначению данного объекта метаданных . Пояснение задается в виде законченных предложений . Заполняется для объектов метаданных , представление которых не достаточно точно передает их назначение .

Например , для справочника " Организации " пояснение может быть задано так: " Юридические лица и предприниматели нашей компании . " .

- 8 . Картинка . Задается для подсистем верхнего уровня с установленным флажком " Включать в командный интерфейс " . Размер картинки: 32 на 32 .

## См . также

- Приложение 3 . Правила формирования текстов стандартных команд и автоматических заголовков форм в документации к платформе 1С:Предприятие .

## Использование сочетаний клавиш , список зарезервированных сочетаний

Shift + (Up

,

,

,

Right)

,

изменение размеров элемента

карты

<!-- image -->

Shift + (Up

,

Down

,

Left

,

Right)

Выделение ячеек

,

изменение размеров элемента

карты

<!-- image -->

## Длительные операции на сервере

- 1 . При разработке конфигураций , поддерживающих работу через веб­клиент , следует избегать длительных вызовов из клиентского кода в серверный . Все длительные серверные вызовы , которые могут выполняться более 20 секунд * в обычных сценариях работы пользователя , следует выполнять асинхронно ** , с помощью фонового задания .
* Примечание: условная оценка предельной длительности серверного вызова , допустимая для распространенных браузеров и веб­серверов
- ** Примечание: при использовании платформы 1С:Предприятие 8 . 2 только в клиент­ т­ серверном режиме работы

К таким операциям относятся: формирование отчета , групповая обработка объектов , загрузка или выгрузка данных в другое приложение , заполнение больших табличных частей и т . п .

В противном случае такие вызовы могут привести к потере работоспособности приложения:

- из­за «зависания» браузера (как правило , браузеры предлагают прекратить выполнение скриптов на зависшей страницы или закрыть ее) ,
- либо из ­ за аварийного завершения с ошибкой превышения установленного времени ожидания вебсервера (или дополнительного программного обеспечения , установленного на веб­сервере) .
- 2 . 1 . Общий подход к асинхронному выполнению длительных серверных операций с помощью фонового задания:
- Код , выполняющий длительную обработку данных , располагается в модуле менеджера объекта ** или в общем модуле . Результат своей работы он помещает во временное хранилище;
- ** Примечание: необходимо использовать процедуру­обертку в общем модуле , которая будет вызывать процедуру модуля менеджера через Выполнить . Т. Т. к . фоновые задания могут работать только с процедурами и функциями общих модулей .
- Для выполнения этого кода на сервере запускается фоновое задание , при этом необходимо ожидать завершения выполнения фонового задания в течении 2 сек (а в режиме медленного соединения – 4 сек);
- Если за время ожидания выполнения задания оно не завершилось , то управление возвращается на клиент , и в клиентском коде подключается обработчик ожидания , в котором периодически проверяется состояние фонового задания . При этом интервал опроса задания увеличивается от 1 до 15 с фиксированным коэффициентом 1 . 4;
- На время выполнения длительной операции пользователю отображается индикатор; при этом для отчетов индикатор выводится в поле табличного документа , используя свойство поля табличного документа ОтображениеСостояния:

<!-- image -->

а для прочих мест – выводится блокирующая форма (РежимОткрытияОкна = БлокироватьОкноВладельца) , на которой размещена декорация с анимированной картинкой и кнопка «Отмена»:

<!-- image -->

- При получении от сервера информации о том , что фоновое задание завершено , полученный результат загружается из временного хранилища и обрабатывается .
- 2 . 2 . Асинхронное формирование отчета требуется только для тех отчетов , которые
- разработаны без использования СКД или с использованием СКД , но с переопределенной процедурой формирования отчета (переопределен обработчик кнопки «Сформировать» или в обработчике модуля отчета ПриКомпоновкеРезультата устанавливается СтандартнаяОбработка = Ложь) .
- и формирование которых , как правило , занимает длительное время .

Поведение таких отчетов должно быть максимально похожим на поведение отчетов на базе СКД , а именно:

- форму отчета не следует блокировать на время его формирования;
- пользователь может изменить настройки и переформировать отчет , не дожидаясь окончания его формирования;
- при закрытии формы отчета , формирование отчета прерывается .
- 3 . Пример заполнения табличной части Реализация документа ФормированиеЗаписейКнигиПродаж .

В модуле менеджера располагается процедура подготовки данных для заполнения табличной части:

```
Процедура ПодготовитьДанныеДляЗаполнения(ПараметрыДокумента , АдресХранилища) Экспорт ДанныеДляЗаполнения = Новый Структура; ДанныеДляЗаполнения . Вставить( " Реализация " , ПодготовитьДанныеРазделаРеализация(ПараметрыДокумента)); ПоместитьВоВременноеХранилище(ДанныеДляЗаполнения , АдресХранилища);
```

## КонецПроцедуры

В модуле формы документа располагается обработчик команды заполнения документа:

```
&НаКлиенте Процедура ЗаполнитьДокумент(Команда) ЗаданиеВыполнено = ЗаполнитьДокументНаСервере(); Если ЗаданиеВыполнено Тогда Возврат; КонецЕсли; // Операция еще не завершена , выполняется с помощью фонового задания (асинхронно) . ПараметрыОбработчикаОжидания = Новый Структура( " МинимальныйИнтервал , |МаксимальныйИнтервал , |ТекущийИнтервал , |КоэффициентУвеличенияИнтервала " , 1 , 15 , 1 , 1 . 4); ПодключитьОбработчикОжидания( " Подключаемый _ ПроверитьВыполнениеЗадания " , 1 , Истина); ФормаДлительнойОперации = ОткрытьФорму( " ОбщаяФорма . ДлительнаяОперация " , Новый Структура( " ИдентификаторЗадания " , ИдентификаторЗадания) , ЭтотОбъект); КонецПроцедуры
```

который передает управление серверной функции ЗаполнитьДокументНаСервере , инициализирует клиентскую переменную модуля формы ПараметрыОбработчикаОжидания , подключает обработчик ожидания Подключаемый \_ ПроверитьВыполнениеЗадания и открывает форму­индикатор выполнения длительной операции ОбщаяФорма . ДлительнаяОперация .

Серверная функция ЗаполнитьДокументНаСервере запускает подготовку в фоновом задании , в которое передает следующие параметры:

- Данные документа , необходимые для заполнения (работы алгоритма);
- АдресХранилища – адрес временного хранилища , в которое фоновое задание должно поместить результат выполнения операции .

Следует учитывать , что платформа 1С:Предприятие 8 . 2 не поддерживает фоновые задания в файловом режиме работы , поэтому , если конфигурация поддерживает работу на данной версии платформы , в

```
файловом режиме подготовку данных необходимо выполнять непосредственно . &НаСервере Функция ЗаполнитьДокументНаСервере() ПараметрыДокумента = Новый Структура( " Дата , Организация , Реализация0 " , Объект . Дата , Объект . Организация , Объект . Реализация0); АдресХранилища = ПоместитьВоВременноеХранилище(Неопределено , УникальныйИдентификатор); ЗаданиеВыполнено = Ложь; // В файловом режиме работы выполняем операцию непосредственно (синхронно) . Если ИнформационнаяБазаФайловая() Тогда Документы . ФормированиеЗаписейКнигиПродаж . ПодготовитьДанныеДляЗаполнения(ПараметрыДокумента , АдресХранилища); Возврат Истина; КонецЕсли; // Выполнение операции в фоновом задании (асинхронно) . НаименованиеЗадания = НСтр( " ru = ' Заполнение документа "" Формирование записей книги продаж "" ' " ); ПараметрыЗаполнения = Новый Массив; ПараметрыЗаполнения . Добавить(ПараметрыДокумента); ПараметрыЗаполнения . Добавить(АдресХранилища); Если ПолучитьСкоростьКлиентскогоСоединения() = СкоростьКлиентскогоСоединения . Низкая Тогда ВремяОжидания = 4; Иначе ВремяОжидания = 2; КонецЕсли; Задание = ФоновыеЗадания . Выполнить( " Документы . ФормированиеЗаписейКнигиПродаж . ПодготовитьДанныеДляЗаполнения " , ПараметрыЗаполнения , , НаименованиеЗадания); Попытка Задание . ОжидатьЗавершения(ВремяОжидания); Исключение // Специальная обработка не требуется . Предположительно , исключение вызвано истечением времени ожидания . КонецПопытки; ИдентификаторЗадания = Задание . УникальныйИдентификатор; // Если операция уже завершилась , то сразу обрабатываем результат . Если ЗаданиеВыполнено(Задание . УникальныйИдентификатор) Тогда ЗаданиеВыполнено = Истина; ЗагрузитьПодготовленныеДанные(); КонецЕсли; Возврат ЗаданиеВыполнено; КонецФункции Обработчик ожидания в модуле формы проверяет , завершено ли фоновое задание и загружает результат из временного хранилища с помощью вызовы процедуры ЗагрузитьПодготовленныеДанные: &НаКлиенте Процедура Подключаемый _ ПроверитьВыполнениеЗадания() Попытка Если ЗаданиеВыполнено() Тогда ЗагрузитьПодготовленныеДанные(); ЗакрытьФормуДлительнойОперации(); Возврат; КонецЕсли;
```

```
Исключение ЗакрытьФормуДлительнойОперации(); ВызватьИсключение; КонецПопытки; ПараметрыОбработчикаОжидания . ТекущийИнтервал = ПараметрыОбработчикаОжидания . ТекущийИнтервал * ПараметрыОбработчикаОжидания . КоэффициентУвеличенияИнтервала; Если ПараметрыОбработчикаОжидания . ТекущийИнтервал > ПараметрыОбработчикаОжидания . МаксимальныйИнтервал Тогда ПараметрыОбработчикаОжидания . ТекущийИнтервал = ПараметрыОбработчикаОжидания . МаксимальныйИнтервал; КонецЕсли; ПодключитьОбработчикОжидания( " Подключаемый _ ПроверитьВыполнениеЗадания " , ПараметрыОбработчикаОжидания . ТекущийИнтервал , Истина); КонецПроцедуры &НаСервере Процедура ЗагрузитьПодготовленныеДанные() Результат = ПолучитьИзВременногоХранилища(АдресХранилища); Если ТипЗнч(СтруктураДанных) <> Тип( " Структура " ) Тогда Возврат; КонецЕсли; Если СтруктураДанных . Свойство( " Реализация " ) Тогда Объект . Реализация . Загрузить(СтруктураДанных . Реализация); КонецЕсли; КонецПроцедуры В приложении ниже приведен пример реализации вспомогательных функций
```

ЗакрытьФормуДлительнойОперации

,

ИнформационнаяБазаФайловая

и ЗаданиеВыполнено

.

- 4 . При использовании в конфигурации Библиотеки стандартных подсистем в распоряжении разработчика имеются вспомогательные функции и процедуры общих модулей ДлительныеОперации , ДлительныеОперацииКлиент , а также процедура УстановитьСостояниеПоляТабличногоДокумента общего модуля ОбщегоНазначенияКлиентСервер .
- 5 . Если в конфигурации реализуются алгоритмы , инициирующие запуск фоновых заданий или запись данных информационной базы без участия пользователя (например , регулярное обновление информации в открытой форме) , то в них следует проверять , что в текущем сеансе не установлен монопольный режим . В противном случае , следует блокировать попытки выполнения таких действий . Например:
- 6 . В некоторых случаях возникает необходимость в выполнении длительных операций , требующих установки монопольного режима доступа к информационной базе . Например:
- Обновление данных ИБ при первом интерактивном запуске программы после обновления конфигурации;
- Удаление объектов , помеченных на удаление;
- Выгрузка данных информационной базы в файл для перехода в сервис;
- Использования монопольного режима для снижения времени выполнения массовых операций по изменению данных;

```
Если МонопольныйРежим() Тогда Возврат; КонецЕсли; ФоновыеЗадания . Выполнить( " . . .
```

При этом необходимо сначала устанавливать монопольный режим , а затем выполнять запуск фонового задания , которое реализует саму длительную операцию . В этом случае фоновым заданием будет унаследован монопольный режим , ранее установленный из пользовательского сеанса (см . документацию к платформе) .

На время выполнения этого фонового задания следует блокировать весь интерфейс приложения , открывая форму ожидания завершения операции в режиме РежимОткрытияОкна = БлокироватьВесьИнтерфейс . Блокировать интерфейс приложения требуется потому , что на время выполнения задания полноценная работа пользователя с приложением уже невозможна:

- Если пользователь( * ) попытается записать какой­либо объект , это приведет к ошибке (из­за установленного монопольного режима);
- В ряде случаев могут запускаться фоновые задания в качестве реакции на действия пользователя случае (при поиске в динамическом списке , при вводе по строке , формировании отчетов и пр . ) , которые также завершатся с ошибкой . Кроме того , на самой форме ожидания длительной операции не следует размещать элементы управления , которые могут приводить к запуску таких фоновых заданий . Например: поля ввода , динамические списки и отчеты .
* Примечание: ошибки записи также возникают в тех случаях, х, когда объекты записываются программно , например , из обработчиков ожидания . В них также следует проверять монопольный режим согласно п . 4 .

## Приложение . Вспомогательные функции .

```
&НаКлиенте Процедура ЗакрытьФормуДлительнойОперации() Если ТипЗнч(ФормаДлительнойОперации) = Тип( " УправляемаяФорма " ) Тогда Если ФормаДлительнойОперации . Открыта() Тогда ФормаДлительнойОперации . Закрыть(); КонецЕсли; КонецЕсли; КонецПроцедуры &НаСервереБезКонтекста Функция ИнформационнаяБазаФайловая(СтрокаСоединенияИнформационнойБазы = "" ) Экспорт Если ПустаяСтрока(СтрокаСоединенияИнформационнойБазы) Тогда СтрокаСоединенияИнформационнойБазы = СтрокаСоединенияИнформационнойБазы(); КонецЕсли; Возврат Найти(Врег(СтрокаСоединенияИнформационнойБазы) , " FILE= " ) = 1; КонецФункции &НаСервере Функция ЗаданиеВыполнено() Задание = НайтиЗаданиеПоИдентификатору(ИдентификаторЗадания); Если Задание <> Неопределено И Задание . Состояние = СостояниеФоновогоЗадания . Активно Тогда Возврат Ложь; КонецЕсли; Если Задание = Неопределено Тогда ТекстКомментария = СтроковыеФункцииКлиентСервер . ПодставитьПараметрыВСтроку( НСтр( " ru = ' Фоновое задание (id=%1) не найдено ' " ) , ИдентификаторЗадания); ЗаписьЖурналаРегистрации(НСтр( " ru = ' Длительная операция ' " ) , УровеньЖурналаРегистрации . Ошибка , , , ТекстКомментария); ИначеЕсли Задание . Состояние = СостояниеФоновогоЗадания . ЗавершеноАварийно Тогда ОшибкаЗадания = Задание . ИнформацияОбОшибке; Если ОшибкаЗадания <> Неопределено Тогда ЗаписьЖурналаРегистрации(НСтр( " ru = ' Длительная операция ' " ) , УровеньЖурналаРегистрации . Ошибка , , , ПодробноеПредставлениеОшибки(ОшибкаЗадания)); Иначе ЗаписьЖурналаРегистрации(НСтр( " ru = ' Длительная операция ' " ) , УровеньЖурналаРегистрации . Ошибка , , , НСтр( " ru = ' Задание завершилось с неизвестной ошибкой . ' " )); КонецЕсли; ИначеЕсли Задание . Состояние = СостояниеФоновогоЗадания . Отменено Тогда ЗаписьЖурналаРегистрации(НСтр( " ru = ' Длительная операция ' " ) , УровеньЖурналаРегистрации . Ошибка , , ,
```

<!-- image -->

## См . также

- Длительные операции на клиенте