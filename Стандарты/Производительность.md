# Стандарт производительности

**Версия:** 1.0  
**Приоритет:** Критичный  
**Источник:** Разделы 10, 11, 14. Оптимизация запросов, транзакций, работы с данными

---

## Описание

Стандарт определяет правила оптимизации производительности конфигурации 1С:Предприятие. Включает требования к оптимизации запросов, работе с транзакциями, избеганию длинных транзакций и блокирующего чтения остатков.

---

## Избегание длинных транзакций

**Правило:** Следует минимизировать время выполнения транзакций для повышения параллельности системы.

```bsl
// ❌ НЕПРАВИЛЬНО: Длинная транзакция с множеством операций
НачатьТранзакцию();
Попытка
    // Множество операций записи
    Для Каждого Элемент Из БольшаяКоллекция Цикл
        НовыйОбъект = Справочники.Товары.СоздатьЭлемент();
        НовыйОбъект.Наименование = Элемент.Наименование;
        НовыйОбъект.Записать();
    КонецЦикла;
    
    // Долгие вычисления
    ВыполнитьДолгиеВычисления();
    
    ЗафиксироватьТранзакцию();
Исключение
    ОтменитьТранзакцию();
    ВызватьИсключение;
КонецПопытки;

// ✅ ПРАВИЛЬНО: Короткая транзакция, вычисления вне транзакции
// Выполнить вычисления ДО транзакции
РезультатВычислений = ВыполнитьДолгиеВычисления();

НачатьТранзакцию();
Попытка
    // Только операции записи
    Для Каждого Элемент Из БольшаяКоллекция Цикл
        НовыйОбъект = Справочники.Товары.СоздатьЭлемент();
        НовыйОбъект.Наименование = Элемент.Наименование;
        НовыйОбъект.Записать();
    КонецЦикла;
    
    ЗафиксироватьТранзакцию();
Исключение
    ОтменитьТранзакцию();
    ВызватьИсключение;
КонецПопытки;
```

**Источник:** Раздел 11. Транзакции и блокировки (строки 3387-3670)

---

## Блокирующее чтение остатков в начале транзакции

**Правило:** Блокирующее чтение остатков следует выполнять в конце транзакции, а не в начале.

```bsl
// ❌ НЕПРАВИЛЬНО: Блокировка остатков в начале транзакции
НачатьТранзакцию();
Попытка
    // Блокировка остатков в начале транзакции
    Запрос = Новый Запрос("ВЫБРАТЬ СуммаОстаток ИЗ РегистрБухгалтерии.Хозрасчетный.Остатки(&Период, &Счет) ДЛЯ ИЗМЕНЕНИЯ");
    Запрос.УстановитьПараметр("Период", ТекущаяДата());
    Запрос.УстановитьПараметр("Счет", Счет);
    Результат = Запрос.Выполнить();
    
    // Долгие операции записи других регистров
    ЗаписатьДвиженияПоДругимРегистрам();
    
    ЗафиксироватьТранзакцию();
Исключение
    ОтменитьТранзакцию();
    ВызватьИсключение;
КонецПопытки;

// ✅ ПРАВИЛЬНО: Блокировка остатков в конце транзакции
НачатьТранзакцию();
Попытка
    // Сначала записываем регистры, не требующие контроля остатков
    ЗаписатьДвиженияПоПриходнымРегистрам();
    
    // В конце транзакции блокируем остатки для контроля
    НаборЗаписей = РегистрыБухгалтерии.Хозрасчетный.СоздатьНаборЗаписей();
    НаборЗаписей.БлокироватьДляИзменения = Истина; // Блокировка для контроля остатков
    НаборЗаписей.Отбор.Период.Установить(ТекущаяДата());
    НаборЗаписей.Отбор.Счет.Установить(Счет);
    НаборЗаписей.Записать();
    
    // Контроль остатков (уже заблокированы записью выше)
    Запрос = Новый Запрос("ВЫБРАТЬ СуммаОстаток ИЗ РегистрБухгалтерии.Хозрасчетный.Остатки(&Период, &Счет) ГДЕ СуммаОстаток < 0");
    Запрос.УстановитьПараметр("Период", ТекущаяДата());
    Запрос.УстановитьПараметр("Счет", Счет);
    Результат = Запрос.Выполнить();
    
    Если НЕ Результат.Пустой() Тогда
        ВызватьИсключение "Отрицательные остатки!";
    КонецЕсли;
    
    ЗафиксироватьТранзакцию();
Исключение
    ОтменитьТранзакцию();
    ВызватьИсключение;
КонецПопытки;
```

**Источник:** Раздел 11. Блокирующее чтение остатков (строки 3800-3828)

---

## Использование транзакций при чтении данных

**Правило:** Использование транзакций при чтении данных оправдано только для обеспечения консистентности данных в рамках одной операции.

```bsl
// ❌ НЕПРАВИЛЬНО: Транзакция для простого чтения
НачатьТранзакцию();
Попытка
    Запрос = Новый Запрос("ВЫБРАТЬ * ИЗ Справочник.Товары");
    Результат = Запрос.Выполнить();
    ЗафиксироватьТранзакцию();
Исключение
    ОтменитьТранзакцию();
КонецПопытки;

// ✅ ПРАВИЛЬНО: Чтение без транзакции (если не требуется консистентность)
Запрос = Новый Запрос("ВЫБРАТЬ * ИЗ Справочник.Товары");
Результат = Запрос.Выполнить();
```

**Источник:** Раздел 11. Использование транзакций при чтении данных (строки 3387-3670)

---

## Оптимизация запросов

**Правило:** Следует минимизировать объем выборки и количество запросов к СУБД.

### Минимизация объема выборки

```bsl
// ❌ НЕПРАВИЛЬНО: Выборка всех полей "на всякий случай"
Запрос.Текст = "ВЫБРАТЬ * ИЗ Справочник.Номенклатура";

// ✅ ПРАВИЛЬНО: Выборка только необходимых полей
Запрос.Текст = "ВЫБРАТЬ Номенклатура.Ссылка, Номенклатура.Наименование ИЗ Справочник.Номенклатура КАК Номенклатура";
```

### Минимизация количества запросов

```bsl
// ❌ НЕПРАВИЛЬНО: Множественные запросы в цикле (N+1)
Для Каждого Склад Из Склады Цикл
    Запрос = Новый Запрос("ВЫБРАТЬ * ИЗ РегистрНакопления.ТоварыНаСкладах.Остатки(, Склад = &Склад)");
    Запрос.УстановитьПараметр("Склад", Склад);
    Результат = Запрос.Выполнить();
КонецЦикла;

// ✅ ПРАВИЛЬНО: Один запрос для всех складов
Запрос = Новый Запрос("ВЫБРАТЬ * ИЗ РегистрНакопления.ТоварыНаСкладах.Остатки(, Склад В(&Склады))");
Запрос.УстановитьПараметр("Склады", Склады);
Результат = Запрос.Выполнить();
```

**Источник:** Раздел 10. Общие требования по разработке оптимальных запросов (строки 2763-2798)

---

## Несоответствие индексов и условий запроса

**Правило:** Для всех условий запроса должны существовать подходящие индексы.

**Требования к подходящему индексу:**
1. Индекс содержит все поля, перечисленные в условии
2. Эти поля находятся в самом начале индекса
3. Эти поля идут подряд (без "вклинивания" других полей)

```bsl
// ❌ НЕПРАВИЛЬНО: Отсутствие условия по первому полю индекса
// Регистр: измерения [Склад, Номенклатура]
Запрос.Текст = 
"ВЫБРАТЬ
|    ТоварыНаСкладахОстатки.Номенклатура
|ИЗ
|    РегистрНакопления.ТоварыНаСкладах.Остатки(, Номенклатура = &Номенклатура) КАК ТоварыНаСкладахОстатки";
// Проблема: отсутствует условие по первому измерению (Склад)

// ✅ ПРАВИЛЬНО: Условие по всем измерениям индекса
Запрос.Текст = 
"ВЫБРАТЬ
|    ТоварыНаСкладахОстатки.Номенклатура
|ИЗ
|    РегистрНакопления.ТоварыНаСкладах.Остатки(, Склад = &Склад И Номенклатура = &Номенклатура) КАК ТоварыНаСкладахОстатки";
```

**Источник:** Раздел 10.9. Несоответствие индексов и условий запроса (строки 2801-2889)

---

## Избыточные блокировки

**Правило:** Следует избегать избыточных блокировок данных, которые не требуются для выполнения операции.

```bsl
// ❌ НЕПРАВИЛЬНО: Блокировка для чтения без необходимости изменения
НачатьТранзакцию();
Попытка
    Запрос = Новый Запрос("ВЫБРАТЬ * ИЗ Справочник.Товары ДЛЯ ИЗМЕНЕНИЯ");
    Результат = Запрос.Выполнить();
    // Только чтение данных, без изменения
    ЗафиксироватьТранзакцию();
Исключение
    ОтменитьТранзакцию();
КонецПопытки;

// ✅ ПРАВИЛЬНО: Блокировка только при необходимости изменения
НачатьТранзакцию();
Попытка
    Запрос = Новый Запрос("ВЫБРАТЬ * ИЗ Справочник.Товары");
    Результат = Запрос.Выполнить();
    // Только чтение - блокировка не требуется
    ЗафиксироватьТранзакцию();
Исключение
    ОтменитьТранзакцию();
КонецПопытки;
```

**Источник:** Раздел 11. Избыточные блокировки (строки 3387-3670)

---

## Чтение отдельных реквизитов объекта из базы данных

**Правило:** При чтении объекта из базы данных следует читать только необходимые реквизиты, а не весь объект.

```bsl
// ❌ НЕПРАВИЛЬНО: Чтение всего объекта для получения одного реквизита
Объект = Справочники.Товары.Получить(Ссылка);
Наименование = Объект.Наименование;

// ✅ ПРАВИЛЬНО: Чтение только необходимого реквизита через запрос
Запрос = Новый Запрос("ВЫБРАТЬ Номенклатура.Наименование ИЗ Справочник.Номенклатура КАК Номенклатура ГДЕ Номенклатура.Ссылка = &Ссылка");
Запрос.УстановитьПараметр("Ссылка", Ссылка);
Результат = Запрос.Выполнить();
Если НЕ Результат.Пустой() Тогда
    Наименование = Результат.Выбрать().Следующий().Наименование;
КонецЕсли;
```

**Источник:** Раздел 11. Чтение отдельных реквизитов объекта (строки 3387-3670)

---

## Чек-лист проверки

- [ ] Транзакции выполняются быстро (минимизировано время блокировки)
- [ ] Блокирующее чтение остатков выполняется в конце транзакции
- [ ] Транзакции при чтении используются только при необходимости консистентности
- [ ] Запросы минимизируют объем выборки (не используется `ВЫБРАТЬ *`)
- [ ] Избегается многократное выполнение однотипных запросов (N+1)
- [ ] Условия запросов соответствуют индексам
- [ ] Избегаются избыточные блокировки
- [ ] Читаются только необходимые реквизиты объектов

---

**Ссылки на исходный документ:**
- Раздел 10: Работа с запросами (строки 2417-3386)
- Раздел 11: Транзакции и блокировки (строки 3387-3670)
- Раздел 11. Блокирующее чтение остатков (строки 3800-3828)

